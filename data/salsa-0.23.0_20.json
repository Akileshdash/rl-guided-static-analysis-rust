{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `tracked_struct::IngredientImpl::<C>::update`",
    "file": "salsa-0.23.0/src/tracked_struct.rs",
    "start_line": 494,
    "start_col": 5,
    "end_line": 623,
    "end_col": 6,
    "code_snippet": "unsafe fn update<'db>(\n        &'db self,\n        zalsa: &'db Zalsa,\n        current_revision: Revision,\n        mut id: Id,\n        current_deps: &Stamp,\n        fields: C::Fields<'db>,\n    ) -> Result<Id, C::Fields<'db>> {\n        let data_raw = Self::data_raw(zalsa.table(), id);\n\n        // The protocol is:\n        //\n        // * When we begin updating, we store `None` in the `updated_at` field\n        // * When completed, we store `Some(current_revision)` in `updated_at`\n        //\n        // No matter what mischief users get up to, it should be impossible for us to\n        // observe `None` in `updated_at`. The `id` should only be associated with one\n        // query and that query can only be running in one thread at a time.\n        //\n        // We *can* observe `Some(current_revision)` however, which means that this\n        // tracked struct is already updated for this revision in two ways.\n        // In that case we should not modify or touch it because there may be\n        // `&`-references to its contents floating around.\n        //\n        // Observing `Some(current_revision)` can happen in two scenarios: leaks (tsk tsk)\n        // but also the scenario embodied by the test test `test_run_5_then_20` in `specify_tracked_fn_in_rev_1_but_not_2.rs`:\n        //\n        // * Revision 1:\n        //   * Tracked function F creates tracked struct S\n        //   * F reads input I\n        // * Revision 2: I is changed, F is re-executed\n        //\n        // When F is re-executed in rev 2, we first try to validate F's inputs/outputs,\n        // which is the list [output: S, input: I]. As no inputs have changed by the time\n        // we reach S, we mark it as verified. But then input I is seen to have changed,\n        // and so we re-execute F. Note that we *know* that S will have the same value\n        // (barring program bugs).\n        //\n        // Further complicating things: it is possible that F calls F2\n        // and gives it (e.g.) S as one of its arguments. Validating F2 may cause F2 to\n        // re-execute which means that it may indeed have read from S's fields\n        // during the current revision and thus obtained an `&` reference to those fields\n        // that is still live.\n\n        {\n            // SAFETY: Guaranteed by caller.\n            let data = unsafe { &*data_raw };\n\n            let last_updated_at = data.updated_at.load();\n            assert!(\n                last_updated_at.is_some(),\n                \"two concurrent writers to {id:?}, should not be possible\"\n            );\n\n            // The value is already read-locked, but we can reuse it safely as per above.\n            if last_updated_at == Some(current_revision) {\n                return Ok(id);\n            }\n\n            // Updating the fields may make it necessary to increment the generation of the ID. In\n            // the unlikely case that the ID is already at its maximum generation, we are forced to leak\n            // the previous slot and allocate a new value.\n            if id.generation() == u32::MAX {\n                tracing::info!(\n                    \"leaking tracked struct {:?} due to generation overflow\",\n                    self.database_key_index(id)\n                );\n\n                return Err(fields);\n            }\n\n            // Acquire the write-lock. This can only fail if there is a parallel thread\n            // reading from this same `id`, which can only happen if the user has leaked it.\n            // Tsk tsk.\n            let swapped_out = data.updated_at.swap(None);\n            if swapped_out != last_updated_at {\n                panic!(\n                \"failed to acquire write lock, id `{id:?}` must have been leaked across threads\"\n            );\n            }\n        }\n\n        // UNSAFE: Marking as mut requires exclusive access for the duration of\n        // the `mut`. We have now *claimed* this data by swapping in `None`,\n        // any attempt to read concurrently will panic.\n        let data = unsafe { &mut *data_raw };\n\n        // SAFETY: We assert that the pointer to `data.revisions`\n        // is a pointer into the database referencing a value\n        // from a previous revision. As such, it continues to meet\n        // its validity invariant and any owned content also continues\n        // to meet its safety invariant.\n        let untracked_update = unsafe {\n            C::update_fields(\n                current_deps.changed_at,\n                &mut data.revisions,\n                mem::transmute::<*mut C::Fields<'static>, *mut C::Fields<'db>>(\n                    std::ptr::addr_of_mut!(data.fields),\n                ),\n                fields,\n            )\n        };\n\n        if untracked_update {\n            // Consider this a new tracked-struct when any non-tracked field got updated.\n            // This should be rare and only ever happen if there's a hash collision.\n            //\n            // Note that we hold the lock and have exclusive access to the tracked struct data,\n            // so there should be no live instances of IDs from the previous generation. We clear\n            // the memos and return a new ID here as if we have allocated a new slot.\n            let mut table = data.take_memo_table();\n\n            // SAFETY: The memo table belongs to a value that we allocated, so it has the\n            // correct type.\n            unsafe { self.clear_memos(zalsa, &mut table, id) };\n\n            id = id\n                .next_generation()\n                .expect(\"already verified that generation is not maximum\");\n        }\n\n        if current_deps.durability < data.durability {\n            data.revisions = C::new_revisions(current_deps.changed_at);\n        }\n        data.durability = current_deps.durability;\n        let swapped_out = data.updated_at.swap(Some(current_revision));\n        assert!(swapped_out.is_none());\n\n        Ok(id)\n    }"
}