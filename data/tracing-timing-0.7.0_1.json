{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `Timing::<S, E>::time`",
    "file": "tracing-timing-0.7.0/src/lib.rs",
    "start_line": 431,
    "start_col": 5,
    "end_line": 542,
    "end_col": 6,
    "code_snippet": "fn time<'a, F>(&self, event: &Event, mut for_each_parent: F)\n    where\n        S: 'a,\n        F: FnMut(&mut dyn FnMut(&SpanState<S::Id>) -> bool),\n    {\n        let start = self.time.raw();\n        let inner = self.writers.read().unwrap();\n\n        let record = move |state: &SpanState<S::Id>, r: &mut Recorder<u64>| {\n            // NOTE: we substitute in the last possible timestamp to avoid measuring time spent\n            // in accessing the various timing datastructures (like taking locks). this has the\n            // effect of measuing \u0394t\u2081\u2082 = e\u2082.start - e\u2081.end, which is probably what users expect\n            let previous = state\n                .last_event\n                .swap(self.time.raw(), atomic::Ordering::AcqRel);\n            if previous > start {\n                // someone else recorded a sample _just_ now\n                // the delta is effectively zero, but recording a 0 sample is misleading\n                return;\n            }\n\n            r.saturating_record(self.time.delta(previous, start).as_nanos() as u64)\n        };\n\n        // who are we?\n        let tid = ThreadId::default();\n\n        // fast path: sid/eid pair is known to this thread\n        let eid = self.event_group.group(event);\n        if let Some(ref tls) = inner.tls.get(&tid) {\n            // we know no-one else has our TID:\n            // NOTE: it's _not_ safe to use this after we drop the lock due to force_synchronize.\n            let tls = unsafe { &mut *tls.get() };\n\n            for_each_parent(&mut |state| {\n                // the span id _must_ be known, as it's added when created\n                if let Some(ref mut recorder) =\n                    tls.get_mut(&state.group).and_then(|rs| rs.get_mut(&eid))\n                {\n                    // sid/eid already known and we already have a thread-local recorder!\n                    record(state, recorder);\n                } else if let Some(ref ir) = inner.idle_recorders[&state.group].get(&eid) {\n                    // we didn't know about the eid, but if there's already a recorder for it,\n                    // we can just create a local recorder from it and move on\n                    let mut recorder = ir.recorder();\n                    record(state, &mut recorder);\n                    let r = tls\n                        .entry(state.group.clone())\n                        .or_insert_with(Default::default)\n                        .insert(eid.clone(), recorder);\n                    assert!(r.is_none());\n                } else {\n                    // we're the first thread to see this pair, so we need to make a histogram for it\n                    return false;\n                }\n\n                // keep recording up the stack\n                self.bubble_spans\n            });\n\n        // at least one sid/eid pair was unknown\n        } else {\n            // this thread does not yet have TLS -- we'll have to take the lock\n        }\n\n        // slow path: either this thread is new, or a sid/eid pair was new\n        // in either case, we need to take the write lock\n        // to do that, we must first drop the read lock\n        drop(inner);\n        let mut inner = self.writers.write().unwrap();\n        let inner = &mut *inner;\n\n        // if we don't have any thread-local state, construct that first\n        let tls = inner.tls.entry(tid).or_insert_with(Default::default);\n        // no-one else has our TID _and_ we have exclusive access to inner\n        let tls = unsafe { &mut *tls.get() };\n\n        // use an existing recorder if one exists, or make a new histogram if one does not\n        let nh = &mut inner.new_histogram;\n        let created = &mut inner.created;\n        let idle = &mut inner.idle_recorders;\n        for_each_parent(&mut |state| {\n            // since we're recursing up the tree, we _may_ find that we already have a recorder for\n            // a _later_ span's sid/eid. make sure we don't create a new one in that case!\n            let recorder = tls\n                .entry(state.group.clone())\n                .or_insert_with(Default::default)\n                .entry(eid.clone())\n                .or_insert_with(|| {\n                    // nope, get us a thread-local recorder\n                    idle.get_mut(&state.group)\n                        .unwrap()\n                        .entry(eid.clone())\n                        .or_insert_with(|| {\n                            // no histogram exists! make one.\n                            let h = (nh)(&state.group, &eid).into_sync();\n                            let ir = h.recorder().into_idle();\n                            created.send((state.group.clone(), eid.clone(), h)).expect(\n                                \"WriterState implies ReaderState, which holds the receiver\",\n                            );\n                            ir\n                        })\n                        .recorder()\n                });\n\n            // finally, we can record the sample\n            record(state, recorder);\n\n            // recurse to parent if any\n            self.bubble_spans\n        });\n    }"
}