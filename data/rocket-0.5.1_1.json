{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `form::buffer::SharedStack::<T>::push`",
    "file": "rocket-0.5.1/src/form/buffer.rs",
    "start_line": 52,
    "start_col": 5,
    "end_line": 81,
    "end_col": 6,
    "code_snippet": "pub(crate) fn push<S: Into<T>>(&self, string: S) -> &T::Target {\n        // SAFETY:\n        //   * Aliasing: We retrieve a mutable reference to the last slot (via\n        //     `push()`) and then return said reference as immutable; these\n        //     occur in serial, so they don't alias. This method accesses a\n        //     unique slot each call: the last slot, subsequently replaced by\n        //     `push()` each next call. No other method accesses the internal\n        //     buffer directly. Thus, the outstanding reference to the last slot\n        //     is never accessed again mutably, preserving aliasing guarantees.\n        //   * Liveness: The returned reference is to a `String`; we must ensure\n        //     that the `String` is never dropped while `self` lives. This is\n        //     guaranteed by returning a reference with the same lifetime as\n        //     `self`, so `self` can't be dropped while the string is live, and\n        //     by never removing elements from the internal `Vec` thus not\n        //     dropping `String` itself: `push()` is the only mutating operation\n        //     called on `Vec`, which preserves all previous elements; the\n        //     stability of `String` itself means that the returned address\n        //     remains valid even after internal realloc of `Vec`.\n        //   * Thread-Safety: Parallel calls to `push_one` without exclusion\n        //     would result in a race to `vec.push()`; `RawMutex` ensures that\n        //     this doesn't occur.\n        unsafe {\n            self.mutex.lock();\n            let vec: &mut Vec<T> = &mut *self.stack.get();\n            vec.push(string.into());\n            let last = vec.last().expect(\"push() => non-empty\");\n            self.mutex.unlock();\n            last\n        }\n    }"
}