{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<datatypes::visible_time_range::VisibleTimeRange as loggable::Loggable>::to_arrow_opt`",
    "file": "re_types_core-0.24.0/src/datatypes/visible_time_range.rs",
    "start_line": 53,
    "start_col": 5,
    "end_line": 144,
    "end_col": 6,
    "code_snippet": "fn to_arrow_opt<'a>(\n        data: impl IntoIterator<Item = Option<impl Into<::std::borrow::Cow<'a, Self>>>>,\n    ) -> SerializationResult<arrow::array::ArrayRef>\n    where\n        Self: Clone + 'a,\n    {\n        #![allow(clippy::wildcard_imports)]\n        #![allow(clippy::manual_is_variant_and)]\n        use crate::{arrow_helpers::as_array_ref, Loggable as _, ResultExt as _};\n        use arrow::{array::*, buffer::*, datatypes::*};\n        Ok({\n            let fields = Fields::from(vec![\n                Field::new(\n                    \"timeline\",\n                    <crate::datatypes::Utf8>::arrow_datatype(),\n                    false,\n                ),\n                Field::new(\n                    \"range\",\n                    <crate::datatypes::TimeRange>::arrow_datatype(),\n                    false,\n                ),\n            ]);\n            let (somes, data): (Vec<_>, Vec<_>) = data\n                .into_iter()\n                .map(|datum| {\n                    let datum: Option<::std::borrow::Cow<'a, Self>> = datum.map(Into::into);\n                    (datum.is_some(), datum)\n                })\n                .unzip();\n            let validity: Option<arrow::buffer::NullBuffer> = {\n                let any_nones = somes.iter().any(|some| !*some);\n                any_nones.then(|| somes.into())\n            };\n            as_array_ref(StructArray::new(\n                fields,\n                vec![\n                    {\n                        let (somes, timeline): (Vec<_>, Vec<_>) = data\n                            .iter()\n                            .map(|datum| {\n                                let datum = datum.as_ref().map(|datum| datum.timeline.clone());\n                                (datum.is_some(), datum)\n                            })\n                            .unzip();\n                        let timeline_validity: Option<arrow::buffer::NullBuffer> = {\n                            let any_nones = somes.iter().any(|some| !*some);\n                            any_nones.then(|| somes.into())\n                        };\n                        {\n                            let offsets = arrow::buffer::OffsetBuffer::<i32>::from_lengths(\n                                timeline.iter().map(|opt| {\n                                    opt.as_ref().map(|datum| datum.0.len()).unwrap_or_default()\n                                }),\n                            );\n                            #[allow(clippy::unwrap_used)]\n                            let capacity = offsets.last().copied().unwrap() as usize;\n                            let mut buffer_builder =\n                                arrow::array::builder::BufferBuilder::<u8>::new(capacity);\n                            for data in timeline.iter().flatten() {\n                                buffer_builder.append_slice(data.0.as_bytes());\n                            }\n                            let inner_data: arrow::buffer::Buffer = buffer_builder.finish();\n\n                            #[allow(unsafe_code, clippy::undocumented_unsafe_blocks)]\n                            as_array_ref(unsafe {\n                                StringArray::new_unchecked(offsets, inner_data, timeline_validity)\n                            })\n                        }\n                    },\n                    {\n                        let (somes, range): (Vec<_>, Vec<_>) = data\n                            .iter()\n                            .map(|datum| {\n                                let datum = datum.as_ref().map(|datum| datum.range.clone());\n                                (datum.is_some(), datum)\n                            })\n                            .unzip();\n                        let range_validity: Option<arrow::buffer::NullBuffer> = {\n                            let any_nones = somes.iter().any(|some| !*some);\n                            any_nones.then(|| somes.into())\n                        };\n                        {\n                            _ = range_validity;\n                            crate::datatypes::TimeRange::to_arrow_opt(range)?\n                        }\n                    },\n                ],\n                validity,\n            ))\n        })\n    }"
}