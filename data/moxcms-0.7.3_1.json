{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `conversions::avx::rgb_xyz_q2_13_opt::TransformShaperRgbQ2_13OptAvx::<T, SRC_LAYOUT, DST_LAYOUT, LINEAR_CAP, GAMMA_LUT, BIT_DEPTH, PRECISION>::transform_avx2`",
    "file": "moxcms-0.7.3/src/conversions/avx/rgb_xyz_q2_13_opt.rs",
    "start_line": 71,
    "start_col": 5,
    "end_line": 290,
    "end_col": 6,
    "code_snippet": "unsafe fn transform_avx2(&self, src: &[T], dst: &mut [T]) -> Result<(), CmsError> {\n        let src_cn = Layout::from(SRC_LAYOUT);\n        let dst_cn = Layout::from(DST_LAYOUT);\n        let src_channels = src_cn.channels();\n        let dst_channels = dst_cn.channels();\n\n        let mut temporary0 = AvxAlignedU16([0; 16]);\n\n        if src.len() / src_channels != dst.len() / dst_channels {\n            return Err(CmsError::LaneSizeMismatch);\n        }\n        if src.len() % src_channels != 0 {\n            return Err(CmsError::LaneMultipleOfChannels);\n        }\n        if dst.len() % dst_channels != 0 {\n            return Err(CmsError::LaneMultipleOfChannels);\n        }\n\n        let t = self.profile.adaptation_matrix.transpose();\n\n        let max_colors = ((1 << BIT_DEPTH) - 1).as_();\n\n        unsafe {\n            let m0 = _mm256_setr_epi16(\n                t.v[0][0], t.v[1][0], t.v[0][1], t.v[1][1], t.v[0][2], t.v[1][2], 0, 0, t.v[0][0],\n                t.v[1][0], t.v[0][1], t.v[1][1], t.v[0][2], t.v[1][2], 0, 0,\n            );\n            let m2 = _mm256_setr_epi16(\n                t.v[2][0], 1, t.v[2][1], 1, t.v[2][2], 1, 0, 0, t.v[2][0], 1, t.v[2][1], 1,\n                t.v[2][2], 1, 0, 0,\n            );\n\n            let rnd_val = ((1i32 << (PRECISION - 1)) as i16).to_ne_bytes();\n            let rnd = _mm256_set1_epi32(i32::from_ne_bytes([0, 0, rnd_val[0], rnd_val[1]]));\n\n            let zeros = _mm256_setzero_si256();\n\n            let v_max_value = _mm256_set1_epi32(GAMMA_LUT as i32 - 1);\n\n            let (mut r0, mut g0, mut b0, mut a0);\n            let (mut r1, mut g1, mut b1, mut a1);\n\n            let mut src_iter = src.chunks_exact(src_channels * 2);\n\n            if let Some(src0) = src_iter.next() {\n                r0 = _xmm_broadcast_epi32(&self.profile.linear[src0[src_cn.r_i()]._as_usize()]);\n                g0 = _xmm_broadcast_epi32(&self.profile.linear[src0[src_cn.g_i()]._as_usize()]);\n                b0 = _xmm_broadcast_epi32(&self.profile.linear[src0[src_cn.b_i()]._as_usize()]);\n\n                r1 = _xmm_broadcast_epi32(\n                    &self.profile.linear[src0[src_cn.r_i() + src_channels]._as_usize()],\n                );\n                g1 = _xmm_broadcast_epi32(\n                    &self.profile.linear[src0[src_cn.g_i() + src_channels]._as_usize()],\n                );\n                b1 = _xmm_broadcast_epi32(\n                    &self.profile.linear[src0[src_cn.b_i() + src_channels]._as_usize()],\n                );\n\n                a0 = if src_channels == 4 {\n                    src0[src_cn.a_i()]\n                } else {\n                    max_colors\n                };\n                a1 = if src_channels == 4 {\n                    src0[src_cn.a_i() + src_channels]\n                } else {\n                    max_colors\n                };\n            } else {\n                r0 = _mm_setzero_si128();\n                g0 = _mm_setzero_si128();\n                b0 = _mm_setzero_si128();\n                a0 = max_colors;\n                r1 = _mm_setzero_si128();\n                g1 = _mm_setzero_si128();\n                b1 = _mm_setzero_si128();\n                a1 = max_colors;\n            }\n\n            for (src, dst) in src_iter.zip(dst.chunks_exact_mut(dst_channels * 2)) {\n                let zr0 = _mm256_inserti128_si256::<1>(_mm256_castsi128_si256(r0), r1);\n                let mut zg0 = _mm256_inserti128_si256::<1>(_mm256_castsi128_si256(g0), g1);\n                let zb0 = _mm256_inserti128_si256::<1>(_mm256_castsi128_si256(b0), b1);\n                zg0 = _mm256_slli_epi32::<16>(zg0);\n\n                let zrg0 = _mm256_or_si256(zr0, zg0);\n                let zbz0 = _mm256_or_si256(zb0, rnd);\n\n                let va0 = _mm256_madd_epi16(zrg0, m0);\n                let va1 = _mm256_madd_epi16(zbz0, m2);\n\n                let mut v0 = _mm256_add_epi32(va0, va1);\n\n                v0 = _mm256_srai_epi32::<PRECISION>(v0);\n                v0 = _mm256_max_epi32(v0, zeros);\n                v0 = _mm256_min_epi32(v0, v_max_value);\n\n                _mm256_store_si256(temporary0.0.as_mut_ptr() as *mut _, v0);\n\n                r0 = _xmm_broadcast_epi32(&self.profile.linear[src[src_cn.r_i()]._as_usize()]);\n                g0 = _xmm_broadcast_epi32(&self.profile.linear[src[src_cn.g_i()]._as_usize()]);\n                b0 = _xmm_broadcast_epi32(&self.profile.linear[src[src_cn.b_i()]._as_usize()]);\n\n                r1 = _xmm_broadcast_epi32(\n                    &self.profile.linear[src[src_cn.r_i() + src_channels]._as_usize()],\n                );\n                g1 = _xmm_broadcast_epi32(\n                    &self.profile.linear[src[src_cn.g_i() + src_channels]._as_usize()],\n                );\n                b1 = _xmm_broadcast_epi32(\n                    &self.profile.linear[src[src_cn.b_i() + src_channels]._as_usize()],\n                );\n\n                dst[dst_cn.r_i()] = self.profile.gamma[temporary0.0[0] as usize];\n                dst[dst_cn.g_i()] = self.profile.gamma[temporary0.0[2] as usize];\n                dst[dst_cn.b_i()] = self.profile.gamma[temporary0.0[4] as usize];\n                if dst_channels == 4 {\n                    dst[dst_cn.a_i()] = a0;\n                }\n\n                dst[dst_cn.r_i() + dst_channels] = self.profile.gamma[temporary0.0[8] as usize];\n                dst[dst_cn.g_i() + dst_channels] = self.profile.gamma[temporary0.0[10] as usize];\n                dst[dst_cn.b_i() + dst_channels] = self.profile.gamma[temporary0.0[12] as usize];\n                if dst_channels == 4 {\n                    dst[dst_cn.a_i() + dst_channels] = a1;\n                }\n\n                a0 = if src_channels == 4 {\n                    src[src_cn.a_i()]\n                } else {\n                    max_colors\n                };\n                a1 = if src_channels == 4 {\n                    src[src_cn.a_i() + src_channels]\n                } else {\n                    max_colors\n                };\n            }\n\n            if let Some(dst) = dst.chunks_exact_mut(dst_channels * 2).last() {\n                let zr0 = _mm256_inserti128_si256::<1>(_mm256_castsi128_si256(r0), r1);\n                let mut zg0 = _mm256_inserti128_si256::<1>(_mm256_castsi128_si256(g0), g1);\n                let zb0 = _mm256_inserti128_si256::<1>(_mm256_castsi128_si256(b0), b1);\n                zg0 = _mm256_slli_epi32::<16>(zg0);\n\n                let zrg0 = _mm256_or_si256(zr0, zg0);\n                let zbz0 = _mm256_or_si256(zb0, rnd);\n\n                let va0 = _mm256_madd_epi16(zrg0, m0);\n                let va1 = _mm256_madd_epi16(zbz0, m2);\n\n                let mut v0 = _mm256_add_epi32(va0, va1);\n\n                v0 = _mm256_srai_epi32::<PRECISION>(v0);\n                v0 = _mm256_max_epi32(v0, zeros);\n                v0 = _mm256_min_epi32(v0, v_max_value);\n\n                _mm256_store_si256(temporary0.0.as_mut_ptr() as *mut _, v0);\n\n                dst[dst_cn.r_i()] = self.profile.gamma[temporary0.0[0] as usize];\n                dst[dst_cn.g_i()] = self.profile.gamma[temporary0.0[2] as usize];\n                dst[dst_cn.b_i()] = self.profile.gamma[temporary0.0[4] as usize];\n                if dst_channels == 4 {\n                    dst[dst_cn.a_i()] = a0;\n                }\n\n                dst[dst_cn.r_i() + dst_channels] = self.profile.gamma[temporary0.0[8] as usize];\n                dst[dst_cn.g_i() + dst_channels] = self.profile.gamma[temporary0.0[10] as usize];\n                dst[dst_cn.b_i() + dst_channels] = self.profile.gamma[temporary0.0[12] as usize];\n                if dst_channels == 4 {\n                    dst[dst_cn.a_i() + dst_channels] = a1;\n                }\n            }\n\n            let src = src.chunks_exact(src_channels * 2).remainder();\n            let dst = dst.chunks_exact_mut(dst_channels * 2).into_remainder();\n\n            for (src, dst) in src\n                .chunks_exact(src_channels)\n                .zip(dst.chunks_exact_mut(dst_channels))\n            {\n                let r = _xmm_broadcast_epi32(&self.profile.linear[src[src_cn.r_i()]._as_usize()]);\n                let mut g =\n                    _xmm_broadcast_epi32(&self.profile.linear[src[src_cn.g_i()]._as_usize()]);\n                let b = _xmm_broadcast_epi32(&self.profile.linear[src[src_cn.b_i()]._as_usize()]);\n\n                g = _mm_slli_epi32::<16>(g);\n\n                let a = if src_channels == 4 {\n                    src[src_cn.a_i()]\n                } else {\n                    max_colors\n                };\n\n                let zrg0 = _mm_or_si128(r, g);\n                let zbz0 = _mm_or_si128(b, _mm256_castsi256_si128(rnd));\n\n                let v0 = _mm_madd_epi16(zrg0, _mm256_castsi256_si128(m0));\n                let v1 = _mm_madd_epi16(zbz0, _mm256_castsi256_si128(m2));\n\n                let mut v = _mm_add_epi32(v0, v1);\n\n                v = _mm_srai_epi32::<PRECISION>(v);\n                v = _mm_max_epi32(v, _mm_setzero_si128());\n                v = _mm_min_epi32(v, _mm256_castsi256_si128(v_max_value));\n\n                _mm_store_si128(temporary0.0.as_mut_ptr() as *mut _, v);\n\n                dst[dst_cn.r_i()] = self.profile.gamma[temporary0.0[0] as usize];\n                dst[dst_cn.g_i()] = self.profile.gamma[temporary0.0[2] as usize];\n                dst[dst_cn.b_i()] = self.profile.gamma[temporary0.0[4] as usize];\n                if dst_channels == 4 {\n                    dst[dst_cn.a_i()] = a;\n                }\n            }\n        }\n\n        Ok(())\n    }"
}