{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `scope::VmScope::<'a, SE>::step`",
    "file": "intuicio-backend-vm-0.47.0/src/scope.rs",
    "start_line": 52,
    "start_col": 5,
    "end_line": 228,
    "end_col": 6,
    "code_snippet": "pub fn step(&mut self, context: &mut Context, registry: &Registry) -> bool {\n        if let Some(child) = &mut self.child {\n            if child.step(context, registry) {\n                return true;\n            } else {\n                self.child = None;\n            }\n        }\n        if self.position == 0 {\n            if let Some(debugger) = self.debugger.as_ref() {\n                if let Ok(mut debugger) = debugger.try_write() {\n                    debugger.on_enter_scope(self, context, registry);\n                }\n            }\n        }\n        let result = if let Some(operation) = self.handle.get(self.position) {\n            if let Some(debugger) = self.debugger.as_ref() {\n                if let Ok(mut debugger) = debugger.try_write() {\n                    debugger.on_enter_operation(self, operation, self.position, context, registry);\n                }\n            }\n            let position = self.position;\n            let result = match operation {\n                ScriptOperation::None => {\n                    self.position += 1;\n                    true\n                }\n                ScriptOperation::Expression { expression } => {\n                    expression.evaluate(context, registry);\n                    self.position += 1;\n                    true\n                }\n                ScriptOperation::DefineRegister { query } => {\n                    let handle = registry\n                        .types()\n                        .find(|handle| query.is_valid(handle))\n                        .unwrap_or_else(|| {\n                            panic!(\"Could not define register for non-existent type: {query:#?}\")\n                        });\n                    unsafe {\n                        context\n                            .registers()\n                            .push_register_raw(handle.type_hash(), *handle.layout())\n                    };\n                    self.position += 1;\n                    true\n                }\n                ScriptOperation::DropRegister { index } => {\n                    let index = context.absolute_register_index(*index);\n                    context\n                        .registers()\n                        .access_register(index)\n                        .unwrap_or_else(|| {\n                            panic!(\"Could not access non-existent register: {index}\")\n                        })\n                        .free();\n                    self.position += 1;\n                    true\n                }\n                ScriptOperation::PushFromRegister { index } => {\n                    let index = context.absolute_register_index(*index);\n                    let (stack, registers) = context.stack_and_registers();\n                    let mut register = registers.access_register(index).unwrap_or_else(|| {\n                        panic!(\"Could not access non-existent register: {index}\")\n                    });\n                    if !stack.push_from_register(&mut register) {\n                        panic!(\"Could not push data from register: {index}\");\n                    }\n                    self.position += 1;\n                    true\n                }\n                ScriptOperation::PopToRegister { index } => {\n                    let index = context.absolute_register_index(*index);\n                    let (stack, registers) = context.stack_and_registers();\n                    let mut register = registers.access_register(index).unwrap_or_else(|| {\n                        panic!(\"Could not access non-existent register: {index}\")\n                    });\n                    if !stack.pop_to_register(&mut register) {\n                        panic!(\"Could not pop data to register: {index}\");\n                    }\n                    self.position += 1;\n                    true\n                }\n                ScriptOperation::MoveRegister { from, to } => {\n                    let from = context.absolute_register_index(*from);\n                    let to = context.absolute_register_index(*to);\n                    let (mut source, mut target) = context\n                        .registers()\n                        .access_registers_pair(from, to)\n                        .unwrap_or_else(|| {\n                            panic!(\"Could not access non-existent registers pair: {from} and {to}\")\n                        });\n                    source.move_to(&mut target);\n                    self.position += 1;\n                    true\n                }\n                ScriptOperation::CallFunction { query } => {\n                    let handle = registry\n                        .functions()\n                        .find(|handle| query.is_valid(handle.signature()))\n                        .unwrap_or_else(|| {\n                            panic!(\"Could not call non-existent function: {query:#?}\")\n                        });\n                    handle.invoke(context, registry);\n                    self.position += 1;\n                    true\n                }\n                ScriptOperation::BranchScope {\n                    scope_success,\n                    scope_failure,\n                } => {\n                    if context.stack().pop::<bool>().unwrap() {\n                        self.child = Some(Box::new(\n                            Self::new(scope_success.clone(), self.symbol)\n                                .with_debugger(self.debugger.clone()),\n                        ));\n                    } else if let Some(scope_failure) = scope_failure {\n                        self.child = Some(Box::new(\n                            Self::new(scope_failure.clone(), self.symbol)\n                                .with_debugger(self.debugger.clone()),\n                        ));\n                    }\n                    self.position += 1;\n                    true\n                }\n                ScriptOperation::LoopScope { scope } => {\n                    if !context.stack().pop::<bool>().unwrap() {\n                        self.position += 1;\n                    } else {\n                        self.child = Some(Box::new(\n                            Self::new(scope.clone(), self.symbol)\n                                .with_debugger(self.debugger.clone()),\n                        ));\n                    }\n                    true\n                }\n                ScriptOperation::PushScope { scope } => {\n                    context.store_registers();\n                    self.child = Some(Box::new(\n                        Self::new(scope.clone(), self.symbol).with_debugger(self.debugger.clone()),\n                    ));\n                    self.position += 1;\n                    true\n                }\n                ScriptOperation::PopScope => {\n                    context.restore_registers();\n                    self.position = self.handle.len();\n                    false\n                }\n                ScriptOperation::ContinueScopeConditionally => {\n                    let result = context.stack().pop::<bool>().unwrap();\n                    if result {\n                        self.position += 1;\n                    } else {\n                        self.position = self.handle.len();\n                    }\n                    result\n                }\n            };\n            if let Some(debugger) = self.debugger.as_ref() {\n                if let Ok(mut debugger) = debugger.try_write() {\n                    debugger.on_exit_operation(self, operation, position, context, registry);\n                }\n            }\n            result\n        } else {\n            false\n        };\n        if !result || self.position >= self.handle.len() {\n            if let Some(debugger) = self.debugger.as_ref() {\n                if let Ok(mut debugger) = debugger.try_write() {\n                    debugger.on_exit_scope(self, context, registry);\n                }\n            }\n        }\n        result\n    }"
}