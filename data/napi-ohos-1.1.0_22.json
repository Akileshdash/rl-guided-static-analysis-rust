{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `threadsafe_function::call_js_cb`",
    "file": "napi-ohos-1.1.0/src/threadsafe_function.rs",
    "start_line": 690,
    "start_col": 1,
    "end_line": 796,
    "end_col": 2,
    "code_snippet": "unsafe extern \"C\" fn call_js_cb<\n  T: 'static,\n  Return: FromNapiValue,\n  V: 'static + JsValuesTupleIntoVec,\n  ErrorStatus: AsRef<str> + From<Status>,\n  R,\n  const CalleeHandled: bool,\n>(\n  raw_env: sys::napi_env,\n  js_callback: sys::napi_value,\n  context: *mut c_void,\n  data: *mut c_void,\n) where\n  R: 'static + FnMut(ThreadsafeCallContext<T>) -> Result<V>,\n{\n  // env and/or callback can be null when shutting down\n  if raw_env.is_null() || js_callback.is_null() {\n    return;\n  }\n\n  let callback: &mut R = unsafe { Box::leak(Box::from_raw(context.cast())) };\n  let val = unsafe {\n    if CalleeHandled {\n      *Box::<Result<ThreadsafeFunctionCallJsBackData<T, Return>, ErrorStatus>>::from_raw(\n        data.cast(),\n      )\n    } else {\n      Ok(*Box::<ThreadsafeFunctionCallJsBackData<T, Return>>::from_raw(data.cast()))\n    }\n  };\n\n  let mut recv = ptr::null_mut();\n  unsafe { sys::napi_get_undefined(raw_env, &mut recv) };\n\n  let ret = val.and_then(|v| {\n    (callback)(ThreadsafeCallContext {\n      env: Env::from_raw(raw_env),\n      value: v.data,\n    })\n    .and_then(|ret| Ok((ret.into_vec(raw_env)?, v.call_variant, v.callback)))\n    .map_err(|err| Error::new(err.status.into(), err.reason.clone()))\n  });\n\n  // Follow async callback conventions: https://nodejs.org/en/knowledge/errors/what-are-the-error-conventions/\n  // Check if the Result is okay, if so, pass a null as the first (error) argument automatically.\n  // If the Result is an error, pass that as the first argument.\n  let status = match ret {\n    Ok((values, call_variant, callback)) => {\n      let args: Vec<sys::napi_value> = if CalleeHandled {\n        let mut js_null = ptr::null_mut();\n        unsafe { sys::napi_get_null(raw_env, &mut js_null) };\n        core::iter::once(js_null).chain(values).collect()\n      } else {\n        values\n      };\n      let mut return_value = ptr::null_mut();\n      let mut status = sys::napi_call_function(\n        raw_env,\n        recv,\n        js_callback,\n        args.len(),\n        args.as_ptr(),\n        &mut return_value,\n      );\n      if let ThreadsafeFunctionCallVariant::WithCallback = call_variant {\n        // throw Error in JavaScript callback\n        let callback_arg = if status == sys::Status::napi_pending_exception {\n          let mut exception = ptr::null_mut();\n          unsafe { sys::napi_get_and_clear_last_exception(raw_env, &mut exception) };\n          let mut error_reference = ptr::null_mut();\n          let raw_status = status;\n          status =\n            unsafe { sys::napi_create_reference(raw_env, exception, 1, &mut error_reference) };\n\n          get_error_message_and_stack_trace(raw_env, exception).and_then(|reason| {\n            Err(Error {\n              maybe_raw: error_reference,\n              maybe_env: raw_env,\n              status: Status::from(raw_status),\n              reason,\n            })\n          })\n        } else {\n          unsafe { Return::from_napi_value(raw_env, return_value) }\n        };\n        if let Err(err) = callback(callback_arg, Env::from_raw(raw_env)) {\n          unsafe { sys::napi_fatal_exception(raw_env, JsError::from(err).into_value(raw_env)) };\n        }\n      }\n      status\n    }\n    Err(e) if !CalleeHandled => unsafe {\n      sys::napi_fatal_exception(raw_env, JsError::from(e).into_value(raw_env))\n    },\n    Err(e) => unsafe {\n      sys::napi_call_function(\n        raw_env,\n        recv,\n        js_callback,\n        1,\n        [JsError::from(e).into_value(raw_env)].as_mut_ptr(),\n        ptr::null_mut(),\n      )\n    },\n  };\n  handle_call_js_cb_status(status, raw_env)\n}"
}