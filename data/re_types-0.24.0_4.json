{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<blueprint::datatypes::selected_columns::SelectedColumns as re_types_core::Loggable>::to_arrow_opt`",
    "file": "re_types-0.24.0/src/blueprint/datatypes/selected_columns.rs",
    "start_line": 63,
    "start_col": 5,
    "end_line": 199,
    "end_col": 6,
    "code_snippet": "fn to_arrow_opt<'a>(\n        data: impl IntoIterator<Item = Option<impl Into<::std::borrow::Cow<'a, Self>>>>,\n    ) -> SerializationResult<arrow::array::ArrayRef>\n    where\n        Self: Clone + 'a,\n    {\n        #![allow(clippy::wildcard_imports)]\n        #![allow(clippy::manual_is_variant_and)]\n        use ::re_types_core::{arrow_helpers::as_array_ref, Loggable as _, ResultExt as _};\n        use arrow::{array::*, buffer::*, datatypes::*};\n        Ok({\n            let fields = Fields::from(vec![\n                Field::new(\n                    \"time_columns\",\n                    DataType::List(std::sync::Arc::new(Field::new(\n                        \"item\",\n                        <crate::datatypes::Utf8>::arrow_datatype(),\n                        false,\n                    ))),\n                    false,\n                ),\n                Field::new(\n                    \"component_columns\",\n                    DataType::List(std::sync::Arc::new(Field::new(\n                        \"item\",\n                        <crate::blueprint::datatypes::ComponentColumnSelector>::arrow_datatype(),\n                        false,\n                    ))),\n                    false,\n                ),\n            ]);\n            let (somes, data): (Vec<_>, Vec<_>) = data\n                .into_iter()\n                .map(|datum| {\n                    let datum: Option<::std::borrow::Cow<'a, Self>> = datum.map(Into::into);\n                    (datum.is_some(), datum)\n                })\n                .unzip();\n            let validity: Option<arrow::buffer::NullBuffer> = {\n                let any_nones = somes.iter().any(|some| !*some);\n                any_nones.then(|| somes.into())\n            };\n            as_array_ref(StructArray::new(\n                fields,\n                vec![\n                    {\n                        let (somes, time_columns): (Vec<_>, Vec<_>) = data\n                            .iter()\n                            .map(|datum| {\n                                let datum = datum.as_ref().map(|datum| datum.time_columns.clone());\n                                (datum.is_some(), datum)\n                            })\n                            .unzip();\n                        let time_columns_validity: Option<arrow::buffer::NullBuffer> = {\n                            let any_nones = somes.iter().any(|some| !*some);\n                            any_nones.then(|| somes.into())\n                        };\n                        {\n                            let offsets = arrow::buffer::OffsetBuffer::<i32>::from_lengths(\n                                time_columns\n                                    .iter()\n                                    .map(|opt| opt.as_ref().map_or(0, |datum| datum.len())),\n                            );\n                            let time_columns_inner_data: Vec<_> =\n                                time_columns.into_iter().flatten().flatten().collect();\n                            let time_columns_inner_validity: Option<arrow::buffer::NullBuffer> =\n                                None;\n                            as_array_ref(ListArray::try_new(\n                                std::sync::Arc::new(Field::new(\n                                    \"item\",\n                                    <crate::datatypes::Utf8>::arrow_datatype(),\n                                    false,\n                                )),\n                                offsets,\n                                {\n                                    let offsets = arrow::buffer::OffsetBuffer::<i32>::from_lengths(\n                                        time_columns_inner_data.iter().map(|datum| datum.0.len()),\n                                    );\n                                    #[allow(clippy::unwrap_used)]\n                                    let capacity = offsets.last().copied().unwrap() as usize;\n                                    let mut buffer_builder =\n                                        arrow::array::builder::BufferBuilder::<u8>::new(capacity);\n                                    for data in &time_columns_inner_data {\n                                        buffer_builder.append_slice(data.0.as_bytes());\n                                    }\n                                    let inner_data: arrow::buffer::Buffer = buffer_builder.finish();\n\n                                    #[allow(unsafe_code, clippy::undocumented_unsafe_blocks)]\n                                    as_array_ref(unsafe {\n                                        StringArray::new_unchecked(\n                                            offsets,\n                                            inner_data,\n                                            time_columns_inner_validity,\n                                        )\n                                    })\n                                },\n                                time_columns_validity,\n                            )?)\n                        }\n                    },\n                    {\n                        let (somes, component_columns): (Vec<_>, Vec<_>) = data\n                            .iter()\n                            .map(|datum| {\n                                let datum =\n                                    datum.as_ref().map(|datum| datum.component_columns.clone());\n                                (datum.is_some(), datum)\n                            })\n                            .unzip();\n                        let component_columns_validity: Option<arrow::buffer::NullBuffer> = {\n                            let any_nones = somes.iter().any(|some| !*some);\n                            any_nones.then(|| somes.into())\n                        };\n                        {\n                            let offsets = arrow::buffer::OffsetBuffer::<i32>::from_lengths(\n                                component_columns\n                                    .iter()\n                                    .map(|opt| opt.as_ref().map_or(0, |datum| datum.len())),\n                            );\n                            let component_columns_inner_data: Vec<_> =\n                                component_columns.into_iter().flatten().flatten().collect();\n                            let component_columns_inner_validity: Option<\n                                arrow::buffer::NullBuffer,\n                            > = None;\n                            as_array_ref(ListArray::try_new(std::sync::Arc::new(Field::new(\"item\",\n                        < crate ::blueprint::datatypes::ComponentColumnSelector >\n                        ::arrow_datatype(), false)), offsets, { _ =\n                        component_columns_inner_validity; crate\n                        ::blueprint::datatypes::ComponentColumnSelector::to_arrow_opt(component_columns_inner_data\n                        .into_iter().map(Some)) ? }, component_columns_validity,) ?)\n                        }\n                    },\n                ],\n                validity,\n            ))\n        })\n    }"
}