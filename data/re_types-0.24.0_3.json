{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<blueprint::datatypes::component_column_selector::ComponentColumnSelector as re_types_core::Loggable>::to_arrow_opt`",
    "file": "re_types-0.24.0/src/blueprint/datatypes/component_column_selector.rs",
    "start_line": 58,
    "start_col": 5,
    "end_line": 169,
    "end_col": 6,
    "code_snippet": "fn to_arrow_opt<'a>(\n        data: impl IntoIterator<Item = Option<impl Into<::std::borrow::Cow<'a, Self>>>>,\n    ) -> SerializationResult<arrow::array::ArrayRef>\n    where\n        Self: Clone + 'a,\n    {\n        #![allow(clippy::wildcard_imports)]\n        #![allow(clippy::manual_is_variant_and)]\n        use ::re_types_core::{arrow_helpers::as_array_ref, Loggable as _, ResultExt as _};\n        use arrow::{array::*, buffer::*, datatypes::*};\n        Ok({\n            let fields = Fields::from(vec![\n                Field::new(\n                    \"entity_path\",\n                    <crate::datatypes::EntityPath>::arrow_datatype(),\n                    false,\n                ),\n                Field::new(\n                    \"component\",\n                    <crate::datatypes::Utf8>::arrow_datatype(),\n                    false,\n                ),\n            ]);\n            let (somes, data): (Vec<_>, Vec<_>) = data\n                .into_iter()\n                .map(|datum| {\n                    let datum: Option<::std::borrow::Cow<'a, Self>> = datum.map(Into::into);\n                    (datum.is_some(), datum)\n                })\n                .unzip();\n            let validity: Option<arrow::buffer::NullBuffer> = {\n                let any_nones = somes.iter().any(|some| !*some);\n                any_nones.then(|| somes.into())\n            };\n            as_array_ref(StructArray::new(\n                fields,\n                vec![\n                    {\n                        let (somes, entity_path): (Vec<_>, Vec<_>) = data\n                            .iter()\n                            .map(|datum| {\n                                let datum = datum.as_ref().map(|datum| datum.entity_path.clone());\n                                (datum.is_some(), datum)\n                            })\n                            .unzip();\n                        let entity_path_validity: Option<arrow::buffer::NullBuffer> = {\n                            let any_nones = somes.iter().any(|some| !*some);\n                            any_nones.then(|| somes.into())\n                        };\n                        {\n                            let offsets = arrow::buffer::OffsetBuffer::<i32>::from_lengths(\n                                entity_path.iter().map(|opt| {\n                                    opt.as_ref().map(|datum| datum.0.len()).unwrap_or_default()\n                                }),\n                            );\n                            #[allow(clippy::unwrap_used)]\n                            let capacity = offsets.last().copied().unwrap() as usize;\n                            let mut buffer_builder =\n                                arrow::array::builder::BufferBuilder::<u8>::new(capacity);\n                            for data in entity_path.iter().flatten() {\n                                buffer_builder.append_slice(data.0.as_bytes());\n                            }\n                            let inner_data: arrow::buffer::Buffer = buffer_builder.finish();\n\n                            #[allow(unsafe_code, clippy::undocumented_unsafe_blocks)]\n                            as_array_ref(unsafe {\n                                StringArray::new_unchecked(\n                                    offsets,\n                                    inner_data,\n                                    entity_path_validity,\n                                )\n                            })\n                        }\n                    },\n                    {\n                        let (somes, component): (Vec<_>, Vec<_>) = data\n                            .iter()\n                            .map(|datum| {\n                                let datum = datum.as_ref().map(|datum| datum.component.clone());\n                                (datum.is_some(), datum)\n                            })\n                            .unzip();\n                        let component_validity: Option<arrow::buffer::NullBuffer> = {\n                            let any_nones = somes.iter().any(|some| !*some);\n                            any_nones.then(|| somes.into())\n                        };\n                        {\n                            let offsets = arrow::buffer::OffsetBuffer::<i32>::from_lengths(\n                                component.iter().map(|opt| {\n                                    opt.as_ref().map(|datum| datum.0.len()).unwrap_or_default()\n                                }),\n                            );\n                            #[allow(clippy::unwrap_used)]\n                            let capacity = offsets.last().copied().unwrap() as usize;\n                            let mut buffer_builder =\n                                arrow::array::builder::BufferBuilder::<u8>::new(capacity);\n                            for data in component.iter().flatten() {\n                                buffer_builder.append_slice(data.0.as_bytes());\n                            }\n                            let inner_data: arrow::buffer::Buffer = buffer_builder.finish();\n\n                            #[allow(unsafe_code, clippy::undocumented_unsafe_blocks)]\n                            as_array_ref(unsafe {\n                                StringArray::new_unchecked(offsets, inner_data, component_validity)\n                            })\n                        }\n                    },\n                ],\n                validity,\n            ))\n        })\n    }"
}