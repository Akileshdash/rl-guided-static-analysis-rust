{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `frame_cache::FrameCache::<K, V>::pop`",
    "file": "ribir_algo-0.4.0-alpha.44/src/frame_cache.rs",
    "start_line": 496,
    "start_col": 3,
    "end_line": 517,
    "end_col": 4,
    "code_snippet": "pub fn pop<Q>(&mut self, k: &Q) -> Option<V>\n  where\n    K: Borrow<Q>,\n    Q: Hash + Eq + ?Sized,\n  {\n    match self.map.remove(KeyWrapper::from_ref(k)) {\n      None => None,\n      Some(old_node) => {\n        let mut old_node = unsafe {\n          let mut old_node = *Box::from_raw(old_node.as_ptr());\n          ptr::drop_in_place(old_node.key.as_mut_ptr());\n\n          old_node\n        };\n\n        self.detach(&mut old_node);\n\n        let LruEntry { key: _, val, .. } = old_node;\n        unsafe { Some(val.assume_init()) }\n      }\n    }\n  }"
}