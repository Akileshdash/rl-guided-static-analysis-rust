{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `gemm::kernels::simd_generic::simd_int8_gemm`",
    "file": "rten-0.20.0/src/gemm/kernels/simd_generic.rs",
    "start_line": 575,
    "start_col": 1,
    "end_line": 734,
    "end_col": 2,
    "code_snippet": "pub unsafe fn simd_int8_gemm<I: Isa, D, const MR: usize, const NR: usize, const NR_REGS: usize>(\n    isa: I,\n    tile_ptr: *mut i32,\n    tile_row_stride: usize,\n    a: &[u8],\n    b: &[u8],\n    used_rows: usize,\n    used_cols: usize,\n    depth: usize,\n    accumulate: bool,\n    a_zero_points: [i32; MR],\n    b_zero_points: [i32; NR],\n    a_row_sums: &[i32; MR],\n    b_col_sums: &[i32; NR],\n    dot: D,\n) where\n    D: Int8DotProduct<X8 = I::I8, I32 = I::I32> + Copy,\n{\n    let ops = isa.i32();\n    let i8_ops = isa.i8();\n\n    assert_eq!(ops.len() * NR_REGS, NR);\n\n    // Packed buffers contain `[MR, 4]` microtiles of A and transposed `[4, NR]`\n    // microtiles of B.\n    assert_eq!(a.len(), MR * depth.next_multiple_of(4));\n    assert_eq!(b.len(), NR * depth.next_multiple_of(4));\n\n    // The value for each element in the output tile is computed as:\n    //\n    // c = (a[0] - a_zero_point) * (b[0] - b_zero_point) + ...\n    //\n    // (or `c += ...` when beta=1)\n    //\n    // Where `a_zero_point` is the zero point for the row of A and\n    // `b_zero_point` is the zero point for the column of B.\n    //\n    // This can be expanded and re-arranged into:\n    //\n    // c = a[0]b[0] - a[0] * b_zero_point - b[0] * a_zero_point + a_zero_point * b_zero_point + ...\n    // c = dot(a, b) - sum(a) * b_zero_point - sum(b) * a_zero_point + k * a_zero_point * b_zero_point\n    // c = k * a_zero_point * b_zero_point + dot(a, b) - sum(a) * b_zero_point - sum(b) * a_zero_point\n    //\n    // The `k * a_zero_point * b_zero_point` term is computed first as the\n    // initial value of the accumulator tile, then we loop over K and add\n    // the dot product of each row and column. Finally the scaled row\n    // and column sums are subtracted.\n\n    let a_ptr = a.as_ptr();\n    let b_ptr = b.as_ptr();\n\n    let n_depth_tiles = depth.div_ceil(4);\n    let b_zero = ops.load_many::<NR_REGS>(&b_zero_points);\n\n    // Initialize output tile with `k * a_zero_point[row] * b_zero_point[col]`\n    let k_mul_b_zero: [I::I32; NR_REGS] =\n        std::array::from_fn(|i| ops.mul(ops.splat(depth as i32), b_zero[i]));\n    let mut tmp = [k_mul_b_zero; MR];\n    for row in 0..MR {\n        let a_zero = ops.splat(a_zero_points[row]);\n        for i in 0..NR_REGS {\n            tmp[row][i] = ops.mul(tmp[row][i], a_zero);\n        }\n    }\n\n    // Loop over K dimension and compute dot product of panel of A with panel of\n    // B.\n    for k_block in 0..n_depth_tiles {\n        // Load `[4, NR]` microtile from B\n        let b_vec: [I::I8; NR_REGS] = std::array::from_fn(|i| {\n            i8_ops.load_ptr(b_ptr.add((k_block * NR + i * ops.len()) * 4) as *const i8)\n        });\n\n        // Multiply a MRx4 tile of A with a 4xNR tile of B.\n        //\n        // On Arm we can load the A tile with one instruction and then use an\n        // indexed dot product for each row to multiply one row of A from that\n        // tile by all columns of B. On other architectures we use a separate\n        // scalar load for each row of A and broadcast to a 4x4 tile which is\n        // then multiplied by the columns of B.\n\n        if D::supports_indexed_dot_product() {\n            let a_tile = unsafe { ops.load_ptr(a_ptr.add(k_block * MR * 4) as *const i32) }\n                .reinterpret_cast::<I::I8>();\n\n            macro_rules! k_step {\n                ($row:literal) => {\n                    for i in 0..NR_REGS {\n                        tmp[$row][i] =\n                            dot.indexed_dot_product::<$row>(b_vec[i], a_tile, tmp[$row][i]);\n                    }\n                };\n            }\n\n            // This code path is currently only used on Arm Neon, where MR=4.\n            debug_assert_eq!(MR, 4);\n            k_step!(0);\n            k_step!(1);\n            k_step!(2);\n            k_step!(3);\n        } else {\n            for row in 0..MR {\n                let a_val = unsafe { *(a_ptr.add(k_block * MR * 4 + row * 4) as *const i32) };\n                let a_vec = ops.splat(a_val).reinterpret_cast::<I::I8>();\n\n                for i in 0..NR_REGS {\n                    tmp[row][i] = dot.dot_product(a_vec, b_vec[i], tmp[row][i]);\n                }\n            }\n        }\n    }\n\n    // Scale zero points by row and column sums and subtract from output tile.\n    let b_col_sums: [I::I32; NR_REGS] =\n        std::array::from_fn(|i| ops.load_ptr(b_col_sums.as_ptr().add(i * ops.len())));\n    for row in 0..MR {\n        let a_zero = ops.splat(a_zero_points[row]);\n        let a_sum = ops.splat(a_row_sums[row]);\n\n        for i in 0..NR_REGS {\n            let a_sum_mul_b_zero = ops.mul(a_sum, b_zero[i]);\n            let b_sum_mul_a_zero = ops.mul(b_col_sums[i], a_zero);\n            let sum = ops.add(a_sum_mul_b_zero, b_sum_mul_a_zero);\n            tmp[row][i] = ops.sub(tmp[row][i], sum);\n        }\n    }\n\n    // Write from accumulator in registers back to output.\n    let output_tile_ptr =\n        |row, col_block| tile_ptr.add(row * tile_row_stride + col_block * ops.len());\n\n    if used_rows == MR && used_cols == NR {\n        // Full output tile\n        for row in 0..MR {\n            for c_block in 0..NR_REGS {\n                let tile_ptr = output_tile_ptr(row, c_block);\n                if accumulate {\n                    tmp[row][c_block] = ops.add(ops.load_ptr(tile_ptr), tmp[row][c_block]);\n                }\n                ops.store_ptr(tmp[row][c_block], tile_ptr);\n            }\n        }\n    } else {\n        // Partial output tile\n        for r in 0..used_rows {\n            for c_block in 0..NR_REGS {\n                let tile_ptr = output_tile_ptr(r, c_block);\n                let used_cols = used_cols.saturating_sub(c_block * ops.len()).min(ops.len());\n                let mut tmp = tmp[r][c_block].to_array();\n\n                for c in 0..used_cols {\n                    if accumulate {\n                        tmp[c] += *tile_ptr.add(c);\n                    }\n                    tile_ptr.add(c).write(tmp[c]);\n                }\n            }\n        }\n    }\n}"
}