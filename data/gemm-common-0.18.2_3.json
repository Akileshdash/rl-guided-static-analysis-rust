{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<gemv::mixed_gemv_rowmajor::implementation::Impl<Lhs, Rhs, Dst, Acc, S> as pulp::NullaryFnOnce>::call`",
    "file": "gemm-common-0.18.2/src/gemv.rs",
    "start_line": 400,
    "start_col": 13,
    "end_line": 553,
    "end_col": 14,
    "code_snippet": "fn call(self) -> Self::Output {\n                unsafe {\n                    let Self {\n                        simd,\n                        dst,\n                        dst_rs,\n                        m,\n                        k,\n                        lhs,\n                        lhs_rs,\n                        rhs,\n                        alpha,\n                        beta,\n                    } = self;\n\n                    let lane = S::SIMD_WIDTH;\n                    let lane8 = 8 * S::SIMD_WIDTH;\n\n                    let k_lane = k / lane * lane;\n                    let k_lane8 = k / lane8 * lane8;\n\n                    for row in 0..m {\n                        let lhs = lhs.wrapping_offset(row as isize * lhs_rs);\n\n                        let mut depth = 0;\n\n                        let mut acc0 = simd.simd_splat(Acc::zero());\n                        let mut acc1 = simd.simd_splat(Acc::zero());\n                        let mut acc2 = simd.simd_splat(Acc::zero());\n                        let mut acc3 = simd.simd_splat(Acc::zero());\n                        let mut acc4 = simd.simd_splat(Acc::zero());\n                        let mut acc5 = simd.simd_splat(Acc::zero());\n                        let mut acc6 = simd.simd_splat(Acc::zero());\n                        let mut acc7 = simd.simd_splat(Acc::zero());\n\n                        while depth < k_lane8 {\n                            let lhs0 = *(lhs.wrapping_add(depth + lane * 0) as *const S::LhsN);\n                            let rhs0 = *(rhs.wrapping_add(depth + lane * 0) as *const S::RhsN);\n                            acc0 = simd.simd_mult_add(\n                                simd.simd_from_lhs(lhs0),\n                                simd.simd_from_rhs(rhs0),\n                                acc0,\n                            );\n\n                            let lhs1 = *(lhs.wrapping_add(depth + lane * 1) as *const S::LhsN);\n                            let rhs1 = *(rhs.wrapping_add(depth + lane * 1) as *const S::RhsN);\n                            acc1 = simd.simd_mult_add(\n                                simd.simd_from_lhs(lhs1),\n                                simd.simd_from_rhs(rhs1),\n                                acc1,\n                            );\n\n                            let lhs2 = *(lhs.wrapping_add(depth + lane * 2) as *const S::LhsN);\n                            let rhs2 = *(rhs.wrapping_add(depth + lane * 2) as *const S::RhsN);\n                            acc2 = simd.simd_mult_add(\n                                simd.simd_from_lhs(lhs2),\n                                simd.simd_from_rhs(rhs2),\n                                acc2,\n                            );\n\n                            let lhs3 = *(lhs.wrapping_add(depth + lane * 3) as *const S::LhsN);\n                            let rhs3 = *(rhs.wrapping_add(depth + lane * 3) as *const S::RhsN);\n                            acc3 = simd.simd_mult_add(\n                                simd.simd_from_lhs(lhs3),\n                                simd.simd_from_rhs(rhs3),\n                                acc3,\n                            );\n\n                            let lhs4 = *(lhs.wrapping_add(depth + lane * 4) as *const S::LhsN);\n                            let rhs4 = *(rhs.wrapping_add(depth + lane * 4) as *const S::RhsN);\n                            acc4 = simd.simd_mult_add(\n                                simd.simd_from_lhs(lhs4),\n                                simd.simd_from_rhs(rhs4),\n                                acc4,\n                            );\n\n                            let lhs5 = *(lhs.wrapping_add(depth + lane * 5) as *const S::LhsN);\n                            let rhs5 = *(rhs.wrapping_add(depth + lane * 5) as *const S::RhsN);\n                            acc5 = simd.simd_mult_add(\n                                simd.simd_from_lhs(lhs5),\n                                simd.simd_from_rhs(rhs5),\n                                acc5,\n                            );\n\n                            let lhs6 = *(lhs.wrapping_add(depth + lane * 6) as *const S::LhsN);\n                            let rhs6 = *(rhs.wrapping_add(depth + lane * 6) as *const S::RhsN);\n                            acc6 = simd.simd_mult_add(\n                                simd.simd_from_lhs(lhs6),\n                                simd.simd_from_rhs(rhs6),\n                                acc6,\n                            );\n\n                            let lhs7 = *(lhs.wrapping_add(depth + lane * 7) as *const S::LhsN);\n                            let rhs7 = *(rhs.wrapping_add(depth + lane * 7) as *const S::RhsN);\n                            acc7 = simd.simd_mult_add(\n                                simd.simd_from_lhs(lhs7),\n                                simd.simd_from_rhs(rhs7),\n                                acc7,\n                            );\n\n                            depth += lane8;\n                        }\n\n                        let acc0 = simd.simd_add(acc0, acc1);\n                        let acc2 = simd.simd_add(acc2, acc3);\n                        let acc4 = simd.simd_add(acc4, acc5);\n                        let acc6 = simd.simd_add(acc6, acc7);\n\n                        let acc0 = simd.simd_add(acc0, acc2);\n                        let acc4 = simd.simd_add(acc4, acc6);\n\n                        let mut acc0 = simd.simd_add(acc0, acc4);\n\n                        while depth < k_lane {\n                            let lhs0 = *(lhs.wrapping_add(depth) as *const S::LhsN);\n                            let rhs0 = *(rhs.wrapping_add(depth) as *const S::RhsN);\n                            acc0 = simd.simd_mult_add(\n                                simd.simd_from_lhs(lhs0),\n                                simd.simd_from_rhs(rhs0),\n                                acc0,\n                            );\n\n                            depth += lane;\n                        }\n\n                        let acc_ptr = &acc0 as *const _ as *const Acc;\n                        let mut acc0 = *acc_ptr;\n                        for x in 1..S::SIMD_WIDTH {\n                            acc0 = simd.add(acc0, *acc_ptr.add(x));\n                        }\n\n                        while depth < k {\n                            let lhs0 = *(lhs.wrapping_add(depth + 0));\n                            let rhs0 = *(rhs.wrapping_add(depth + 0));\n\n                            acc0 = simd.mult_add(simd.from_lhs(lhs0), simd.from_rhs(rhs0), acc0);\n\n                            depth += 1;\n                        }\n\n                        if alpha.is_zero() {\n                            let dst = dst.wrapping_offset(dst_rs * row as isize);\n                            *dst = simd.into_dst(simd.mult(acc0, beta));\n                        } else {\n                            let dst = dst.wrapping_offset(dst_rs * row as isize);\n                            *dst =\n                                simd.into_dst(simd.add(\n                                    simd.mult(acc0, beta),\n                                    simd.mult(simd.from_dst(*dst), alpha),\n                                ));\n                        }\n                    }\n                }\n            }"
}