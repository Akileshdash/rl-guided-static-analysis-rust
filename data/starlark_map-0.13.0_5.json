{
    "level": "Warning",
    "analyzer": "UnsafeDataflow",
    "op_type": "ReadFlow/WriteFlow",
    "description": "Potential unsafe dataflow issue in `vec2::Vec2::<A, B>::retain`",
    "file": "starlark_map-0.13.0/src/vec2.rs",
    "start_line": 421,
    "start_col": 5,
    "end_line": 480,
    "end_col": 6,
    "code_snippet": "pub fn retain<F>(&mut self, mut f: F)\n    where\n        F: FnMut(&mut A, &mut B) -> bool,\n    {\n        struct Retain<'a, A, B> {\n            /// Data in `vec` is valid in ranges `[0, written)` and `[next, vec.len)`.\n            vec: &'a mut Vec2<A, B>,\n            /// Processed and retained element count.\n            written: usize,\n            /// Next element to check.\n            next: usize,\n        }\n\n        impl<'a, A, B> Drop for Retain<'a, A, B> {\n            fn drop(&mut self) {\n                debug_assert!(self.written <= self.next);\n                debug_assert!(self.next <= self.vec.len);\n                unsafe {\n                    // Copy remaining elements to the beginning.\n                    // Copy occurs only if `f` or `{A,B}::drop` panics.\n                    ptr::copy(\n                        self.vec.aaa_ptr().as_ptr().add(self.next),\n                        self.vec.aaa_ptr().as_ptr().add(self.written),\n                        self.vec.len - self.next,\n                    );\n                    ptr::copy(\n                        self.vec.bbb_ptr().as_ptr().add(self.next),\n                        self.vec.bbb_ptr().as_ptr().add(self.written),\n                        self.vec.len - self.next,\n                    );\n\n                    // Set correct length.\n                    self.vec.len = self.written + self.vec.len - self.next;\n                }\n            }\n        }\n\n        let mut retain = Retain {\n            vec: self,\n            next: 0,\n            written: 0,\n        };\n\n        unsafe {\n            while retain.next < retain.vec.len {\n                let (a, b) = retain.vec.get_unchecked_mut(retain.next);\n                let retain_elem = f(a, b);\n                let a = ptr::read(a);\n                let b = ptr::read(b);\n                retain.next += 1;\n                if retain_elem {\n                    ptr::write(retain.vec.aaa_ptr().as_ptr().add(retain.written), a);\n                    ptr::write(retain.vec.bbb_ptr().as_ptr().add(retain.written), b);\n                    retain.written += 1;\n                } else {\n                    drop((a, b));\n                }\n            }\n        }\n    }"
}