{
    "level": "Warning",
    "analyzer": "UnsafeDataflow",
    "op_type": "ReadFlow",
    "description": "Potential unsafe dataflow issue in `mirror_select_nth_unstable_by::mirror_partition`",
    "file": "kiddo-5.2.2/src/mirror_select_nth_unstable_by.rs",
    "start_line": 162,
    "start_col": 1,
    "end_line": 234,
    "end_col": 2,
    "code_snippet": "fn mirror_partition<AA, BB, F>(\n    target: &mut [AA],\n    mirror: &mut [BB],\n    pivot: usize,\n    is_less: &mut F,\n) -> (usize, bool)\nwhere\n    F: FnMut(&AA, &AA) -> bool,\n{\n    let (mid, was_partitioned) = {\n        // Place the pivot at the beginning of slice.\n        target.swap(0, pivot);\n        mirror.swap(0, pivot);\n\n        let (pivot, v) = target.split_at_mut(1);\n        let (mirror_pivot, mirror_v) = mirror.split_at_mut(1);\n        let pivot = &mut pivot[0];\n        let mirror_pivot = &mut mirror_pivot[0];\n\n        // Read the pivot into a stack-allocated variable for efficiency. If a following comparison\n        // operation panics, the pivot will be automatically written back into the slice.\n\n        // SAFETY: `pivot` is a reference to the first element of `v`, so `ptr::read` is safe.\n        let tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n        let _pivot_guard = CopyOnDrop {\n            src: &*tmp,\n            dest: pivot,\n        };\n        let pivot = &*tmp;\n\n        let mirror_tmp = mem::ManuallyDrop::new(unsafe { ptr::read(mirror_pivot) });\n        let _mirror_pivot_guard = CopyOnDrop {\n            src: &*mirror_tmp,\n            dest: mirror_pivot,\n        };\n        let _mirror_pivot = &*mirror_tmp;\n\n        // Find the first pair of out-of-order elements.\n        let mut l = 0;\n        let mut r = v.len();\n\n        // SAFETY: The unsafety below involves indexing an array.\n        // For the first one: We already do the bounds checking here with `l < r`.\n        // For the second one: We initially have `l == 0` and `r == v.len()` and we checked that `l < r` at every indexing operation.\n        //                     From here we know that `r` must be at least `r == l` which was shown to be valid from the first one.\n        unsafe {\n            // Find the first element greater than or equal to the pivot.\n            while l < r && is_less(v.get_unchecked(l), pivot) {\n                l += 1;\n            }\n\n            // Find the last element smaller that the pivot.\n            while l < r && !is_less(v.get_unchecked(r - 1), pivot) {\n                r -= 1;\n            }\n        }\n\n        (\n            l + mirror_partition_in_blocks(&mut v[l..r], &mut mirror_v[l..r], pivot, is_less),\n            l >= r,\n        )\n\n        // `_pivot_guard` goes out of scope and writes the pivot (which is a stack-allocated\n        // variable) back into the slice where it originally was. This step is critical in ensuring\n        // safety!\n    };\n\n    // Place the pivot between the two partitions.\n    target.swap(0, mid);\n    mirror.swap(0, mid);\n\n    (mid, was_partitioned)\n}"
}