{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<[T; N] as codec::Decode>::decode_into`",
    "file": "parity-scale-codec-3.7.5/src/codec.rs",
    "start_line": 915,
    "start_col": 2,
    "end_line": 1012,
    "end_col": 3,
    "code_snippet": "fn decode_into<I: Input>(\n\t\tinput: &mut I,\n\t\tdst: &mut MaybeUninit<Self>,\n\t) -> Result<DecodeFinished, Error> {\n\t\tlet is_primitive = match <T as Decode>::TYPE_INFO {\n\t\t\t| TypeInfo::U8 | TypeInfo::I8 => true,\n\t\t\t| TypeInfo::U16 |\n\t\t\tTypeInfo::I16 |\n\t\t\tTypeInfo::U32 |\n\t\t\tTypeInfo::I32 |\n\t\t\tTypeInfo::U64 |\n\t\t\tTypeInfo::I64 |\n\t\t\tTypeInfo::U128 |\n\t\t\tTypeInfo::I128 |\n\t\t\tTypeInfo::F32 |\n\t\t\tTypeInfo::F64 => cfg!(target_endian = \"little\"),\n\t\t\tTypeInfo::Unknown => false,\n\t\t};\n\n\t\tif is_primitive {\n\t\t\t// Let's read the array in bulk as that's going to be a lot\n\t\t\t// faster than just reading each element one-by-one.\n\n\t\t\tlet ptr: *mut [T; N] = dst.as_mut_ptr();\n\t\t\tlet ptr: *mut u8 = ptr.cast();\n\n\t\t\tlet bytesize = calculate_array_bytesize::<T, N>();\n\n\t\t\t// TODO: This is potentially slow; it'd be better if `Input` supported\n\t\t\t//       reading directly into uninitialized memory.\n\t\t\t//\n\t\t\t// SAFETY: The pointer is valid and points to a memory `bytesize` bytes big.\n\t\t\tunsafe {\n\t\t\t\tptr.write_bytes(0, bytesize);\n\t\t\t}\n\n\t\t\t// SAFETY: We've zero-initialized everything so creating a slice here is safe.\n\t\t\tlet slice: &mut [u8] = unsafe { core::slice::from_raw_parts_mut(ptr, bytesize) };\n\n\t\t\tinput.read(slice)?;\n\n\t\t\t// SAFETY: We've initialized the whole slice so calling this is safe.\n\t\t\tunsafe {\n\t\t\t\treturn Ok(DecodeFinished::assert_decoding_finished());\n\t\t\t}\n\t\t}\n\n\t\tlet slice: &mut [MaybeUninit<T>; N] = {\n\t\t\tlet ptr: *mut [T; N] = dst.as_mut_ptr();\n\t\t\tlet ptr: *mut [MaybeUninit<T>; N] = ptr.cast();\n\t\t\t// SAFETY: Casting `&mut MaybeUninit<[T; N]>` into `&mut [MaybeUninit<T>; N]` is safe.\n\t\t\tunsafe { &mut *ptr }\n\t\t};\n\n\t\t/// A wrapper type to make sure the partially read elements are always\n\t\t/// dropped in case an error occurs or the underlying `decode` implementation panics.\n\t\tstruct State<'a, T, const N: usize> {\n\t\t\tcount: usize,\n\t\t\tslice: &'a mut [MaybeUninit<T>; N],\n\t\t}\n\n\t\timpl<T, const N: usize> Drop for State<'_, T, N> {\n\t\t\tfn drop(&mut self) {\n\t\t\t\tif !mem::needs_drop::<T>() {\n\t\t\t\t\t// If the types don't actually need to be dropped then don't even\n\t\t\t\t\t// try to run the loop below.\n\t\t\t\t\t//\n\t\t\t\t\t// Most likely won't make a difference in release mode, but will\n\t\t\t\t\t// make a difference in debug mode.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// TODO: Use `MaybeUninit::slice_assume_init_mut` + `core::ptr::drop_in_place`\n\t\t\t\t//       once `slice_assume_init_mut` is stable.\n\t\t\t\tfor item in &mut self.slice[..self.count] {\n\t\t\t\t\t// SAFETY: Each time we've read a new element we incremented `count`,\n\t\t\t\t\t//         and we only drop at most `count` elements here,\n\t\t\t\t\t//         so all of the elements we drop here are valid.\n\t\t\t\t\tunsafe {\n\t\t\t\t\t\titem.assume_init_drop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet mut state = State { count: 0, slice };\n\n\t\twhile state.count < state.slice.len() {\n\t\t\tT::decode_into(input, &mut state.slice[state.count])?;\n\t\t\tstate.count += 1;\n\t\t}\n\n\t\t// We've successfully read everything, so disarm the `Drop` impl.\n\t\tmem::forget(state);\n\n\t\t// SAFETY: We've initialized the whole slice so calling this is safe.\n\t\tunsafe { Ok(DecodeFinished::assert_decoding_finished()) }\n\t}"
}