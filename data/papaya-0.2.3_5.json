{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `raw::HashMap::<K, V, S>::insert_inner`",
    "file": "papaya-0.2.3/src/raw/mod.rs",
    "start_line": 439,
    "start_col": 5,
    "end_line": 579,
    "end_col": 6,
    "code_snippet": "fn insert_inner<'g>(\n        &self,\n        key: K,\n        value: V,\n        should_replace: bool,\n        guard: &'g impl VerifiedGuard,\n    ) -> RawInsertResult<'g, K, V> {\n        // Allocate the entry to be inserted.\n        let new_entry = untagged(Box::into_raw(Box::new(Entry { key, value })));\n\n        // Safety: We just allocated the entry above.\n        let new_ref = unsafe { &(*new_entry.ptr) };\n\n        // Load the root table.\n        let mut table = self.root(guard);\n\n        // Allocate the table if it has not been initialized yet.\n        if table.raw.is_null() {\n            table = self.init(None);\n        }\n\n        let (h1, h2) = self.hash(&new_ref.key);\n\n        let mut help_copy = true;\n        loop {\n            // Initialize the probe state.\n            let mut probe = Probe::start(h1, table.mask);\n\n            // Probe until we reach the limit.\n            let copying = 'probe: loop {\n                if probe.len > table.limit {\n                    break None;\n                }\n\n                // Load the entry metadata first for cheap searches.\n                //\n                // Safety: `probe.i` is always in-bounds for the table length.\n                let meta = unsafe { table.meta(probe.i) }.load(Ordering::Acquire);\n\n                // The entry is empty, try to insert.\n                let entry = if meta == meta::EMPTY {\n                    // Perform the insertion.\n                    //\n                    // Safety: `probe.i` is always in-bounds for the table length. Additionally,\n                    // `new_entry` was allocated above and never shared.\n                    match unsafe { self.insert_at(probe.i, h2, new_entry.raw, table, guard) } {\n                        // Successfully inserted.\n                        InsertStatus::Inserted => return RawInsertResult::Inserted(&new_ref.value),\n\n                        // Lost to a concurrent insert.\n                        //\n                        // If the key matches, we might be able to update the value.\n                        InsertStatus::Found(EntryStatus::Value(found))\n                        | InsertStatus::Found(EntryStatus::Copied(found)) => found,\n\n                        // Otherwise, continue probing.\n                        InsertStatus::Found(EntryStatus::Null) => {\n                            probe.next(table.mask);\n                            continue 'probe;\n                        }\n                    }\n                }\n                // Found a potential match.\n                else if meta == h2 {\n                    // Load the full entry.\n                    //\n                    // Safety: `probe.i` is always in-bounds for the table length.\n                    let entry = guard\n                        .protect(unsafe { table.entry(probe.i) }, Ordering::Acquire)\n                        .unpack();\n\n                    // The entry was deleted, keep probing.\n                    if entry.ptr.is_null() {\n                        probe.next(table.mask);\n                        continue 'probe;\n                    }\n\n                    // If the key matches, we might be able to update the value.\n                    entry\n                }\n                // Otherwise, continue probing.\n                else {\n                    probe.next(table.mask);\n                    continue 'probe;\n                };\n\n                // Safety: We performed a protected load of the pointer using a verified guard with\n                // `Acquire` and ensured that it is non-null, meaning it is valid for reads as long\n                // as we hold the guard.\n                let entry_ref = unsafe { &(*entry.ptr) };\n\n                // Check for a full match.\n                if entry_ref.key != new_ref.key {\n                    probe.next(table.mask);\n                    continue 'probe;\n                }\n\n                // The entry is being copied to the new table.\n                if entry.tag() & Entry::COPYING != 0 {\n                    break 'probe Some(probe.i);\n                }\n\n                // Return an error for calls to `try_insert`.\n                if !should_replace {\n                    return RawInsertResult::Error {\n                        current: &entry_ref.value,\n                        not_inserted: new_entry.ptr,\n                    };\n                }\n\n                // Try to update the value.\n                //\n                // Safety:\n                // - `probe.i` is always in-bounds for the table length\n                // - `entry` is a valid non-null entry that was inserted into the map.\n                match unsafe { self.insert_slow(probe.i, entry, new_entry.raw, table, guard) } {\n                    // Successfully performed the update.\n                    UpdateStatus::Replaced(entry) => {\n                        // Safety: `entry` is a valid non-null entry that we found in the map\n                        // before replacing it.\n                        let value = unsafe { &(*entry.ptr).value };\n                        return RawInsertResult::Replaced(value);\n                    }\n\n                    // The entry is being copied.\n                    UpdateStatus::Found(EntryStatus::Copied(_)) => break 'probe Some(probe.i),\n\n                    // The entry was deleted before we could update it, continue probing.\n                    UpdateStatus::Found(EntryStatus::Null) => {\n                        probe.next(table.mask);\n                        continue 'probe;\n                    }\n\n                    UpdateStatus::Found(EntryStatus::Value(_)) => {}\n                }\n            };\n\n            // Prepare to retry in the next table.\n            table = self.prepare_retry_insert(copying, &mut help_copy, table, guard);\n        }\n    }"
}