{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `compiled_program::CaoCompiledProgram::disassemble_writer`",
    "file": "cao-lang-0.2.6/src/compiled_program.rs",
    "start_line": 87,
    "start_col": 5,
    "end_line": 149,
    "end_col": 6,
    "code_snippet": "pub fn disassemble_writer(&self, mut writer: impl std::io::Write) -> std::io::Result<()> {\n        let mut i = 0;\n        while i < self.bytecode.len() {\n            let instr: u8 = self.bytecode[i];\n            let instr: Instruction = unsafe { transmute(instr) };\n            write!(writer, \"{i}\\t\")?;\n            // TODO: also print the arguments of the instructions\n            match instr {\n                Instruction::Add => writeln!(writer, \"Add\")?,\n                Instruction::Sub => writeln!(writer, \"Sub\")?,\n                Instruction::Mul => writeln!(writer, \"Mul\")?,\n                Instruction::Div => writeln!(writer, \"Div\")?,\n                Instruction::CallNative => writeln!(writer, \"CallNative\")?,\n                Instruction::ScalarInt => writeln!(writer, \"ScalarInt\")?,\n                Instruction::ScalarFloat => writeln!(writer, \"ScalarFloat\")?,\n                Instruction::ScalarNil => writeln!(writer, \"ScalarNil\")?,\n                Instruction::StringLiteral => writeln!(writer, \"StringLiteral\")?,\n                Instruction::CopyLast => writeln!(writer, \"CopyLast\")?,\n                Instruction::Exit => writeln!(writer, \"Exit\")?,\n                Instruction::CallFunction => writeln!(writer, \"CallFunction\")?,\n                Instruction::Equals => writeln!(writer, \"Equals\")?,\n                Instruction::NotEquals => writeln!(writer, \"NotEquals\")?,\n                Instruction::Less => writeln!(writer, \"Less\")?,\n                Instruction::LessOrEq => writeln!(writer, \"LessOrEq\")?,\n                Instruction::Pop => writeln!(writer, \"Pop\")?,\n                Instruction::SetGlobalVar => writeln!(writer, \"SetGlobalVar\")?,\n                Instruction::ReadGlobalVar => writeln!(writer, \"ReadGlobalVar\")?,\n                Instruction::SetLocalVar => writeln!(writer, \"SetLocalVar\")?,\n                Instruction::ReadLocalVar => writeln!(writer, \"ReadLocalVar\")?,\n                Instruction::ClearStack => writeln!(writer, \"ClearStack\")?,\n                Instruction::Return => writeln!(writer, \"Return\")?,\n                Instruction::SwapLast => writeln!(writer, \"SwapLast\")?,\n                Instruction::And => writeln!(writer, \"And\")?,\n                Instruction::Or => writeln!(writer, \"Or\")?,\n                Instruction::Xor => writeln!(writer, \"Xor\")?,\n                Instruction::Not => writeln!(writer, \"Not\")?,\n                Instruction::GotoIfTrue | Instruction::GotoIfFalse | Instruction::Goto => {\n                    i += 1;\n                    let pos: i32 = unsafe { decode_value(&self.bytecode, &mut i) };\n                    writeln!(writer, \"{instr:?}\\t{pos}\")?;\n                    continue;\n                }\n                Instruction::InitTable => writeln!(writer, \"InitTable\")?,\n                Instruction::GetProperty => writeln!(writer, \"GetProperty\")?,\n                Instruction::SetProperty => writeln!(writer, \"SetProperty\")?,\n                Instruction::Len => writeln!(writer, \"Len\")?,\n                Instruction::BeginForEach => writeln!(writer, \"BeginForEach\")?,\n                Instruction::ForEach => writeln!(writer, \"ForEach\")?,\n                Instruction::FunctionPointer => writeln!(writer, \"FunctionPointer\")?,\n                Instruction::NativeFunctionPointer => writeln!(writer, \"NativeFunctionPointer\")?,\n                Instruction::NthRow => writeln!(writer, \"NthRow\")?,\n                Instruction::AppendTable => writeln!(writer, \"AppendTable\")?,\n                Instruction::PopTable => writeln!(writer, \"PopTable\")?,\n                Instruction::Closure => writeln!(writer, \"Closure\")?,\n                Instruction::SetUpvalue => writeln!(writer, \"SetUpvalue\")?,\n                Instruction::ReadUpvalue => writeln!(writer, \"ReadUpvalue\")?,\n                Instruction::RegisterUpvalue => writeln!(writer, \"RegisterUpvalue\")?,\n                Instruction::CloseUpvalue => writeln!(writer, \"CloseUpvalue\")?,\n            }\n            i += instr.span();\n        }\n        Ok(())\n    }"
}