{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `generic::mmm::kernel`",
    "file": "tract-linalg-0.21.13/src/generic/mmm.rs",
    "start_line": 188,
    "start_col": 1,
    "end_line": 332,
    "end_col": 2,
    "code_snippet": "unsafe fn kernel<TI, const MR: usize, const NR: usize>(mut pnl: *const FusedKerSpec<TI>) -> isize\nwhere\n    TI: LADatum + ScaleShiftAndRound + AsPrimitive<TI>,\n    TI: AsPrimitive<f16> + AsPrimitive<f32> + AsPrimitive<f64>,\n    usize: AsPrimitive<TI>,\n    f16: AsPrimitive<TI>,\n    f32: AsPrimitive<TI>,\n    f64: AsPrimitive<TI>,\n    i8: AsPrimitive<TI>,\n    i32: AsPrimitive<TI>,\n{\n    unsafe {\n        let mut ab = [[TI::zero(); NR]; MR];\n        loop {\n            if pnl.is_null() {\n                break;\n            }\n            match *pnl {\n                FusedKerSpec::Done => break,\n                FusedKerSpec::Clear => ab = std::mem::zeroed(),\n                FusedKerSpec::LoadTile(col_major, _row_major) => {\n                    for row in 0..MR {\n                        for col in 0..NR {\n                            ab[row][col] = *col_major.add(col * MR + row);\n                        }\n                    }\n                }\n                FusedKerSpec::ScalarAdd(a) => scalar!(ab, a, |a, b| a + b),\n                FusedKerSpec::ScalarMul(a) => scalar!(ab, a, |a, b| a * b),\n                FusedKerSpec::ScalarMin(m) => scalar!(ab, m, |a, b| if a < b { a } else { b }),\n                FusedKerSpec::ScalarMax(m) => scalar!(ab, m, |a, b| if a > b { a } else { b }),\n                FusedKerSpec::ScalarSub(m) => scalar!(ab, m, |a, b| a - b),\n                FusedKerSpec::ScalarSubF(m) => scalar!(ab, m, |a, b| b - a),\n                FusedKerSpec::LeakyRelu(m) => {\n                    scalar!(ab, m, |a, b| if b > TI::zero() { b } else { a * b })\n                }\n                FusedKerSpec::PerRowMin(m) => per_row!(ab, m, |a, b| if a < b { a } else { b }),\n                FusedKerSpec::PerRowMax(m) => per_row!(ab, m, |a, b| if a > b { a } else { b }),\n                FusedKerSpec::PerRowAdd(m) => per_row!(ab, m, |a, b| a + b),\n                FusedKerSpec::PerRowMul(m) => per_row!(ab, m, |a, b| a * b),\n                FusedKerSpec::PerRowSub(m) => per_row!(ab, m, |a, b| a - b),\n                FusedKerSpec::PerRowSubF(m) => per_row!(ab, m, |a, b| b - a),\n                FusedKerSpec::PerColMin(m) => per_col!(ab, m, |a, b| if a < b { a } else { b }),\n                FusedKerSpec::PerColMax(m) => per_col!(ab, m, |a, b| if a > b { a } else { b }),\n                FusedKerSpec::PerColAdd(m) => per_col!(ab, m, |a, b| a + b),\n                FusedKerSpec::PerColMul(m) => per_col!(ab, m, |a, b| a * b),\n                FusedKerSpec::PerColSub(m) => per_col!(ab, m, |a, b| a - b),\n                FusedKerSpec::PerColSubF(m) => per_col!(ab, m, |a, b| b - a),\n                FusedKerSpec::AddRowColProducts(rows, cols) => {\n                    for i in 0..MR {\n                        for j in 0..NR {\n                            ab[i][j] += *rows.add(i) * *cols.add(j);\n                        }\n                    }\n                }\n                FusedKerSpec::AddUnicast(other) => {\n                    if TI::datum_type().is_float() && other.item_size == 2 {\n                        add_unicast::<MR, NR, TI, f16>(&mut ab, &other)\n                    } else if TI::datum_type().is_float() && other.item_size == 4 {\n                        add_unicast::<MR, NR, TI, f32>(&mut ab, &other)\n                    } else if TI::datum_type().is_float() && other.item_size == 8 {\n                        add_unicast::<MR, NR, TI, f64>(&mut ab, &other)\n                    } else if TI::datum_type() == i32::datum_type() && other.item_size == 1 {\n                        add_unicast::<MR, NR, TI, i8>(&mut ab, &other)\n                    } else if TI::datum_type() == i32::datum_type() && other.item_size == 4 {\n                        add_unicast::<MR, NR, TI, i32>(&mut ab, &other)\n                    } else {\n                        unimplemented!(\"Missing AddUnicast type\");\n                    }\n                }\n                FusedKerSpec::ShiftLeft(shift) => {\n                    for i in 0..MR {\n                        for j in 0..NR {\n                            ab[i][j] = ab[i][j].q_shl(shift);\n                        }\n                    }\n                }\n                FusedKerSpec::RoundingShiftRight(shift, rp) => {\n                    for i in 0..MR {\n                        for j in 0..NR {\n                            ab[i][j] = ab[i][j].q_shr(shift, rp);\n                        }\n                    }\n                }\n                FusedKerSpec::QScale(shift, rp, mult) => {\n                    for i in 0..MR {\n                        for j in 0..NR {\n                            ab[i][j] = ab[i][j].q_scale(Scaler::from_fuse_params(shift, rp, mult));\n                        }\n                    }\n                }\n                FusedKerSpec::AddMatMul { k, pa, pb, packing } => {\n                    use std::mem::transmute;\n                    if TI::datum_type().is_float() {\n                        match packing {\n                            0 => add_mat_mul::<MR, NR, TI, TI, TI>(pa, pb, k, &mut ab),\n                            1 => add_mat_mul::<MR, NR, TI, f16, f16>(pa, pb, k, &mut ab),\n                            2 => add_mat_mul::<MR, NR, TI, f32, f32>(pa, pb, k, &mut ab),\n                            3 => add_mat_mul::<MR, NR, TI, f16, f32>(pa, pb, k, &mut ab),\n                            4 => add_mat_mul::<MR, NR, TI, f32, f16>(pa, pb, k, &mut ab),\n                            5 => add_mat_mul_pq40::<MR, NR, f16, TI>(pa, pb, k, &mut ab),\n                            6 => add_mat_mul_pq40_scales_at_end::<MR, NR, f16, TI>(\n                                pa, pb, k, &mut ab,\n                            ),\n                            7 => add_mat_mul_pq40::<MR, NR, f32, TI>(pa, pb, k, &mut ab),\n                            _ => unreachable!(),\n                        }\n                    } else if TI::datum_type() == i32::datum_type() {\n                        // transmute to allow using explicitly i3 in add_mat_mul generic params\n                        let ab = transmute::<&mut [[TI; NR]; MR], &mut [[i32; NR]; MR]>(&mut ab);\n                        if packing == 0 {\n                            add_mat_mul::<MR, NR, i32, i32, i32>(pa, pb, k, ab)\n                        } else if packing == 1 {\n                            add_mat_mul::<MR, NR, i32, i8, i8>(pa, pb, k, ab)\n                        } else {\n                            return 1;\n                        }\n                    } else {\n                        return 1;\n                    }\n                }\n                FusedKerSpec::Store(tile) => {\n                    if TI::datum_type().is_float() {\n                        match tile.item_size {\n                            2 => store_float_t::<MR, NR, f16, _>(&tile, &ab),\n                            4 => store_float_t::<MR, NR, f32, _>(&tile, &ab),\n                            8 => store_float_t::<MR, NR, f64, _>(&tile, &ab),\n                            _ => unimplemented!(),\n                        }\n                    } else {\n                        match tile.item_size {\n                            1 => store_t::<MR, NR, u8, _>(&tile, &ab),\n                            2 => store_t::<MR, NR, u16, _>(&tile, &ab),\n                            4 => store_t::<MR, NR, u32, _>(&tile, &ab),\n                            8 => store_t::<MR, NR, u64, _>(&tile, &ab),\n                            _ => unimplemented!(),\n                        }\n                    }\n                }\n            };\n            pnl = pnl.add(1);\n        }\n    }\n    0\n}"
}