{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `gemm::im2col::Im2Col::<'_, i8>::pack_block_int8`",
    "file": "rten-0.20.0/src/gemm/im2col.rs",
    "start_line": 249,
    "start_col": 5,
    "end_line": 357,
    "end_col": 6,
    "code_snippet": "fn pack_block_int8<I: Isa, const NR_REGS: usize, const CAST_B_U8: bool>(\n        &self,\n        isa: I,\n        out: &mut [MaybeUninit<i8>],\n        rows: Range<usize>,\n        cols: Range<usize>,\n    ) {\n        let ops = isa.i32();\n        let mask_ops = ops.mask_ops();\n\n        const K_TILE: usize = size_of::<i32>() / size_of::<i8>();\n\n        debug_assert!(rows.end <= self.rows());\n        debug_assert!(cols.end <= self.cols());\n\n        let max_x_offset = ops.splat(self.max_x_offset);\n        let max_y_offset = ops.splat(self.max_y_offset);\n\n        let col_x_offsets = &self.col_offsets.x;\n        debug_assert_eq!(col_x_offsets.len() % ops.len(), 0);\n\n        let col_y_offsets = &self.col_offsets.y;\n        debug_assert_eq!(col_y_offsets.len() % ops.len(), 0);\n\n        let row_x_offsets = &self.row_offsets.x;\n        debug_assert_eq!(row_x_offsets.len() % K_TILE, 0);\n\n        let row_y_offsets = &self.row_offsets.y;\n        debug_assert_eq!(row_y_offsets.len() % K_TILE, 0);\n\n        let row_chan_offsets = &self.row_offsets.chan;\n        debug_assert_eq!(row_chan_offsets.len() % K_TILE, 0);\n\n        let img_data = self.image.storage();\n\n        let mut out_offset = 0;\n\n        for start_col in cols.step_by(ops.len() * NR_REGS) {\n            let col_y_offset: [I::I32; NR_REGS] =\n                std::array::from_fn(|i| ops.load(&col_y_offsets[start_col + i * ops.len()..]));\n            let col_x_offset: [I::I32; NR_REGS] =\n                std::array::from_fn(|i| ops.load(&col_x_offsets[start_col + i * ops.len()..]));\n            let zero = ops.zero();\n\n            let mut col_sums = [ops.zero().to_array(); NR_REGS];\n\n            for start_row in rows.clone().step_by(4) {\n                for i in 0..K_TILE {\n                    let k = start_row + i;\n                    let row_x_offset = ops.splat(unsafe { *row_x_offsets.get_unchecked(k) });\n                    let row_y_offset = ops.splat(unsafe { *row_y_offsets.get_unchecked(k) });\n                    let row_chan_offset = ops.splat(unsafe { *row_chan_offsets.get_unchecked(k) });\n\n                    for c_block in 0..NR_REGS {\n                        let x_offsets = ops.add(row_x_offset, col_x_offset[c_block]);\n                        let y_offsets = ops.add(row_y_offset, col_y_offset[c_block]);\n                        let offsets = ops.add(ops.add(x_offsets, y_offsets), row_chan_offset);\n\n                        let y_valid =\n                            mask_ops.and(ops.ge(y_offsets, zero), ops.le(y_offsets, max_y_offset));\n                        let x_valid =\n                            mask_ops.and(ops.ge(x_offsets, zero), ops.le(x_offsets, max_x_offset));\n                        let pad_mask = mask_ops.and(y_valid, x_valid);\n                        let pad_mask_array = pad_mask.to_array();\n\n                        // Set offsets to zero for padding elements. We require\n                        // this offset is always valid.\n                        let offsets_array = ops.select(offsets, zero, pad_mask).to_array();\n\n                        for idx in 0..ops.len() {\n                            let out_elem = unsafe {\n                                out.get_unchecked_mut(\n                                    out_offset + (c_block * ops.len() + idx) * K_TILE + i,\n                                )\n                            };\n                            let src_elem =\n                                unsafe { *img_data.get_unchecked(offsets_array[idx] as usize) };\n\n                            if CAST_B_U8 {\n                                let src_elem = shift_cast_i8_u8(src_elem);\n                                let elem = if pad_mask_array[idx] { src_elem } else { 0 };\n                                col_sums[c_block][idx] += elem as i32;\n                                out_elem.write(elem as i8);\n                            } else {\n                                let elem = if pad_mask_array[idx] { src_elem } else { 0 };\n                                col_sums[c_block][idx] += elem as i32;\n                                out_elem.write(elem);\n                            }\n                        }\n                    }\n                }\n                out_offset += ops.len() * NR_REGS * K_TILE;\n            }\n\n            // Store column sums at end of each panel.\n            for c_block in 0..NR_REGS {\n                let col_sum_ptr = unsafe { out.as_mut_ptr().add(out_offset) as *mut i32 };\n                for i in 0..ops.len() {\n                    unsafe {\n                        *col_sum_ptr.add(i) = col_sums[c_block][i];\n                    }\n                }\n                out_offset += ops.len() * K_TILE;\n            }\n        }\n\n        // Sanity check\n        assert_eq!(out_offset, out.len());\n    }"
}