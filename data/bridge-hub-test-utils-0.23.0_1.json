{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `test_cases::helpers::for_pallet_xcm_bridge_hub::ensure_opened_bridge`",
    "file": "bridge-hub-test-utils-0.23.0/src/test_cases/helpers.rs",
    "start_line": 394,
    "start_col": 2,
    "end_line": 466,
    "end_col": 3,
    "code_snippet": "pub fn ensure_opened_bridge<\n\t\tRuntime,\n\t\tXcmOverBridgePalletInstance,\n\t\tLocationToAccountId,\n\t\tTokenLocation>\n\t(source: Location, destination: InteriorLocation, is_paid_xcm_execution: bool, bridge_opener: impl Fn(pallet_xcm_bridge_hub::BridgeLocations, Option<Asset>)) -> (pallet_xcm_bridge_hub::BridgeLocations, pallet_xcm_bridge_hub::LaneIdOf<Runtime, XcmOverBridgePalletInstance>)\n\twhere\n\t\tRuntime: BasicParachainRuntime + BridgeXcmOverBridgeConfig<XcmOverBridgePalletInstance>,\n\t\tXcmOverBridgePalletInstance: 'static,\n\t\t<Runtime as frame_system::Config>::RuntimeCall: GetDispatchInfo + From<BridgeXcmOverBridgeCall<Runtime, XcmOverBridgePalletInstance>>,\n\t\t<Runtime as pallet_balances::Config>::Balance: From<<<Runtime as pallet_bridge_messages::Config<<Runtime as pallet_xcm_bridge_hub::Config<XcmOverBridgePalletInstance>>::BridgeMessagesPalletInstance>>::ThisChain as bp_runtime::Chain>::Balance>,\n\t\t<Runtime as pallet_balances::Config>::Balance: From<u128>,\n\t\tLocationToAccountId: ConvertLocation<AccountIdOf<Runtime>>,\n\t\tTokenLocation: Get<Location>\n\t{\n\t\t// construct expected bridge configuration\n\t\tlet locations =\n\t\t\tpallet_xcm_bridge_hub::Pallet::<Runtime, XcmOverBridgePalletInstance>::bridge_locations(\n\t\t\t\tsource.clone().into(),\n\t\t\t\tdestination.clone().into(),\n\t\t\t)\n\t\t\t\t.expect(\"valid bridge locations\");\n\t\tassert!(pallet_xcm_bridge_hub::Bridges::<Runtime, XcmOverBridgePalletInstance>::get(\n\t\t\tlocations.bridge_id()\n\t\t)\n\t\t.is_none());\n\n\t\t// SA of source location needs to have some required balance\n\t\tif !<Runtime as pallet_xcm_bridge_hub::Config<XcmOverBridgePalletInstance>>::AllowWithoutBridgeDeposit::contains(&source) {\n\t\t\t// required balance: ED + fee + BridgeDeposit\n\t\t\tlet bridge_deposit =\n\t\t\t\t<Runtime as pallet_xcm_bridge_hub::Config<XcmOverBridgePalletInstance>>::BridgeDeposit::get();\n\t\t\tlet balance_needed = <Runtime as pallet_balances::Config>::ExistentialDeposit::get() + bridge_deposit.into();\n\n\t\t\tlet source_account_id = LocationToAccountId::convert_location(&source).expect(\"valid location\");\n\t\t\tlet _ = <pallet_balances::Pallet<Runtime>>::mint_into(&source_account_id, balance_needed)\n\t\t\t\t.expect(\"mint_into passes\");\n\t\t};\n\n\t\tlet maybe_paid_execution = if is_paid_xcm_execution {\n\t\t\t// random high enough value for `BuyExecution` fees\n\t\t\tlet buy_execution_fee_amount = 5_000_000_000_000_u128;\n\t\t\tlet buy_execution_fee = (TokenLocation::get(), buy_execution_fee_amount).into();\n\n\t\t\tlet balance_needed = <Runtime as pallet_balances::Config>::ExistentialDeposit::get() +\n\t\t\t\tbuy_execution_fee_amount.into();\n\t\t\tlet source_account_id =\n\t\t\t\tLocationToAccountId::convert_location(&source).expect(\"valid location\");\n\t\t\tlet _ =\n\t\t\t\t<pallet_balances::Pallet<Runtime>>::mint_into(&source_account_id, balance_needed)\n\t\t\t\t\t.expect(\"mint_into passes\");\n\t\t\tSome(buy_execution_fee)\n\t\t} else {\n\t\t\tNone\n\t\t};\n\n\t\t// call the bridge opener\n\t\tbridge_opener(*locations.clone(), maybe_paid_execution);\n\n\t\t// check opened bridge\n\t\tlet bridge = pallet_xcm_bridge_hub::Bridges::<Runtime, XcmOverBridgePalletInstance>::get(\n\t\t\tlocations.bridge_id(),\n\t\t)\n\t\t.expect(\"opened bridge\");\n\n\t\t// check state\n\t\tassert_ok!(\n\t\t\tpallet_xcm_bridge_hub::Pallet::<Runtime, XcmOverBridgePalletInstance>::do_try_state()\n\t\t);\n\n\t\t// return locations\n\t\t(*locations, bridge.lane_id)\n\t}"
}