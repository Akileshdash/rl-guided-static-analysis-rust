{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<StreamUnordered<S> as futures_core::Stream>::poll_next`",
    "file": "streamunordered-0.5.4/src/lib.rs",
    "start_line": 744,
    "start_col": 5,
    "end_line": 926,
    "end_col": 6,
    "code_snippet": "fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n        // Keep track of how many child futures we have polled,\n        // in case we want to forcibly yield.\n        let mut polled = 0;\n\n        // Ensure `parent` is correctly set.\n        self.ready_to_run_queue.waker.register(cx.waker());\n\n        loop {\n            // Safety: &mut self guarantees the mutual exclusion `dequeue`\n            // expects\n            let task = match unsafe { self.ready_to_run_queue.dequeue() } {\n                Dequeue::Empty => {\n                    if self.is_empty() {\n                        // We can only consider ourselves terminated once we\n                        // have yielded a `None`\n                        *self.is_terminated.get_mut() = true;\n                        return Poll::Ready(None);\n                    } else {\n                        return Poll::Pending;\n                    }\n                }\n                Dequeue::Inconsistent => {\n                    // At this point, it may be worth yielding the thread &\n                    // spinning a few times... but for now, just yield using the\n                    // task system.\n                    cx.waker().wake_by_ref();\n                    return Poll::Pending;\n                }\n                Dequeue::Data(task) => task,\n            };\n\n            debug_assert!(task != self.ready_to_run_queue.stub());\n\n            // Safety:\n            // - `task` is a valid pointer.\n            // - We are the only thread that accesses the `UnsafeCell` that\n            //   contains the stream\n            let stream = match unsafe { &mut *(*task).stream.get() } {\n                Some(stream) => stream,\n\n                // If the stream has already gone away then we're just\n                // cleaning out this task. See the comment in\n                // `release_task` for more information, but we're basically\n                // just taking ownership of our reference count here.\n                None => {\n                    // This case only happens when `release_task` was called\n                    // for this task before and couldn't drop the task\n                    // because it was already enqueued in the ready to run\n                    // queue.\n\n                    // Safety: `task` is a valid pointer\n                    let task = unsafe { Arc::from_raw(task) };\n\n                    // Double check that the call to `release_task` really\n                    // happened. Calling it required the task to be unlinked.\n                    debug_assert_eq!(task.next_all.load(Relaxed), self.pending_next_all());\n                    unsafe {\n                        debug_assert!((*task.prev_all.get()).is_null());\n                    }\n                    continue;\n                }\n            };\n\n            // Safety: we only ever access is_done on the thread that owns StreamUnordered.\n            if unsafe { *(*task).is_done.get() } {\n                // This stream has already been polled to completion.\n                // We're keeping it around because the user has not removed it yet.\n                // We can ignore any wake-ups for the Stream.\n                continue;\n            }\n\n            // Safety: `task` is a valid pointer\n            let task = unsafe { self.unlink(task) };\n\n            // Unset queued flag: This must be done before polling to ensure\n            // that the stream's task gets rescheduled if it sends a wake-up\n            // notification **during** the call to `poll`.\n            let prev = task.queued.swap(false, SeqCst);\n            assert!(prev);\n\n            // We're going to need to be very careful if the `poll`\n            // method below panics. We need to (a) not leak memory and\n            // (b) ensure that we still don't have any use-after-frees. To\n            // manage this we do a few things:\n            //\n            // * A \"bomb\" is created which if dropped abnormally will call\n            //   `release_task`. That way we'll be sure the memory management\n            //   of the `task` is managed correctly. In particular\n            //   `release_task` will drop the steam. This ensures that it is\n            //   dropped on this thread and not accidentally on a different\n            //   thread (bad).\n            // * We unlink the task from our internal queue to preemptively\n            //   assume it'll panic, in which case we'll want to discard it\n            //   regardless.\n            struct Bomb<'a, S> {\n                queue: &'a mut StreamUnordered<S>,\n                task: Option<Arc<Task<S>>>,\n            }\n\n            impl<S> Drop for Bomb<'_, S> {\n                fn drop(&mut self) {\n                    if let Some(task) = self.task.take() {\n                        self.queue.release_task(task);\n                    }\n                }\n            }\n\n            let id = task.id;\n            let mut bomb = Bomb {\n                task: Some(task),\n                queue: &mut *self,\n            };\n\n            // Poll the underlying stream with the appropriate waker\n            // implementation. This is where a large bit of the unsafety\n            // starts to stem from internally. The waker is basically just\n            // our `Arc<Task<S>>` and can schedule the stream for polling by\n            // enqueuing itself in the ready to run queue.\n            //\n            // Critically though `Task<S>` won't actually access `S`, the\n            // stream, while it's floating around inside of wakers.\n            // These structs will basically just use `S` to size\n            // the internal allocation, appropriately accessing fields and\n            // deallocating the task if need be.\n            let res = {\n                let waker = Task::waker_ref(bomb.task.as_ref().unwrap());\n                let mut cx = Context::from_waker(&waker);\n\n                // Safety: We won't move the stream ever again\n                let stream = unsafe { Pin::new_unchecked(stream) };\n\n                stream.poll_next(&mut cx)\n            };\n            polled += 1;\n\n            match res {\n                Poll::Pending => {\n                    let task = bomb.task.take().unwrap();\n                    bomb.queue.link(task);\n\n                    if polled == YIELD_EVERY {\n                        // We have polled a large number of futures in a row without yielding.\n                        // To ensure we do not starve other tasks waiting on the executor,\n                        // we yield here, but immediately wake ourselves up to continue.\n                        cx.waker().wake_by_ref();\n                        return Poll::Pending;\n                    }\n                    continue;\n                }\n                Poll::Ready(None) => {\n                    // The stream has completed -- let the user know.\n                    // Note that we do not remove the stream here. Instead, we let the user decide\n                    // whether to keep the stream for a bit longer, in case they still need to do\n                    // some work with it (like if it's also a Sink and they need to flush some more\n                    // stuff).\n\n                    // Safe as we only ever access is_done on the thread that owns StreamUnordered.\n                    let task = bomb.task.take().unwrap();\n                    unsafe {\n                        *task.is_done.get() = true;\n                    }\n                    bomb.queue.link(task);\n\n                    return Poll::Ready(Some((\n                        StreamYield::Finished(FinishedStream { token: id }),\n                        id,\n                    )));\n                }\n                Poll::Ready(Some(output)) => {\n                    // We're not done with the stream just because it yielded something\n                    // We're going to need to poll it again!\n                    Task::wake_by_ref(bomb.task.as_ref().unwrap());\n\n                    // And also return it to the task queue\n                    let task = bomb.task.take().unwrap();\n                    bomb.queue.link(task);\n\n                    return Poll::Ready(Some((StreamYield::Item(output), id)));\n                }\n            }\n        }\n    }"
}