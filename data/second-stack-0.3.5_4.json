{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `Stack::buffer`",
    "file": "second-stack-0.3.5/src/lib.rs",
    "start_line": 91,
    "start_col": 5,
    "end_line": 191,
    "end_col": 6,
    "code_snippet": "pub fn buffer<T, F, R, I>(&self, i: I, f: F) -> R\n    where\n        I: Iterator<Item = T>,\n        F: FnOnce(&mut [T]) -> R,\n    {\n        // Special case for ZST\n        if size_of::<T>() == 0 {\n            let mut v: Vec<_> = i.collect();\n            return f(&mut v);\n        }\n\n        // Data goes in a struct in case user code panics.\n        // User code includes Iterator::next, FnOnce, and Drop::drop\n        struct Writer<'a, T> {\n            restore: Option<DropStack<'a>>,\n            base: *mut T,\n            len: usize,\n            capacity: usize,\n        }\n\n        impl<T> Writer<'_, T> {\n            unsafe fn write(&mut self, item: T) {\n                self.base.add(self.len).write(item);\n                self.len += 1;\n            }\n\n            fn try_reuse(&mut self, stack: &mut Allocation) -> bool {\n                if let Some(prev) = &self.restore {\n                    if prev.restore.ref_eq(stack) {\n                        // If we are already are using this stack, we know the\n                        // end ptr is already aligned. To double in size,\n                        // we would need as many bytes as there are currently\n                        // and do not need to align\n                        let required_bytes = size_of::<T>() * self.capacity;\n\n                        if stack.remaining_bytes() >= required_bytes {\n                            stack.len += required_bytes;\n                            self.capacity *= 2;\n                            return true;\n                        }\n                    }\n                }\n                false\n            }\n        }\n\n        impl<T> Drop for Writer<'_, T> {\n            fn drop(&mut self) {\n                unsafe {\n                    for i in 0..self.len {\n                        self.base.add(i).drop_in_place()\n                    }\n                }\n            }\n        }\n\n        unsafe {\n            let mut writer = Writer {\n                restore: None,\n                base: ptr::null_mut(),\n                capacity: 0,\n                len: 0,\n            };\n\n            for next in i {\n                if writer.capacity == writer.len {\n                    let stack = &mut *self.0.get();\n\n                    // First try to use the same stack, but if that fails\n                    // copy over to the upsized stack\n                    if !writer.try_reuse(stack) {\n                        // This will always be a different allocation, otherwise\n                        // try_reuse would have succeeded\n                        let (restore, (base, capacity)) =\n                            stack.get_slice(&self.0, (writer.len * 2).max(1));\n\n                        // Check for 0 is to avoid copy from null ptr (miri violation)\n                        if writer.len != 0 {\n                            ptr::copy_nonoverlapping(writer.base, base, writer.len);\n                        }\n\n                        // This attempts to restore the old allocation when\n                        // writer.restore is Some, but we know that there\n                        // is a new allocation at this point, so the only\n                        // thing it can do is free memory\n                        writer.restore = Some(restore);\n\n                        writer.capacity = capacity;\n                        writer.base = base;\n                    }\n                }\n                writer.write(next);\n            }\n\n            // TODO: (Performance?) Drop reserve of unused stack, if any. We have over-allocated.\n            // TODO: (Performance?) Consider using size_hint\n\n            let buffer = slice::from_raw_parts_mut(writer.base, writer.len);\n            f(buffer)\n        }\n    }"
}