{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `utils::glob::glob::ReadDirRunner::<TEnvironment>::run`",
    "file": "dprint-0.50.1/src/utils/glob/glob.rs",
    "start_line": 125,
    "start_col": 3,
    "end_line": 191,
    "end_col": 4,
    "code_snippet": "pub fn run(&self) {\n    while let Some(pending_dirs) = self.get_next_pending_dirs() {\n      let mut pending_count = 0;\n      let mut all_entries = Vec::new();\n      for current_dir in pending_dirs.into_iter().flatten() {\n        let info_result = self.environment.dir_info(&current_dir);\n        let entries = match info_result {\n          Ok(entries) => {\n            if entries.is_empty() {\n              continue;\n            }\n            let maybe_config_file = if self.options.config_discovery.traverse_descendants() && current_dir != self.options.start_dir {\n              entries\n                .iter()\n                .filter_map(|e| match e {\n                  DirEntry::Directory(_) => None,\n                  DirEntry::File { name, path } => {\n                    if matches!(name.to_str(), Some(\".dprint.json\" | \"dprint.json\" | \".dprint.jsonc\" | \"dprint.jsonc\")) {\n                      Some(path)\n                    } else {\n                      None\n                    }\n                  }\n                })\n                .next()\n            } else {\n              None\n            };\n            if let Some(config_file) = maybe_config_file {\n              vec![DirOrConfigEntry::Config(config_file.clone())]\n            } else {\n              entries\n                .into_iter()\n                .map(|e| match e {\n                  DirEntry::Directory(path) => DirOrConfigEntry::Dir(path),\n                  DirEntry::File { path, .. } => DirOrConfigEntry::File(path),\n                })\n                .collect::<Vec<_>>()\n            }\n          }\n          Err(err) => {\n            let ignore_error = is_system_volume_error(&current_dir, &err);\n            if ignore_error {\n              continue;\n            }\n            if err.kind() == std::io::ErrorKind::PermissionDenied {\n              log_warn!(self.environment, \"WARNING: Ignoring directory. Permission denied: {}\", current_dir.display());\n              continue;\n            } else {\n              self.set_glob_error(anyhow!(\"Error reading dir '{}': {:#}\", current_dir.display(), err));\n              return;\n            }\n          }\n        };\n        pending_count += entries.len();\n        all_entries.push(DirEntries { path: current_dir, entries });\n        // it is much faster to batch these than to hit the lock every time\n        if pending_count > PUSH_DIR_ENTRIES_BATCH_COUNT {\n          self.push_entries(std::mem::take(&mut all_entries));\n          pending_count = 0;\n        }\n      }\n      if !all_entries.is_empty() {\n        self.push_entries(all_entries);\n      }\n    }\n  }"
}