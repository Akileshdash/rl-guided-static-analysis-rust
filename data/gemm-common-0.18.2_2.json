{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<gemv::mixed_gemv_colmajor::implementation::Impl<'_, Lhs, Rhs, Dst, Acc, S> as pulp::NullaryFnOnce>::call`",
    "file": "gemm-common-0.18.2/src/gemv.rs",
    "start_line": 167,
    "start_col": 13,
    "end_line": 263,
    "end_col": 14,
    "code_snippet": "fn call(self) -> Self::Output {\n                unsafe {\n                    let Self {\n                        simd,\n                        m,\n                        k,\n                        noalias_dst,\n                        lhs,\n                        lhs_cs,\n                        rhs,\n                        rhs_cs: _,\n                        rhs_rs,\n                        mut alpha,\n                        beta,\n                    } = self;\n\n                    let lane = S::SIMD_WIDTH;\n                    let dst = noalias_dst.0.as_mut_ptr();\n                    let m_lane = m / lane * lane;\n                    for col in 0..k {\n                        let lhs = lhs.wrapping_offset(col as isize * lhs_cs);\n                        let rhs = simd.from_rhs(*rhs.wrapping_offset(col as isize * rhs_rs));\n\n                        let alpha_s = alpha;\n                        let alpha_v = simd.simd_splat(alpha_s);\n\n                        let rhs_scalar = simd.mult(beta, rhs);\n                        let rhs = simd.simd_splat(rhs_scalar);\n\n                        if alpha_s.is_zero() {\n                            let mut row = 0usize;\n                            while row < m_lane {\n                                let dst_ptr = dst.wrapping_add(row) as *mut S::DstN;\n                                let lhs =\n                                    simd.simd_from_lhs(*(lhs.wrapping_add(row) as *const S::LhsN));\n                                *dst_ptr = simd.simd_into_dst(simd.simd_mul(lhs, rhs));\n                                row += lane;\n                            }\n                            while row < m {\n                                let dst_ptr = dst.wrapping_add(row);\n                                let lhs = simd.from_lhs(*lhs.wrapping_add(row));\n                                *dst_ptr = simd.into_dst(simd.mult(lhs, rhs_scalar));\n                                row += 1;\n                            }\n                        } else if alpha_s.is_one() {\n                            let mut row = 0usize;\n                            while row < m_lane {\n                                let dst_ptr = dst.wrapping_add(row) as *mut S::DstN;\n                                let dst = *dst_ptr;\n                                let lhs =\n                                    simd.simd_from_lhs(*(lhs.wrapping_add(row) as *const S::LhsN));\n                                *dst_ptr = simd.simd_into_dst(simd.simd_mult_add(\n                                    lhs,\n                                    rhs,\n                                    simd.simd_from_dst(dst),\n                                ));\n                                row += lane;\n                            }\n                            while row < m {\n                                let dst_ptr = dst.wrapping_add(row);\n                                let dst = *dst_ptr;\n                                let lhs = simd.from_lhs(*lhs.wrapping_add(row));\n                                *dst_ptr = simd.into_dst(simd.mult_add(\n                                    lhs,\n                                    rhs_scalar,\n                                    simd.from_dst(dst),\n                                ));\n                                row += 1;\n                            }\n                        } else {\n                            let mut row = 0usize;\n                            while row < m_lane {\n                                let dst_ptr = dst.wrapping_add(row) as *mut S::DstN;\n                                let dst = *dst_ptr;\n                                let lhs =\n                                    simd.simd_from_lhs(*(lhs.wrapping_add(row) as *const S::LhsN));\n                                *dst_ptr = simd.simd_into_dst(simd.simd_add(\n                                    simd.simd_mul(lhs, rhs),\n                                    simd.simd_mul(alpha_v, simd.simd_from_dst(dst)),\n                                ));\n                                row += lane;\n                            }\n                            while row < m {\n                                let dst_ptr = dst.wrapping_add(row);\n                                let dst = *dst_ptr;\n                                let lhs = simd.from_lhs(*lhs.wrapping_add(row));\n                                *dst_ptr = simd.into_dst(simd.add(\n                                    simd.mult(lhs, rhs_scalar),\n                                    simd.mult(alpha_s, simd.from_dst(dst)),\n                                ));\n                                row += 1;\n                            }\n                        }\n                        alpha = Acc::one();\n                    }\n                }\n            }"
}