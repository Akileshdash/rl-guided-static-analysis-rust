{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `eval::runtime::params::spec::ParametersSpec::<values::layout::value::Value<'v>>::collect_slow`",
    "file": "starlark-0.13.0/src/eval/runtime/params/spec.rs",
    "start_line": 568,
    "start_col": 5,
    "end_line": 790,
    "end_col": 6,
    "code_snippet": "fn collect_slow<'a, A: ArgumentsImpl<'v, 'a>>(\n        &self,\n        args: &A,\n        slots: &mut [Option<Value<'v>>],\n        heap: &'v Heap,\n    ) -> crate::Result<()>\n    where\n        'v: 'a,\n    {\n        /// Lazily initialized `kwargs` object.\n        #[derive(Default)]\n        struct LazyKwargs<'v> {\n            kwargs: Option<SmallMap<StringValue<'v>, Value<'v>>>,\n        }\n\n        impl<'v> LazyKwargs<'v> {\n            // Return true if the value is a duplicate\n            #[inline(always)]\n            fn insert(&mut self, key: Hashed<StringValue<'v>>, val: Value<'v>) -> bool {\n                match &mut self.kwargs {\n                    None => {\n                        let mut mp = SmallMap::with_capacity(12);\n                        mp.insert_hashed_unique_unchecked(key, val);\n                        self.kwargs = Some(mp);\n                        false\n                    }\n                    Some(mp) => mp.insert_hashed(key, val).is_some(),\n                }\n            }\n\n            #[inline(always)]\n            fn insert_unique_unchecked(&mut self, key: Hashed<StringValue<'v>>, val: Value<'v>) {\n                match &mut self.kwargs {\n                    None => {\n                        let mut mp = SmallMap::with_capacity(12);\n                        mp.insert_hashed_unique_unchecked(key, val);\n                        self.kwargs = Some(mp);\n                    }\n                    Some(mp) => {\n                        mp.insert_hashed_unique_unchecked(key, val);\n                    }\n                }\n            }\n\n            fn alloc(self, heap: &'v Heap) -> Value<'v> {\n                let kwargs = match self.kwargs {\n                    Some(kwargs) => Dict::new(coerce(kwargs)),\n                    None => Dict::default(),\n                };\n                heap.alloc(kwargs)\n            }\n        }\n\n        let len = self.param_kinds.len();\n        // We might do unchecked stuff later on, so make sure we have as many slots as we expect\n        assert!(slots.len() >= len);\n\n        let mut star_args = Vec::new();\n        let mut kwargs = LazyKwargs::default();\n        let mut next_position = 0;\n\n        // First deal with positional parameters\n        if args.pos().len() <= (self.indices.num_positional as usize) {\n            // fast path for when we don't need to bounce down to filling in args\n            for (v, s) in args.pos().iter().zip(slots.iter_mut()) {\n                *s = Some(*v);\n            }\n            next_position = args.pos().len();\n        } else {\n            for v in args.pos() {\n                if next_position < (self.indices.num_positional as usize) {\n                    slots[next_position] = Some(*v);\n                    next_position += 1;\n                } else {\n                    star_args.push(*v);\n                }\n            }\n        }\n\n        // Next deal with named parameters\n        // The lowest position at which we've written a name.\n        // If at the end lowest_name is less than next_position, we got the same variable twice.\n        // So no duplicate checking until after all positional arguments\n        let mut lowest_name = usize::MAX;\n        // Avoid a lot of loop setup etc in the common case\n        if !args.names().names().is_empty() {\n            for ((name, name_value), v) in args.names().names().iter().zip(args.named()) {\n                // Safe to use new_unchecked because hash for the Value and str are the same\n                match name.get_index_from_param_spec(self) {\n                    None => {\n                        kwargs.insert_unique_unchecked(\n                            Hashed::new_unchecked(name.small_hash(), *name_value),\n                            *v,\n                        );\n                    }\n                    Some(i) => {\n                        slots[i] = Some(*v);\n                        lowest_name = cmp::min(lowest_name, i);\n                    }\n                }\n            }\n        }\n\n        // Next up are the *args parameters\n        if let Some(param_args) = args.args() {\n            for v in param_args\n                .iterate(heap)\n                .map_err(|_| FunctionError::ArgsArrayIsNotIterable)?\n            {\n                if next_position < (self.indices.num_positional as usize) {\n                    slots[next_position] = Some(v);\n                    next_position += 1;\n                } else {\n                    star_args.push(v);\n                }\n            }\n        }\n\n        // Check if the named arguments clashed with the positional arguments\n        if unlikely(next_position > lowest_name) {\n            return Err(FunctionError::RepeatedArg {\n                name: self.param_names[lowest_name].clone(),\n            }\n            .into());\n        }\n\n        // Now insert the kwargs, if there are any\n        if let Some(param_kwargs) = args.kwargs() {\n            match DictRef::from_value(param_kwargs) {\n                Some(y) => {\n                    for (k, v) in y.iter_hashed() {\n                        match StringValue::new(*k.key()) {\n                            None => return Err(FunctionError::ArgsValueIsNotString.into()),\n                            Some(s) => {\n                                let repeat = match self\n                                    .names\n                                    .get_hashed_string_value(Hashed::new_unchecked(k.hash(), s))\n                                {\n                                    None => kwargs.insert(Hashed::new_unchecked(k.hash(), s), v),\n                                    Some(i) => {\n                                        let this_slot = &mut slots[*i as usize];\n                                        let repeat = this_slot.is_some();\n                                        *this_slot = Some(v);\n                                        repeat\n                                    }\n                                };\n                                if unlikely(repeat) {\n                                    return Err(FunctionError::RepeatedArg {\n                                        name: s.as_str().to_owned(),\n                                    }\n                                    .into());\n                                }\n                            }\n                        }\n                    }\n                }\n                None => return Err(FunctionError::KwArgsIsNotDict.into()),\n            }\n        }\n\n        // We have moved parameters into all the relevant slots, so need to finalise things.\n        // We need to set default values and error if any required values are missing\n        let kinds = &*self.param_kinds;\n        // This code is very hot, and setting up iterators was a noticeable bottleneck.\n        for index in next_position..kinds.len() {\n            // The number of locals must be at least the number of parameters, see `collect`\n            // which reserves `max(_, kinds.len())`.\n            let slot = unsafe { slots.get_unchecked_mut(index) };\n            let def = unsafe { kinds.get_unchecked(index) };\n\n            // We know that up to next_position got filled positionally, so we don't need to check those\n            if slot.is_some() {\n                continue;\n            }\n            match def {\n                ParameterKind::Required => {\n                    let function_name = &self.function_name;\n                    let param_name = &self.param_names[index];\n                    if index < self.indices.num_positional_only as usize {\n                        return Err(function_error!(\n                            \"Missing positional-only parameter `{param_name}` for call to `{function_name}`\",\n                        ));\n                    } else if index >= self.indices.num_positional as usize {\n                        return Err(function_error!(\n                            \"Missing named-only parameter `{param_name}` for call to `{function_name}`\",\n                        ));\n                    } else {\n                        return Err(function_error!(\n                            \"Missing parameter `{param_name}` for call to `{function_name}`\"\n                        ));\n                    }\n                }\n                ParameterKind::Defaulted(x) => {\n                    *slot = Some(x.to_value());\n                }\n                _ => {}\n            }\n        }\n\n        // Now set the kwargs/args slots, if they are requested, and fail it they are absent but used\n        // Note that we deliberately give warnings about missing parameters _before_ giving warnings\n        // about unexpected extra parameters, so if a user misspells an argument they get a better error.\n        if let Some(args_pos) = self.indices.args {\n            slots[args_pos as usize] = Some(heap.alloc_tuple(&star_args));\n        } else if unlikely(!star_args.is_empty()) {\n            return Err(FunctionError::ExtraPositionalArg {\n                count: star_args.len(),\n                function: self.signature(),\n            }\n            .into());\n        }\n\n        if let Some(kwargs_pos) = self.indices.kwargs {\n            slots[kwargs_pos as usize] = Some(kwargs.alloc(heap));\n        } else if let Some(kwargs) = kwargs.kwargs {\n            return Err(FunctionError::ExtraNamedArg {\n                names: kwargs.keys().map(|x| x.as_str().to_owned()).collect(),\n                function: self.signature(),\n            }\n            .into());\n        }\n        Ok(())\n    }"
}