{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `local::link_soem::SOEMECatThreadGuard::ecat_run`",
    "file": "autd3-link-soem-35.0.1/src/local/link_soem.rs",
    "start_line": 607,
    "start_col": 5,
    "end_line": 716,
    "end_col": 6,
    "code_snippet": "fn ecat_run<S: Sleep>(\n        is_open: Arc<AtomicBool>,\n        io_map: Arc<Mutex<IOMap>>,\n        wkc: Arc<AtomicI32>,\n        buffer_queue_sender: Sender<Vec<TxMessage>>,\n        receiver: Receiver<Vec<TxMessage>>,\n        cycle: Duration,\n        sleeper: S,\n        thread_priority: ThreadPriority,\n        #[cfg(target_os = \"windows\")] process_priority: super::ProcessPriority,\n        affinity: Option<core_affinity::CoreId>,\n    ) -> Result<(), SOEMError> {\n        if let Some(affinity) = affinity {\n            tracing::info!(\n                \"Setting CPU affinity for the EtherCAT thread to {:?}\",\n                affinity\n            );\n            if !core_affinity::set_for_current(affinity) {\n                tracing::error!(\"Failed to set CPU affinity for the EtherCAT thread.\");\n                return Err(SOEMError::AffinitySetFailed(affinity));\n            }\n        }\n\n        unsafe {\n            #[cfg(target_os = \"windows\")]\n            let old_priority = {\n                let old_priority = windows::Win32::System::Threading::GetPriorityClass(\n                    windows::Win32::System::Threading::GetCurrentProcess(),\n                );\n                if let Err(e) = windows::Win32::System::Threading::SetPriorityClass(\n                    windows::Win32::System::Threading::GetCurrentProcess(),\n                    process_priority.into(),\n                ) {\n                    tracing::warn!(\n                        \"Failed to set process priority to {:?}: {:?}.\",\n                        process_priority,\n                        e\n                    );\n                }\n                old_priority\n            };\n            thread_priority.set_for_current()?;\n\n            let mut cnt_miss_deadline = 0;\n            let mut toff = time::Duration::ZERO;\n            let mut integral = 0;\n            ec_send_processdata();\n            let mut ts = {\n                let tp = time::OffsetDateTime::now_utc();\n                let tp_unix_ns = tp.unix_timestamp_nanos();\n                let cycle_ns = cycle.as_nanos() as i128;\n                let ts_unix_ns = (tp_unix_ns / cycle_ns + 1) * cycle_ns;\n                time::OffsetDateTime::from_unix_timestamp_nanos(ts_unix_ns).unwrap()\n            };\n            while is_open.load(Ordering::Acquire) {\n                ts += cycle;\n                ts += toff;\n\n                let duration = ts - time::OffsetDateTime::now_utc();\n                if duration > time::Duration::ZERO {\n                    sleeper.sleep(std::time::Duration::from_nanos(\n                        duration.whole_nanoseconds() as _,\n                    ));\n                    cnt_miss_deadline = 0;\n                } else {\n                    cnt_miss_deadline += 1;\n                    if cnt_miss_deadline == 1000 {\n                        tracing::warn!(\n                            \"Slow network was detected. Increase send_cycle and sync0_cycle and restart the program, or reboot the network adapter and device.\"\n                        );\n                        cnt_miss_deadline = 0;\n                    }\n                }\n\n                wkc.store(\n                    ec_receive_processdata(EC_TIMEOUTRET as i32),\n                    Ordering::Relaxed,\n                );\n\n                toff = Self::ec_sync(ec_DCtime, cycle.as_nanos() as _, &mut integral);\n\n                if let Ok(tx) = receiver.try_recv() {\n                    match io_map.lock() {\n                        Ok(mut io_map) => io_map.copy_from(&tx),\n                        Err(_) => {\n                            is_open.store(false, Ordering::Release);\n                            break;\n                        }\n                    }\n                    let _ = buffer_queue_sender.send(tx);\n                }\n                ec_send_processdata();\n            }\n\n            #[cfg(target_os = \"windows\")]\n            {\n                if let Err(e) = windows::Win32::System::Threading::SetPriorityClass(\n                    windows::Win32::System::Threading::GetCurrentProcess(),\n                    windows::Win32::System::Threading::PROCESS_CREATION_FLAGS(old_priority),\n                ) {\n                    tracing::warn!(\n                        \"Failed to restore process priority to {:?}: {:?}.\",\n                        old_priority,\n                        e\n                    );\n                }\n            }\n        }\n        Ok(())\n    }"
}