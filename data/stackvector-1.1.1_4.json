{
    "level": "Warning",
    "analyzer": "UnsafeDataflow",
    "op_type": "WriteFlow",
    "description": "Potential unsafe dataflow issue in `StackVec::<A>::insert_many`",
    "file": "stackvector-1.1.1/src/lib.rs",
    "start_line": 571,
    "start_col": 5,
    "end_line": 635,
    "end_col": 6,
    "code_snippet": "pub fn insert_many<I: iter::IntoIterator<Item = A::Item>>(\n        &mut self,\n        index: usize,\n        iterable: I,\n    ) {\n        let mut iter = iterable.into_iter();\n        if index == self.len() {\n            return self.extend(iter);\n        }\n\n        let (lower_size_bound, _) = iter.size_hint();\n        assert!(lower_size_bound <= lib::isize::MAX as usize); // Ensure offset is indexable\n        assert!(index + lower_size_bound >= index); // Protect against overflow\n        assert!(self.len() + lower_size_bound <= self.capacity());\n\n        let mut num_added = 0;\n        let old_len = self.len();\n        assert!(index <= old_len);\n\n\n        unsafe {\n            let start = self.as_mut_ptr();\n            let ptr = start.add(index);\n\n            // Move the trailing elements.\n            ptr::copy(ptr, ptr.padd(lower_size_bound), old_len - index);\n\n            // In case the iterator panics, don't double-drop the items we just copied above.\n            self.set_len(0);\n            let mut guard = DropOnPanic {\n                start,\n                skip: index..(index + lower_size_bound),\n                len: old_len + lower_size_bound,\n            };\n\n            while num_added < lower_size_bound {\n                let element = match iter.next() {\n                    Some(x) => x,\n                    None => break,\n                };\n                let cur = ptr.add(num_added);\n                ptr::write(cur, element);\n                guard.skip.start += 1;\n                num_added += 1;\n            }\n\n            if num_added < lower_size_bound {\n                // Iterator provided fewer elements than the hint. Move the tail backward.\n                ptr::copy(\n                    ptr.add(lower_size_bound),\n                    ptr.add(num_added),\n                    old_len - index,\n                );\n            }\n            // There are no more duplicate or uninitialized slots, so the guard is not needed.\n            self.set_len(old_len + num_added);\n            mem::forget(guard);\n\n            // Insert any remaining elements one-by-one.\n            for element in iter {\n                self.insert(index + num_added, element);\n                num_added += 1;\n            }\n        }\n    }"
}