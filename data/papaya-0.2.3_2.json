{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `raw::HashMap::<K, V, S>::insert_copy`",
    "file": "papaya-0.2.3/src/raw/mod.rs",
    "start_line": 2362,
    "start_col": 5,
    "end_line": 2441,
    "end_col": 6,
    "code_snippet": "unsafe fn insert_copy(\n        &self,\n        new_entry: Tagged<Entry<K, V>>,\n        resize: bool,\n        table: &Table<Entry<K, V>>,\n        guard: &impl VerifiedGuard,\n    ) -> Option<(Table<Entry<K, V>>, usize)> {\n        // Safety: The new entry is guaranteed to be valid for reads.\n        let key = unsafe { &(*new_entry.ptr).key };\n\n        let mut table = *table;\n        let (h1, h2) = self.hash(key);\n\n        loop {\n            // Initialize the probe state.\n            let mut probe = Probe::start(h1, table.mask);\n\n            // Probe until we reach the limit.\n            while probe.len <= table.limit {\n                // Safety: `probe.i` is always in-bounds for the table length.\n                let meta_entry = unsafe { table.meta(probe.i) };\n\n                // Load the entry metadata first for cheap searches.\n                let meta = meta_entry.load(Ordering::Acquire);\n\n                // The entry is empty, try to insert.\n                if meta == meta::EMPTY {\n                    // Safety: `probe.i` is always in-bounds for the table length.\n                    let entry = unsafe { table.entry(probe.i) };\n\n                    // Try to claim the entry.\n                    match guard.compare_exchange(\n                        entry,\n                        ptr::null_mut(),\n                        new_entry.raw,\n                        Ordering::Release,\n                        Ordering::Acquire,\n                    ) {\n                        // Successfully inserted.\n                        Ok(_) => {\n                            // Update the metadata table.\n                            meta_entry.store(h2, Ordering::Release);\n                            return Some((table, probe.i));\n                        }\n                        Err(found) => {\n                            let found = found.unpack();\n\n                            // The entry was deleted or copied.\n                            let meta = if found.ptr.is_null() {\n                                meta::TOMBSTONE\n                            } else {\n                                // Safety: We performed a protected load of the pointer using a verified guard with\n                                // `Acquire` and ensured that it is non-null, meaning it is valid for reads as long\n                                // as we hold the guard.\n                                let found_ref = unsafe { &(*found.ptr) };\n\n                                // Ensure the meta table is updated to avoid breaking the probe chain.\n                                let hash = self.hasher.hash_one(&found_ref.key);\n                                meta::h2(hash)\n                            };\n\n                            if meta_entry.load(Ordering::Relaxed) == meta::EMPTY {\n                                meta_entry.store(meta, Ordering::Release);\n                            }\n                        }\n                    }\n                }\n\n                // Continue probing.\n                probe.next(table.mask);\n            }\n\n            if !resize {\n                return None;\n            }\n\n            // Insert into the next table.\n            table = self.get_or_alloc_next(None, table);\n        }\n    }"
}