{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `ssl::callbacks::raw_verify`",
    "file": "variant-ssl-0.17.3/src/ssl/callbacks.rs",
    "start_line": 40,
    "start_col": 1,
    "end_line": 60,
    "end_col": 2,
    "code_snippet": "pub extern \"C\" fn raw_verify<F>(preverify_ok: c_int, x509_ctx: *mut ffi::X509_STORE_CTX) -> c_int\nwhere\n    F: Fn(bool, &mut X509StoreContextRef) -> bool + 'static + Sync + Send,\n{\n    unsafe {\n        let ctx = X509StoreContextRef::from_ptr_mut(x509_ctx);\n        let ssl_idx = X509StoreContext::ssl_idx().expect(\"BUG: store context ssl index missing\");\n        let verify_idx = SslContext::cached_ex_index::<F>();\n\n        // raw pointer shenanigans to break the borrow of ctx\n        // the callback can't mess with its own ex_data slot so this is safe\n        let verify = ctx\n            .ex_data(ssl_idx)\n            .expect(\"BUG: store context missing ssl\")\n            .ssl_context()\n            .ex_data(verify_idx)\n            .expect(\"BUG: verify callback missing\") as *const F;\n\n        (*verify)(preverify_ok != 0, ctx) as c_int\n    }\n}"
}