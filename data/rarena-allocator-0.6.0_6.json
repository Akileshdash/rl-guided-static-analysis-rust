{
    "level": "Warning",
    "analyzer": "UnsafeDestructor",
    "op_type": null,
    "description": "unsafe block detected in drop",
    "file": "rarena-allocator-0.6.0/src/sync.rs",
    "start_line": 1665,
    "start_col": 1,
    "end_line": 1665,
    "end_col": 20,
    "code_snippet": "impl Drop for Arena {\n  fn drop(&mut self) {\n    unsafe {\n      let memory_ptr = self.inner.as_ptr();\n      let memory = &*memory_ptr;\n      // `Memory` storage... follow the drop steps from Arc.\n      if memory.refs().fetch_sub(1, Ordering::Release) != 1 {\n        return;\n      }\n\n      // This fence is needed to prevent reordering of use of the data and\n      // deletion of the data.  Because it is marked `Release`, the decreasing\n      // of the reference count synchronizes with this `Acquire` fence. This\n      // means that use of the data happens before decreasing the reference\n      // count, which happens before this fence, which happens before the\n      // deletion of the data.\n      //\n      // As explained in the [Boost documentation][1],\n      //\n      // > It is important to enforce any possible access to the object in one\n      // > thread (through an existing reference) to *happen before* deleting\n      // > the object in a different thread. This is achieved by a \"release\"\n      // > operation after dropping a reference (any access to the object\n      // > through this reference must obviously happened before), and an\n      // > \"acquire\" operation before deleting the object.\n      //\n      // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n      //\n      // Thread sanitizer does not support atomic fences. Use an atomic load\n      // instead.\n      memory.refs().load(Ordering::Acquire);\n      // Drop the data\n      let mut memory = Box::from_raw(memory_ptr);\n\n      // Relaxed is enough here as we're in a drop, no one else can\n      // access this memory anymore.\n      memory.unmount();\n    }\n  }\n}"
}