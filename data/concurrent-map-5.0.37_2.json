{
    "level": "Warning",
    "analyzer": "UnsafeDestructor",
    "op_type": null,
    "description": "unsafe block detected in drop",
    "file": "concurrent-map-5.0.37/src/lib.rs",
    "start_line": 647,
    "start_col": 1,
    "end_line": 651,
    "end_col": 38,
    "code_snippet": "impl<K, V, const FANOUT: usize, const LOCAL_GC_BUFFER_SIZE: usize> Drop\n    for Inner<K, V, FANOUT, LOCAL_GC_BUFFER_SIZE>\nwhere\n    K: 'static + Clone + Minimum + Ord + Send + Sync,\n    V: 'static + Clone + Send + Sync,\n{\n    fn drop(&mut self) {\n        #[cfg(feature = \"timing\")]\n        self.print_timing();\n\n        let ebr = Ebr::default();\n        let mut guard = ebr.pin();\n\n        let mut cursor: NodeView<K, V, FANOUT> = self.root(&mut guard);\n\n        let mut lhs_chain: Vec<BoxedAtomicPtr<K, V, FANOUT>> = vec![];\n\n        loop {\n            lhs_chain.push(cursor.id);\n            if cursor.is_leaf() {\n                break;\n            }\n            let child_ptr: BoxedAtomicPtr<K, V, FANOUT> = cursor.index().get_index(0).unwrap().1;\n\n            cursor = child_ptr.node_view(&mut guard).unwrap();\n        }\n\n        let mut layer = 0;\n        for lhs_ptr in lhs_chain {\n            layer += 1;\n\n            let mut min_fill_physical: f64 = 1.0;\n            let mut max_fill_physical: f64 = 0.0;\n            let mut fill_sum_physical: f64 = 0.0;\n\n            let mut min_fill_logical: f64 = 1.0;\n            let mut max_fill_logical: f64 = 0.0;\n            let mut fill_sum_logical: f64 = 0.0;\n            let mut nodes_counted: usize = 0;\n\n            let mut next_opt: Option<BoxedAtomicPtr<K, V, FANOUT>> = Some(lhs_ptr);\n            while let Some(next) = next_opt {\n                assert!(!next.0.is_null());\n                let sibling_cursor = next.node_view(&mut guard).unwrap();\n\n                let fill_phy = ((size_of::<K>() + size_of::<V>()) * sibling_cursor.len()) as f64\n                    / size_of::<Node<K, V, FANOUT>>() as f64;\n                min_fill_physical = min_fill_physical.min(fill_phy);\n                max_fill_physical = max_fill_physical.max(fill_phy);\n                fill_sum_physical += fill_phy;\n\n                let fill_log = sibling_cursor.len() as f64 / FANOUT as f64;\n                min_fill_logical = min_fill_logical.min(fill_log);\n                max_fill_logical = max_fill_logical.max(fill_log);\n                fill_sum_logical += fill_log;\n                nodes_counted += 1;\n\n                next_opt = sibling_cursor.next;\n                let node_box = unsafe { Box::from_raw(sibling_cursor.ptr.as_ptr()) };\n                drop(node_box);\n\n                let reclaimed_ptr: Box<AtomicPtr<Node<K, V, FANOUT>>> =\n                    unsafe { Box::from_raw(next.0 as *mut _) };\n                drop(reclaimed_ptr);\n            }\n\n            if cfg!(feature = \"print_utilization_on_drop\") {\n                println!(\"layer {layer} count {nodes_counted}\");\n                println!(\n                    \"logical: min: {min_fill_logical} max: {max_fill_logical} avg: {}\",\n                    fill_sum_logical / nodes_counted as f64\n                );\n                println!(\n                    \"physical: min: {min_fill_physical} max: {max_fill_physical} avg: {}\",\n                    fill_sum_physical / nodes_counted as f64\n                );\n            }\n        }\n    }\n}"
}