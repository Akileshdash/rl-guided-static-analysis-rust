{
    "level": "Warning",
    "analyzer": "UnsafeDestructor",
    "op_type": null,
    "description": "unsafe block detected in drop",
    "file": "glommio-0.9.0/src/task/join_handle.rs",
    "start_line": 85,
    "start_col": 1,
    "end_line": 85,
    "end_col": 31,
    "code_snippet": "impl<R> Drop for JoinHandle<R> {\n    fn drop(&mut self) {\n        let ptr = self.raw_task.as_ptr();\n        dbg_context!(ptr, \"drop_join_handle\", {\n            let header = ptr as *mut Header;\n\n            // A place where the output will be stored in case it needs to be dropped.\n            let mut output = None;\n\n            unsafe {\n                // Optimistically assume the `JoinHandle` is being dropped just after creating\n                // the task. This is a common case, as often users don't wait on the task\n                if (*header).state == SCHEDULED | HANDLE {\n                    (*header).state = SCHEDULED;\n                    return;\n                }\n\n                let state = (*header).state;\n                let refs = (*header).references.load(Ordering::Relaxed);\n\n                // If the task has been completed but not yet closed, that means its output\n                // must be dropped.\n                if state & COMPLETED != 0 && state & CLOSED == 0 {\n                    // Mark the task as closed in order to grab its output.\n                    (*header).state |= CLOSED;\n                    // Read the output.\n                    output = Some((((*header).vtable.get_output)(ptr) as *mut R).read());\n\n                    (*header).state &= !HANDLE;\n\n                    // If this is the last reference to the task, we need to destroy it.\n                    if refs == 0 {\n                        ((*header).vtable.destroy)(ptr)\n                    }\n                } else {\n                    // If this is the last reference to the task, and it's not closed, then\n                    // close it and schedule one more time so that its future gets dropped by\n                    // the executor.\n                    let new = if (refs == 0) & (state & CLOSED == 0) {\n                        SCHEDULED | CLOSED\n                    } else {\n                        state & !HANDLE\n                    };\n\n                    (*header).state = new;\n                    // If this is the last reference to the task, we need to either\n                    // schedule dropping its future or destroy it.\n                    if refs == 0 {\n                        if state & CLOSED == 0 {\n                            let refs = (*header).references.fetch_add(1, Ordering::Relaxed);\n                            assert_ne!(refs, i16::max_value());\n                            ((*header).vtable.schedule)(ptr);\n                        } else {\n                            ((*header).vtable.destroy)(ptr);\n                        }\n                    }\n                }\n            }\n\n            drop(output);\n        });\n    }\n}"
}