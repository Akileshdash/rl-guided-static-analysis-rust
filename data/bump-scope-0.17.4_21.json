{
    "level": "Warning",
    "analyzer": "UnsafeDestructor",
    "op_type": null,
    "description": "unsafe block detected in drop",
    "file": "bump-scope-0.17.4/src/owned_slice/drain.rs",
    "start_line": 198,
    "start_col": 1,
    "end_line": 198,
    "end_col": 30,
    "code_snippet": "impl<T> Drop for Drain<'_, T> {\n    fn drop(&mut self) {\n        /// Moves back the un-`Drain`ed elements to restore the original slice.\n        struct DropGuard<'r, 'a, T>(&'r mut Drain<'a, T>);\n\n        impl<T> Drop for DropGuard<'_, '_, T> {\n            fn drop(&mut self) {\n                if self.0.tail_len > 0 {\n                    unsafe {\n                        // memmove back untouched tail, update to new length\n                        let slice_ptr = non_null::as_non_null_ptr(*self.0.slice).as_ptr();\n\n                        let start = self.0.slice.len();\n                        let tail = self.0.tail_start;\n\n                        if tail != start {\n                            let src = slice_ptr.add(tail);\n                            let dst = slice_ptr.add(start);\n                            ptr::copy(src, dst, self.0.tail_len);\n                        }\n\n                        non_null::set_len(self.0.slice, start + self.0.tail_len);\n                    }\n                }\n            }\n        }\n\n        let iter = mem::take(&mut self.iter);\n\n        if T::IS_ZST {\n            // ZSTs have no identity, so we don't need to move them around, we only need to drop the correct amount.\n            // this can be achieved by manipulating the slice length instead of moving values out from `iter`.\n            unsafe {\n                let old_len = self.slice.len();\n                non_null::set_len(self.slice, old_len + iter.len() + self.tail_len);\n                non_null::truncate(self.slice, old_len + self.tail_len);\n            }\n\n            return;\n        }\n\n        // Ensure elements are moved back into their appropriate places, even when dropping `iter` panics.\n        let _guard = DropGuard(self);\n\n        // Drops the remaining drained elements.\n        drop(iter);\n    }\n}"
}