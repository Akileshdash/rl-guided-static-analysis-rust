{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `bindgen_runtime::js_values::arraybuffer::Uint8ArraySlice::<'env>::from_external`",
    "file": "napi-3.1.5/src/bindgen_runtime/js_values/arraybuffer.rs",
    "start_line": 986,
    "start_col": 7,
    "end_line": 1068,
    "end_col": 8,
    "code_snippet": "pub unsafe fn from_external<T: 'env, F: FnOnce(Env, T)>(\n        env: &Env,\n        data: *mut u8,\n        len: usize,\n        finalize_hint: T,\n        finalize_callback: F,\n      ) -> Result<Self> {\n        if data.is_null() || data as *const u8 == crate::EMPTY_VEC.as_ptr() {\n          return Err(Error::new(\n            Status::InvalidArg,\n            \"Borrowed data should not be null\".to_owned(),\n          ));\n        }\n        #[cfg(all(debug_assertions, not(windows)))]\n        {\n          let is_existed = super::BUFFER_DATA.with(|buffer_data| {\n            let buffer = buffer_data.lock().expect(\"Unlock buffer data failed\");\n            buffer.contains(&data)\n          });\n          if is_existed {\n            panic!(\"Share the same data between different buffers is not allowed, see: https://github.com/nodejs/node/issues/32463#issuecomment-631974747\");\n          }\n        }\n        let hint_ptr = Box::into_raw(Box::new((finalize_hint, finalize_callback)));\n        let mut arraybuffer_value = ptr::null_mut();\n        let mut status = unsafe {\n          sys::napi_create_external_arraybuffer(\n            env.0,\n            data.cast(),\n            len,\n            Some(crate::env::raw_finalize_with_custom_callback::<T, F>),\n            hint_ptr.cast(),\n            &mut arraybuffer_value,\n          )\n        };\n        status = if status == sys::Status::napi_no_external_buffers_allowed {\n          let (hint, finalize) = *Box::from_raw(hint_ptr);\n          let mut underlying_data = ptr::null_mut();\n          let status = unsafe {\n            sys::napi_create_arraybuffer(\n              env.0,\n              len,\n              &mut underlying_data,\n              &mut arraybuffer_value,\n            )\n          };\n          let underlying_slice: &mut [u8] =\n            unsafe { std::slice::from_raw_parts_mut(underlying_data.cast(), len) };\n          underlying_slice.copy_from_slice(unsafe { std::slice::from_raw_parts(data, len) });\n          finalize(*env, hint);\n          status\n        } else {\n          status\n        };\n        check_status!(status, \"Failed to create arraybuffer from data\")?;\n\n        let mut napi_val = ptr::null_mut();\n        check_status!(\n          unsafe {\n            sys::napi_create_typedarray(\n              env.0,\n              $typed_array_type as i32,\n              len,\n              arraybuffer_value,\n              0,\n              &mut napi_val,\n            )\n          },\n          \"Create TypedArray failed\"\n        )?;\n\n        Ok(Self {\n          inner: if len == 0 {\n            NonNull::dangling()\n          } else {\n            unsafe { NonNull::new_unchecked(data.cast()) }\n          },\n          length: len,\n          raw_value: napi_val,\n          env: env.0,\n          _marker: PhantomData,\n        })\n      }"
}