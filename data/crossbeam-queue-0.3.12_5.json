{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `array_queue::ArrayQueue::<T>::push_or_else`",
    "file": "crossbeam-queue-0.3.12/src/array_queue.rs",
    "start_line": 129,
    "start_col": 5,
    "end_line": 189,
    "end_col": 6,
    "code_snippet": "fn push_or_else<F>(&self, mut value: T, f: F) -> Result<(), T>\n    where\n        F: Fn(T, usize, usize, &Slot<T>) -> Result<T, T>,\n    {\n        let backoff = Backoff::new();\n        let mut tail = self.tail.load(Ordering::Relaxed);\n\n        loop {\n            // Deconstruct the tail.\n            let index = tail & (self.one_lap - 1);\n            let lap = tail & !(self.one_lap - 1);\n\n            let new_tail = if index + 1 < self.cap {\n                // Same lap, incremented index.\n                // Set to `{ lap: lap, index: index + 1 }`.\n                tail + 1\n            } else {\n                // One lap forward, index wraps around to zero.\n                // Set to `{ lap: lap.wrapping_add(1), index: 0 }`.\n                lap.wrapping_add(self.one_lap)\n            };\n\n            // Inspect the corresponding slot.\n            debug_assert!(index < self.buffer.len());\n            let slot = unsafe { self.buffer.get_unchecked(index) };\n            let stamp = slot.stamp.load(Ordering::Acquire);\n\n            // If the tail and the stamp match, we may attempt to push.\n            if tail == stamp {\n                // Try moving the tail.\n                match self.tail.compare_exchange_weak(\n                    tail,\n                    new_tail,\n                    Ordering::SeqCst,\n                    Ordering::Relaxed,\n                ) {\n                    Ok(_) => {\n                        // Write the value into the slot and update the stamp.\n                        unsafe {\n                            slot.value.get().write(MaybeUninit::new(value));\n                        }\n                        slot.stamp.store(tail + 1, Ordering::Release);\n                        return Ok(());\n                    }\n                    Err(t) => {\n                        tail = t;\n                        backoff.spin();\n                    }\n                }\n            } else if stamp.wrapping_add(self.one_lap) == tail + 1 {\n                atomic::fence(Ordering::SeqCst);\n                value = f(value, tail, new_tail, slot)?;\n                backoff.spin();\n                tail = self.tail.load(Ordering::Relaxed);\n            } else {\n                // Snooze because we need to wait for the stamp to get updated.\n                backoff.snooze();\n                tail = self.tail.load(Ordering::Relaxed);\n            }\n        }\n    }"
}