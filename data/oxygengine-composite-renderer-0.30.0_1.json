{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `system::renderer::composite_renderer_system`",
    "file": "oxygengine-composite-renderer-0.30.0/src/system/renderer.rs",
    "start_line": 39,
    "start_col": 1,
    "end_line": 228,
    "end_col": 2,
    "code_snippet": "pub fn composite_renderer_system<CR>(universe: &mut Universe)\nwhere\n    CR: CompositeRenderer + 'static,\n{\n    let (world, mut renderer, lifecycle, assets, cache, ..) =\n        universe.query_resources::<CompositeRendererSystemResources<CR>>();\n\n    renderer.update_cache(&assets);\n    renderer.update_state();\n    let (width, height) = {\n        let r = renderer.view_size();\n        (r.x, r.y)\n    };\n    let mut stats = Stats {\n        view_size: renderer.view_size(),\n        images_count: renderer.images_count(),\n        fontfaces_count: renderer.fontfaces_count(),\n        surfaces_count: renderer.surfaces_count(),\n        ..Default::default()\n    };\n\n    if let Some(color) = renderer.state().clear_color {\n        let result = renderer.execute(vec![Command::Draw(Renderable::FullscreenRectangle(color))]);\n        if let Ok((render_ops, renderables)) = result {\n            stats.render_ops += render_ops;\n            stats.renderables += renderables;\n        }\n    }\n\n    let unsafe_scope = UnsafeScope;\n    let mut sorted_cameras = world\n        .query::<(\n            &CompositeCamera,\n            &CompositeTransform,\n            Option<&CompositeVisibility>,\n            Option<&CompositeRenderAlpha>,\n            Option<&CompositeRenderLayer>,\n            Option<&CompositeRenderDepth>,\n        )>()\n        .iter()\n        .filter_map(\n            |(_, (camera, transform, visibility, alpha, layer, depth))| {\n                let visible = visibility.map(|v| v.0).unwrap_or(true);\n                let alpha = alpha.map(|v| v.0);\n                let alpha_visible = alpha.map(|v| v > 0.0).unwrap_or(true);\n                if visible && alpha_visible {\n                    let layer = layer.map(|v| v.0).unwrap_or(0);\n                    let depth = depth.map(|v| v.0).unwrap_or(0.0);\n                    unsafe {\n                        Some((\n                            layer,\n                            depth,\n                            alpha,\n                            UnsafeRef::upgrade(&unsafe_scope, camera),\n                            UnsafeRef::upgrade(&unsafe_scope, transform),\n                        ))\n                    }\n                } else {\n                    None\n                }\n            },\n        )\n        .collect::<Vec<_>>();\n    sorted_cameras.sort_by(|a, b| {\n        a.0.partial_cmp(&b.0)\n            .unwrap()\n            .then_with(|| a.1.partial_cmp(&b.1).unwrap())\n    });\n\n    for (_, _, camera_alpha, camera, camera_transform) in sorted_cameras {\n        let unsafe_scope = UnsafeScope;\n        let mut sorted = world\n            .query::<(\n                &CompositeRenderable,\n                Option<&Tag>,\n                Option<&CompositeVisibility>,\n                Option<&CompositeRenderAlpha>,\n                Option<&CompositeRenderLayer>,\n                Option<&CompositeRenderDepth>,\n                Option<&CompositeCameraAlignment>,\n                Option<&CompositeEffect>,\n                Option<&CompositeRenderableStroke>,\n            )>()\n            .with::<&CompositeTransform>()\n            .iter()\n            .filter(|(_, (_, tag, ..))| unsafe {\n                camera.read().tags.is_empty()\n                    || tag\n                        .map(|tag| camera.read().tags.contains(&tag.0))\n                        .unwrap_or(false)\n            })\n            .filter_map(\n                |(\n                    entity,\n                    (renderable, _, visibility, alpha, layer, depth, alignment, effect, stroke),\n                )| {\n                    let visible = visibility.map(|v| v.0).unwrap_or(true);\n                    let alpha_visible = alpha.map(|v| v.0 > 0.0).unwrap_or(true);\n                    if visible && alpha_visible {\n                        let layer = layer.map(|v| v.0).unwrap_or(0);\n                        let depth = depth.map(|v| v.0).unwrap_or(0.0);\n                        unsafe {\n                            Some((\n                                layer,\n                                depth,\n                                cache.matrix(entity).unwrap_or_default(),\n                                UnsafeRef::upgrade(&unsafe_scope, renderable),\n                                alignment\n                                    .map(|alignment| UnsafeRef::upgrade(&unsafe_scope, alignment)),\n                                effect.map(|effect| UnsafeRef::upgrade(&unsafe_scope, effect)),\n                                alpha.map(|alpha| UnsafeRef::upgrade(&unsafe_scope, alpha)),\n                                stroke.map(|stroke| UnsafeRef::upgrade(&unsafe_scope, stroke)),\n                            ))\n                        }\n                    } else {\n                        None\n                    }\n                },\n            )\n            .collect::<Vec<_>>();\n        sorted.sort_by(|a, b| {\n            a.0.partial_cmp(&b.0)\n                .unwrap()\n                .then_with(|| a.1.partial_cmp(&b.1).unwrap())\n        });\n\n        let camera_matrix = unsafe {\n            camera\n                .read()\n                .view_matrix(camera_transform.read(), [width, height].into())\n        };\n        let commands = std::iter::once(Command::Store)\n            .chain(std::iter::once({\n                let [a, b, c, d, e, f] = camera_matrix.0;\n                Command::Transform(a, b, c, d, e, f)\n            }))\n            .chain(std::iter::once(\n                camera_alpha.map(Command::Alpha).unwrap_or(Command::None),\n            ))\n            .chain(sorted.iter().flat_map(\n                |(_, _, matrix, renderable, alignment, effect, alpha, stroke)| {\n                    let [a, b, c, d, e, f] = matrix.0;\n                    vec![\n                        Command::Store,\n                        alignment\n                            .as_ref()\n                            .map(|alignment| unsafe {\n                                let alignment = alignment.read();\n                                let p = Vec2::new(alignment.0.x * width, alignment.0.y * height);\n                                let [a, b, c, d, e, f] =\n                                    ((!camera_matrix).unwrap() * Mat2d::translation(p)).0;\n                                Command::Transform(a, b, c, d, e, f)\n                            })\n                            .unwrap_or(Command::None),\n                        Command::Transform(a, b, c, d, e, f),\n                        effect\n                            .as_ref()\n                            .map(|effect| unsafe { Command::Effect(effect.read().0) })\n                            .unwrap_or(Command::None),\n                        alpha\n                            .as_ref()\n                            .map(|alpha| unsafe { Command::Alpha(alpha.read().0) })\n                            .unwrap_or(Command::None),\n                        stroke\n                            .as_ref()\n                            .map(|stroke| unsafe {\n                                Command::Stroke(stroke.read().0, renderable.read().0.clone())\n                            })\n                            .unwrap_or_else(|| unsafe {\n                                Command::Draw(renderable.read().0.clone())\n                            }),\n                        Command::Restore,\n                    ]\n                },\n            ))\n            .chain(std::iter::once(Command::Restore));\n\n        if let Ok((render_ops, renderables)) = renderer.execute(commands) {\n            stats.render_ops += render_ops;\n            stats.renderables += renderables;\n        }\n    }\n    stats.delta_time = lifecycle.delta_time_seconds();\n    stats.fps = if stats.delta_time > 0.0 {\n        1.0 / stats.delta_time\n    } else {\n        0.0\n    };\n    renderer.state_mut().set_stats(stats);\n}"
}