{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<future::shared::Shared<Fut> as futures_core::Future>::poll`",
    "file": "futures-util-preview-0.3.0-alpha.19/src/future/shared.rs",
    "start_line": 193,
    "start_col": 5,
    "end_line": 290,
    "end_col": 6,
    "code_snippet": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n        let this = &mut *self;\n\n        this.set_waker(cx);\n\n        let inner = if let Some(inner) = this.inner.as_ref() {\n            inner\n        } else {\n            panic!(\"Shared future polled again after completion\");\n        };\n\n        match inner.notifier.state.compare_and_swap(IDLE, POLLING, SeqCst) {\n            IDLE => {\n                // Lock acquired, fall through\n            }\n            POLLING | REPOLL => {\n                // Another task is currently polling, at this point we just want\n                // to ensure that the waker for this task is registered\n\n                return Poll::Pending;\n            }\n            COMPLETE => {\n                // Safety: We're in the COMPLETE state\n                return unsafe { Poll::Ready(this.take_or_clone_output()) };\n            }\n            POISONED => panic!(\"inner future panicked during poll\"),\n            _ => unreachable!(),\n        }\n\n        let waker = waker_ref(&inner.notifier);\n        let mut cx = Context::from_waker(&waker);\n\n        struct Reset<'a>(&'a AtomicUsize);\n\n        impl Drop for Reset<'_> {\n            fn drop(&mut self) {\n                use std::thread;\n\n                if thread::panicking() {\n                    self.0.store(POISONED, SeqCst);\n                }\n            }\n        }\n\n        let _reset = Reset(&inner.notifier.state);\n\n        let output = loop {\n            let future = unsafe {\n                match &mut *inner.future_or_output.get() {\n                    FutureOrOutput::Future(fut) => Pin::new_unchecked(fut),\n                    _ => unreachable!(),\n                }\n            };\n\n            let poll = future.poll(&mut cx);\n\n            match poll {\n                Poll::Pending => {\n                    let state = &inner.notifier.state;\n                    match state.compare_and_swap(POLLING, IDLE, SeqCst) {\n                        POLLING => {\n                            // Success\n                            return Poll::Pending;\n                        }\n                        REPOLL => {\n                            // Was woken since: Gotta poll again!\n                            let prev = state.swap(POLLING, SeqCst);\n                            assert_eq!(prev, REPOLL);\n                        }\n                        _ => unreachable!(),\n                    }\n                }\n                Poll::Ready(output) => break output,\n            }\n        };\n\n        unsafe {\n            *inner.future_or_output.get() =\n                FutureOrOutput::Output(output);\n        }\n\n        inner.notifier.state.store(COMPLETE, SeqCst);\n\n        // Wake all tasks and drop the slab\n        let mut wakers_guard = inner.notifier.wakers.lock().unwrap();\n        let wakers = &mut wakers_guard.take().unwrap();\n        for (_key, opt_waker) in wakers {\n            if let Some(waker) = opt_waker.take() {\n                waker.wake();\n            }\n        }\n\n        drop(_reset); // Make borrow checker happy\n        drop(wakers_guard);\n\n        // Safety: We're in the COMPLETE state\n        unsafe { Poll::Ready(this.take_or_clone_output()) }\n    }"
}