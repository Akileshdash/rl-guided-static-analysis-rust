{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<datatypes::_datatypes::tensor_data::TensorData as re_types_core::Loggable>::to_arrow_opt`",
    "file": "re_types-0.24.0/src/datatypes/../datatypes/tensor_data.rs",
    "start_line": 82,
    "start_col": 5,
    "end_line": 240,
    "end_col": 6,
    "code_snippet": "fn to_arrow_opt<'a>(\n        data: impl IntoIterator<Item = Option<impl Into<::std::borrow::Cow<'a, Self>>>>,\n    ) -> SerializationResult<arrow::array::ArrayRef>\n    where\n        Self: Clone + 'a,\n    {\n        #![allow(clippy::wildcard_imports)]\n        #![allow(clippy::manual_is_variant_and)]\n        use ::re_types_core::{arrow_helpers::as_array_ref, Loggable as _, ResultExt as _};\n        use arrow::{array::*, buffer::*, datatypes::*};\n        Ok({\n            let fields = Fields::from(vec![\n                Field::new(\n                    \"shape\",\n                    DataType::List(std::sync::Arc::new(Field::new(\n                        \"item\",\n                        DataType::UInt64,\n                        false,\n                    ))),\n                    false,\n                ),\n                Field::new(\n                    \"names\",\n                    DataType::List(std::sync::Arc::new(Field::new(\n                        \"item\",\n                        DataType::Utf8,\n                        false,\n                    ))),\n                    true,\n                ),\n                Field::new(\n                    \"buffer\",\n                    <crate::datatypes::TensorBuffer>::arrow_datatype(),\n                    true,\n                ),\n            ]);\n            let (somes, data): (Vec<_>, Vec<_>) = data\n                .into_iter()\n                .map(|datum| {\n                    let datum: Option<::std::borrow::Cow<'a, Self>> = datum.map(Into::into);\n                    (datum.is_some(), datum)\n                })\n                .unzip();\n            let validity: Option<arrow::buffer::NullBuffer> = {\n                let any_nones = somes.iter().any(|some| !*some);\n                any_nones.then(|| somes.into())\n            };\n            as_array_ref(StructArray::new(\n                fields,\n                vec![\n                    {\n                        let (somes, shape): (Vec<_>, Vec<_>) = data\n                            .iter()\n                            .map(|datum| {\n                                let datum = datum.as_ref().map(|datum| datum.shape.clone());\n                                (datum.is_some(), datum)\n                            })\n                            .unzip();\n                        let shape_validity: Option<arrow::buffer::NullBuffer> = {\n                            let any_nones = somes.iter().any(|some| !*some);\n                            any_nones.then(|| somes.into())\n                        };\n                        {\n                            let offsets = arrow::buffer::OffsetBuffer::<i32>::from_lengths(\n                                shape\n                                    .iter()\n                                    .map(|opt| opt.as_ref().map_or(0, |datum| datum.len())),\n                            );\n                            let shape_inner_data: ScalarBuffer<_> = shape\n                                .iter()\n                                .flatten()\n                                .map(|b| b as &[_])\n                                .collect::<Vec<_>>()\n                                .concat()\n                                .into();\n                            let shape_inner_validity: Option<arrow::buffer::NullBuffer> = None;\n                            as_array_ref(ListArray::try_new(\n                                std::sync::Arc::new(Field::new(\"item\", DataType::UInt64, false)),\n                                offsets,\n                                as_array_ref(PrimitiveArray::<UInt64Type>::new(\n                                    shape_inner_data,\n                                    shape_inner_validity,\n                                )),\n                                shape_validity,\n                            )?)\n                        }\n                    },\n                    {\n                        let (somes, names): (Vec<_>, Vec<_>) = data\n                            .iter()\n                            .map(|datum| {\n                                let datum =\n                                    datum.as_ref().map(|datum| datum.names.clone()).flatten();\n                                (datum.is_some(), datum)\n                            })\n                            .unzip();\n                        let names_validity: Option<arrow::buffer::NullBuffer> = {\n                            let any_nones = somes.iter().any(|some| !*some);\n                            any_nones.then(|| somes.into())\n                        };\n                        {\n                            let offsets = arrow::buffer::OffsetBuffer::<i32>::from_lengths(\n                                names\n                                    .iter()\n                                    .map(|opt| opt.as_ref().map_or(0, |datum| datum.len())),\n                            );\n                            let names_inner_data: Vec<_> =\n                                names.into_iter().flatten().flatten().collect();\n                            let names_inner_validity: Option<arrow::buffer::NullBuffer> = None;\n                            as_array_ref(ListArray::try_new(\n                                std::sync::Arc::new(Field::new(\"item\", DataType::Utf8, false)),\n                                offsets,\n                                {\n                                    let offsets = arrow::buffer::OffsetBuffer::<i32>::from_lengths(\n                                        names_inner_data.iter().map(|datum| datum.len()),\n                                    );\n                                    #[allow(clippy::unwrap_used)]\n                                    let capacity = offsets.last().copied().unwrap() as usize;\n                                    let mut buffer_builder =\n                                        arrow::array::builder::BufferBuilder::<u8>::new(capacity);\n                                    for data in &names_inner_data {\n                                        buffer_builder.append_slice(data.as_bytes());\n                                    }\n                                    let inner_data: arrow::buffer::Buffer = buffer_builder.finish();\n                                    #[allow(unsafe_code, clippy::undocumented_unsafe_blocks)]\n                                    as_array_ref(unsafe {\n                                        StringArray::new_unchecked(\n                                            offsets,\n                                            inner_data,\n                                            names_inner_validity,\n                                        )\n                                    })\n                                },\n                                names_validity,\n                            )?)\n                        }\n                    },\n                    {\n                        let (somes, buffer): (Vec<_>, Vec<_>) = data\n                            .iter()\n                            .map(|datum| {\n                                let datum = datum.as_ref().map(|datum| datum.buffer.clone());\n                                (datum.is_some(), datum)\n                            })\n                            .unzip();\n                        let buffer_validity: Option<arrow::buffer::NullBuffer> = {\n                            let any_nones = somes.iter().any(|some| !*some);\n                            any_nones.then(|| somes.into())\n                        };\n                        {\n                            _ = buffer_validity;\n                            crate::datatypes::TensorBuffer::to_arrow_opt(buffer)?\n                        }\n                    },\n                ],\n                validity,\n            ))\n        })\n    }"
}