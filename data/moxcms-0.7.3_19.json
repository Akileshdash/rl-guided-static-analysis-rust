{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `conversions::avx::rgb_xyz::TransformShaperRgbAvx::<T, SRC_LAYOUT, DST_LAYOUT, LINEAR_CAP, GAMMA_LUT, BIT_DEPTH>::transform_impl`",
    "file": "moxcms-0.7.3/src/conversions/avx/rgb_xyz.rs",
    "start_line": 62,
    "start_col": 5,
    "end_line": 294,
    "end_col": 6,
    "code_snippet": "unsafe fn transform_impl<const FMA: bool>(\n        &self,\n        src: &[T],\n        dst: &mut [T],\n    ) -> Result<(), CmsError> {\n        let src_cn = Layout::from(SRC_LAYOUT);\n        let dst_cn = Layout::from(DST_LAYOUT);\n        let src_channels = src_cn.channels();\n        let dst_channels = dst_cn.channels();\n\n        let mut temporary0 = AvxAlignedU16([0; 16]);\n\n        if src.len() / src_channels != dst.len() / dst_channels {\n            return Err(CmsError::LaneSizeMismatch);\n        }\n        if src.len() % src_channels != 0 {\n            return Err(CmsError::LaneMultipleOfChannels);\n        }\n        if dst.len() % dst_channels != 0 {\n            return Err(CmsError::LaneMultipleOfChannels);\n        }\n\n        let t = self.profile.adaptation_matrix.transpose();\n\n        let scale = (GAMMA_LUT - 1) as f32;\n        let max_colors: T = ((1 << BIT_DEPTH) - 1).as_();\n\n        unsafe {\n            let m0 = _mm256_setr_ps(\n                t.v[0][0], t.v[0][1], t.v[0][2], 0., t.v[0][0], t.v[0][1], t.v[0][2], 0.,\n            );\n            let m1 = _mm256_setr_ps(\n                t.v[1][0], t.v[1][1], t.v[1][2], 0., t.v[1][0], t.v[1][1], t.v[1][2], 0.,\n            );\n            let m2 = _mm256_setr_ps(\n                t.v[2][0], t.v[2][1], t.v[2][2], 0., t.v[2][0], t.v[2][1], t.v[2][2], 0.,\n            );\n\n            let zeros = _mm_setzero_ps();\n\n            let v_scale = _mm256_set1_ps(scale);\n\n            let mut src = src;\n            let mut dst = dst;\n\n            let mut src_iter = src.chunks_exact(src_channels * 2);\n            let dst_iter = dst.chunks_exact_mut(dst_channels * 2);\n\n            let (mut r0, mut g0, mut b0, mut a0);\n            let (mut r1, mut g1, mut b1, mut a1);\n\n            if let Some(src) = src_iter.next() {\n                r0 = _mm_broadcast_ss(&self.profile.r_linear[src[src_cn.r_i()]._as_usize()]);\n                g0 = _mm_broadcast_ss(&self.profile.g_linear[src[src_cn.g_i()]._as_usize()]);\n                b0 = _mm_broadcast_ss(&self.profile.b_linear[src[src_cn.b_i()]._as_usize()]);\n                r1 = _mm_broadcast_ss(\n                    &self.profile.r_linear[src[src_cn.r_i() + src_channels]._as_usize()],\n                );\n                g1 = _mm_broadcast_ss(\n                    &self.profile.g_linear[src[src_cn.g_i() + src_channels]._as_usize()],\n                );\n                b1 = _mm_broadcast_ss(\n                    &self.profile.b_linear[src[src_cn.b_i() + src_channels]._as_usize()],\n                );\n                a0 = if src_channels == 4 {\n                    src[src_cn.a_i()]\n                } else {\n                    max_colors\n                };\n                a1 = if src_channels == 4 {\n                    src[src_cn.a_i() + src_channels]\n                } else {\n                    max_colors\n                };\n            } else {\n                r0 = _mm_setzero_ps();\n                g0 = _mm_setzero_ps();\n                b0 = _mm_setzero_ps();\n                a0 = max_colors;\n                r1 = _mm_setzero_ps();\n                g1 = _mm_setzero_ps();\n                b1 = _mm_setzero_ps();\n                a1 = max_colors;\n            }\n\n            for (src, dst) in src_iter.zip(dst_iter) {\n                let r = _mm256_insertf128_ps::<1>(_mm256_castps128_ps256(r0), r1);\n                let g = _mm256_insertf128_ps::<1>(_mm256_castps128_ps256(g0), g1);\n                let b = _mm256_insertf128_ps::<1>(_mm256_castps128_ps256(b0), b1);\n\n                let mut v = if FMA {\n                    let v0 = _mm256_mul_ps(r, m0);\n                    let v1 = _mm256_fmadd_ps(g, m1, v0);\n                    _mm256_fmadd_ps(b, m2, v1)\n                } else {\n                    let v0 = _mm256_mul_ps(r, m0);\n                    let v1 = _mm256_mul_ps(g, m1);\n                    let v2 = _mm256_mul_ps(b, m2);\n\n                    _mm256_add_ps(_mm256_add_ps(v0, v1), v2)\n                };\n\n                v = _mm256_max_ps(v, _mm256_setzero_ps());\n                v = _mm256_mul_ps(v, v_scale);\n                v = _mm256_min_ps(v, v_scale);\n\n                let zx = _mm256_cvtps_epi32(v);\n                _mm256_store_si256(temporary0.0.as_mut_ptr() as *mut _, zx);\n\n                r0 = _mm_broadcast_ss(&self.profile.r_linear[src[src_cn.r_i()]._as_usize()]);\n                g0 = _mm_broadcast_ss(&self.profile.g_linear[src[src_cn.g_i()]._as_usize()]);\n                b0 = _mm_broadcast_ss(&self.profile.b_linear[src[src_cn.b_i()]._as_usize()]);\n                r1 = _mm_broadcast_ss(\n                    &self.profile.r_linear[src[src_cn.r_i() + src_channels]._as_usize()],\n                );\n                g1 = _mm_broadcast_ss(\n                    &self.profile.g_linear[src[src_cn.g_i() + src_channels]._as_usize()],\n                );\n                b1 = _mm_broadcast_ss(\n                    &self.profile.b_linear[src[src_cn.b_i() + src_channels]._as_usize()],\n                );\n\n                dst[dst_cn.r_i()] = self.profile.r_gamma[temporary0.0[0] as usize];\n                dst[dst_cn.g_i()] = self.profile.g_gamma[temporary0.0[2] as usize];\n                dst[dst_cn.b_i()] = self.profile.b_gamma[temporary0.0[4] as usize];\n                if dst_channels == 4 {\n                    dst[dst_cn.a_i()] = a0;\n                }\n\n                dst[dst_cn.r_i() + dst_channels] = self.profile.r_gamma[temporary0.0[8] as usize];\n                dst[dst_cn.g_i() + dst_channels] = self.profile.g_gamma[temporary0.0[10] as usize];\n                dst[dst_cn.b_i() + dst_channels] = self.profile.b_gamma[temporary0.0[12] as usize];\n                if dst_channels == 4 {\n                    dst[dst_cn.a_i() + dst_channels] = a1;\n                }\n\n                a0 = if src_channels == 4 {\n                    src[src_cn.a_i()]\n                } else {\n                    max_colors\n                };\n                a1 = if src_channels == 4 {\n                    src[src_cn.a_i() + src_channels]\n                } else {\n                    max_colors\n                };\n            }\n\n            if let Some(dst) = dst.chunks_exact_mut(dst_channels * 2).last() {\n                let r = _mm256_insertf128_ps::<1>(_mm256_castps128_ps256(r0), r1);\n                let g = _mm256_insertf128_ps::<1>(_mm256_castps128_ps256(g0), g1);\n                let b = _mm256_insertf128_ps::<1>(_mm256_castps128_ps256(b0), b1);\n\n                let mut v = if FMA {\n                    let v0 = _mm256_mul_ps(r, m0);\n                    let v1 = _mm256_fmadd_ps(g, m1, v0);\n                    _mm256_fmadd_ps(b, m2, v1)\n                } else {\n                    let v0 = _mm256_mul_ps(r, m0);\n                    let v1 = _mm256_mul_ps(g, m1);\n                    let v2 = _mm256_mul_ps(b, m2);\n\n                    _mm256_add_ps(_mm256_add_ps(v0, v1), v2)\n                };\n\n                v = _mm256_max_ps(v, _mm256_setzero_ps());\n                v = _mm256_mul_ps(v, v_scale);\n                v = _mm256_min_ps(v, v_scale);\n\n                let zx = _mm256_cvtps_epi32(v);\n                _mm256_store_si256(temporary0.0.as_mut_ptr() as *mut _, zx);\n\n                dst[dst_cn.r_i()] = self.profile.r_gamma[temporary0.0[0] as usize];\n                dst[dst_cn.g_i()] = self.profile.g_gamma[temporary0.0[2] as usize];\n                dst[dst_cn.b_i()] = self.profile.b_gamma[temporary0.0[4] as usize];\n                if dst_channels == 4 {\n                    dst[dst_cn.a_i()] = a0;\n                }\n\n                dst[dst_cn.r_i() + dst_channels] = self.profile.r_gamma[temporary0.0[8] as usize];\n                dst[dst_cn.g_i() + dst_channels] = self.profile.g_gamma[temporary0.0[10] as usize];\n                dst[dst_cn.b_i() + dst_channels] = self.profile.b_gamma[temporary0.0[12] as usize];\n                if dst_channels == 4 {\n                    dst[dst_cn.a_i() + dst_channels] = a1;\n                }\n            }\n\n            src = src.chunks_exact(src_channels * 2).remainder();\n            dst = dst.chunks_exact_mut(dst_channels * 2).into_remainder();\n\n            for (src, dst) in src\n                .chunks_exact(src_channels)\n                .zip(dst.chunks_exact_mut(dst_channels))\n            {\n                let r = _mm_broadcast_ss(&self.profile.r_linear[src[src_cn.r_i()]._as_usize()]);\n                let g = _mm_broadcast_ss(&self.profile.g_linear[src[src_cn.g_i()]._as_usize()]);\n                let b = _mm_broadcast_ss(&self.profile.b_linear[src[src_cn.b_i()]._as_usize()]);\n                let a = if src_channels == 4 {\n                    src[src_cn.a_i()]\n                } else {\n                    max_colors\n                };\n\n                let mut v = if FMA {\n                    let v0 = _mm_mul_ps(r, _mm256_castps256_ps128(m0));\n                    let v1 = _mm_fmadd_ps(g, _mm256_castps256_ps128(m1), v0);\n                    _mm_fmadd_ps(b, _mm256_castps256_ps128(m2), v1)\n                } else {\n                    let v0 = _mm_mul_ps(r, _mm256_castps256_ps128(m0));\n                    let v1 = _mm_mul_ps(g, _mm256_castps256_ps128(m1));\n                    let v2 = _mm_mul_ps(b, _mm256_castps256_ps128(m2));\n\n                    _mm_add_ps(_mm_add_ps(v0, v1), v2)\n                };\n\n                v = _mm_max_ps(v, zeros);\n                v = _mm_mul_ps(v, _mm256_castps256_ps128(v_scale));\n                v = _mm_min_ps(v, _mm256_castps256_ps128(v_scale));\n\n                let zx = _mm_cvtps_epi32(v);\n                _mm_store_si128(temporary0.0.as_mut_ptr() as *mut _, zx);\n\n                dst[dst_cn.r_i()] = self.profile.r_gamma[temporary0.0[0] as usize];\n                dst[dst_cn.g_i()] = self.profile.g_gamma[temporary0.0[2] as usize];\n                dst[dst_cn.b_i()] = self.profile.b_gamma[temporary0.0[4] as usize];\n                if dst_channels == 4 {\n                    dst[dst_cn.a_i()] = a;\n                }\n            }\n        }\n\n        Ok(())\n    }"
}