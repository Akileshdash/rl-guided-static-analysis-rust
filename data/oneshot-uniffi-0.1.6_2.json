{
    "level": "Warning",
    "analyzer": "UnsafeDestructor",
    "op_type": null,
    "description": "unsafe block detected in drop",
    "file": "oneshot-uniffi-0.1.6/src/lib.rs",
    "start_line": 344,
    "start_col": 1,
    "end_line": 344,
    "end_col": 27,
    "code_snippet": "impl<T> Drop for Sender<T> {\n    fn drop(&mut self) {\n        // SAFETY: The receiver only ever frees the channel if we are in the MESSAGE or\n        // DISCONNECTED states. If we are in the MESSAGE state, then we called\n        // mem::forget(self), so we should not be in this function call. If we are in the\n        // DISCONNECTED state, then the receiver either received a MESSAGE so this statement is\n        // unreachable, or was dropped and observed that our side was still alive, and thus didn't\n        // free the channel.\n        let channel = unsafe { self.channel_ptr.as_ref() };\n\n        // Set the channel state to disconnected and read what state the receiver was in\n        // ORDERING: we don't need release ordering here since there are no modifications we\n        // need to make visible to other thread, and the Err(RECEIVING) branch handles\n        // synchronization independent of this cmpxchg\n        //\n        // EMPTY ^ 001 = DISCONNECTED\n        // RECEIVING ^ 001 = UNPARKING\n        // DISCONNECTED ^ 001 = EMPTY (invalid), but this state is never observed\n        match channel.state.fetch_xor(0b001, Relaxed) {\n            // The receiver has not started waiting, nor is it dropped.\n            EMPTY => (),\n            // The receiver is waiting. Wake it up so it can detect that the channel disconnected.\n            RECEIVING => {\n                // See comments in Sender::send\n\n                fence(Acquire);\n\n                let waker = unsafe { channel.take_waker() };\n\n                // We still need release ordering here to make sure our read of the waker happens\n                // before this, and acquire ordering to ensure the unparking of the receiver\n                // happens after this.\n                channel.state.swap(DISCONNECTED, AcqRel);\n\n                // The Acquire ordering above ensures that the write of the DISCONNECTED state\n                // happens-before unparking the receiver.\n                waker.unpark();\n            }\n            // The receiver was already dropped. We are responsible for freeing the channel.\n            DISCONNECTED => {\n                // SAFETY: when the receiver switches the state to DISCONNECTED they have received\n                // the message or will no longer be trying to receive the message, and have\n                // observed that the sender is still alive, meaning that we're responsible for\n                // freeing the channel allocation.\n                unsafe { dealloc(self.channel_ptr) };\n            }\n            _ => unreachable!(),\n        }\n    }\n}"
}