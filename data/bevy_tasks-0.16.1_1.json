{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `single_threaded_task_pool::TaskPool::scope_with_executor`",
    "file": "bevy_tasks-0.16.1/src/single_threaded_task_pool.rs",
    "start_line": 132,
    "start_col": 5,
    "end_line": 187,
    "end_col": 6,
    "code_snippet": "pub fn scope_with_executor<'env, F, T>(\n        &self,\n        _tick_task_pool_executor: bool,\n        _thread_executor: Option<&ThreadExecutor>,\n        f: F,\n    ) -> Vec<T>\n    where\n        F: for<'scope> FnOnce(&'env mut Scope<'scope, 'env, T>),\n        T: Send + 'static,\n    {\n        // SAFETY: This safety comment applies to all references transmuted to 'env.\n        // Any futures spawned with these references need to return before this function completes.\n        // This is guaranteed because we drive all the futures spawned onto the Scope\n        // to completion in this function. However, rust has no way of knowing this so we\n        // transmute the lifetimes to 'env here to appease the compiler as it is unable to validate safety.\n        // Any usages of the references passed into `Scope` must be accessed through\n        // the transmuted reference for the rest of this function.\n\n        let executor = &LocalExecutor::new();\n        // SAFETY: As above, all futures must complete in this function so we can change the lifetime\n        let executor: &'env LocalExecutor<'env> = unsafe { mem::transmute(executor) };\n\n        let results: RefCell<Vec<ScopeResult<T>>> = RefCell::new(Vec::new());\n        // SAFETY: As above, all futures must complete in this function so we can change the lifetime\n        let results: &'env RefCell<Vec<ScopeResult<T>>> = unsafe { mem::transmute(&results) };\n\n        let mut scope = Scope {\n            executor,\n            results,\n            scope: PhantomData,\n            env: PhantomData,\n        };\n\n        // SAFETY: As above, all futures must complete in this function so we can change the lifetime\n        let scope_ref: &'env mut Scope<'_, 'env, T> = unsafe { mem::transmute(&mut scope) };\n\n        f(scope_ref);\n\n        // Loop until all tasks are done\n        while executor.try_tick() {}\n\n        let results = scope.results.borrow();\n        results\n            .iter()\n            .map(|result| {\n                #[cfg(feature = \"std\")]\n                return result.borrow_mut().take().unwrap();\n\n                #[cfg(not(feature = \"std\"))]\n                {\n                    let mut lock = result.lock().unwrap_or_else(PoisonError::into_inner);\n                    lock.take().unwrap()\n                }\n            })\n            .collect()\n    }"
}