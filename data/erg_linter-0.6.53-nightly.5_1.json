{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `lint::Linter::check_recursively`",
    "file": "erg_linter-0.6.53-nightly.5/lint.rs",
    "start_line": 268,
    "start_col": 5,
    "end_line": 406,
    "end_col": 6,
    "code_snippet": "fn check_recursively(&mut self, lint_fn: &impl Fn(&mut Linter, &Expr), expr: &Expr) {\n        match expr {\n            Expr::Literal(_) => {}\n            Expr::Record(record) => {\n                for attr in record.attrs.iter() {\n                    for chunk in attr.body.block.iter() {\n                        lint_fn(self, chunk);\n                    }\n                    if let Signature::Subr(subr) = &attr.sig {\n                        for param in subr.params.defaults.iter() {\n                            lint_fn(self, &param.default_val);\n                        }\n                    }\n                }\n            }\n            Expr::List(list) => match list {\n                List::Normal(lis) => {\n                    for elem in lis.elems.pos_args.iter() {\n                        lint_fn(self, &elem.expr);\n                    }\n                }\n                List::WithLength(lis) => {\n                    lint_fn(self, &lis.elem);\n                    if let Some(len) = &lis.len {\n                        lint_fn(self, len);\n                    }\n                }\n                List::Comprehension(lis) => {\n                    lint_fn(self, &lis.elem);\n                    lint_fn(self, &lis.guard);\n                }\n            },\n            Expr::Tuple(tuple) => match tuple {\n                Tuple::Normal(tup) => {\n                    for elem in tup.elems.pos_args.iter() {\n                        lint_fn(self, &elem.expr);\n                    }\n                }\n            },\n            Expr::Set(set) => match set {\n                Set::Normal(set) => {\n                    for elem in set.elems.pos_args.iter() {\n                        lint_fn(self, &elem.expr);\n                    }\n                }\n                Set::WithLength(set) => {\n                    lint_fn(self, &set.elem);\n                    lint_fn(self, &set.len);\n                }\n            },\n            Expr::Dict(dict) => match dict {\n                Dict::Normal(dic) => {\n                    for kv in dic.kvs.iter() {\n                        lint_fn(self, &kv.key);\n                        lint_fn(self, &kv.value);\n                    }\n                }\n                _ => {\n                    log!(\"Dict comprehension not implemented\");\n                }\n            },\n            Expr::BinOp(binop) => {\n                lint_fn(self, &binop.lhs);\n                lint_fn(self, &binop.rhs);\n            }\n            Expr::UnaryOp(unaryop) => {\n                lint_fn(self, &unaryop.expr);\n            }\n            Expr::Call(call) => {\n                lint_fn(self, &call.obj);\n                for arg in call.args.iter() {\n                    lint_fn(self, arg);\n                }\n            }\n            Expr::Def(def) => {\n                for chunk in def.body.block.iter() {\n                    lint_fn(self, chunk);\n                }\n                if let Signature::Subr(subr) = &def.sig {\n                    for param in subr.params.defaults.iter() {\n                        lint_fn(self, &param.default_val);\n                    }\n                }\n            }\n            Expr::ClassDef(class_def) => {\n                if let Signature::Subr(subr) = &class_def.sig {\n                    for param in subr.params.defaults.iter() {\n                        lint_fn(self, &param.default_val);\n                    }\n                }\n                for methods in class_def.methods_list.iter() {\n                    for method in methods.defs.iter() {\n                        lint_fn(self, method);\n                    }\n                }\n            }\n            Expr::PatchDef(class_def) => {\n                if let Signature::Subr(subr) = &class_def.sig {\n                    for param in subr.params.defaults.iter() {\n                        lint_fn(self, &param.default_val);\n                    }\n                }\n                for method in class_def.methods.iter() {\n                    lint_fn(self, method);\n                }\n            }\n            Expr::ReDef(redef) => {\n                self.check_acc_recursively(lint_fn, &redef.attr);\n                for chunk in redef.block.iter() {\n                    lint_fn(self, chunk);\n                }\n            }\n            Expr::Lambda(lambda) => {\n                for chunk in lambda.body.iter() {\n                    lint_fn(self, chunk);\n                }\n                for param in lambda.params.defaults.iter() {\n                    lint_fn(self, &param.default_val);\n                }\n            }\n            Expr::TypeAsc(tasc) => {\n                lint_fn(self, &tasc.expr);\n            }\n            Expr::Accessor(acc) => {\n                self.check_acc_recursively(lint_fn, acc);\n            }\n            Expr::Compound(exprs) => {\n                for chunk in exprs.iter() {\n                    lint_fn(self, chunk);\n                }\n            }\n            Expr::Dummy(exprs) => {\n                for chunk in exprs.iter() {\n                    lint_fn(self, chunk);\n                }\n            }\n            _ => {}\n        }\n    }"
}