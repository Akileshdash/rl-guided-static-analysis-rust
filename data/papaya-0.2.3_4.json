{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `raw::HashMap::<K, V, S>::get`",
    "file": "papaya-0.2.3/src/raw/mod.rs",
    "start_line": 312,
    "start_col": 5,
    "end_line": 393,
    "end_col": 6,
    "code_snippet": "pub fn get<'g, Q>(&self, key: &Q, guard: &'g impl VerifiedGuard) -> Option<(&'g K, &'g V)>\n    where\n        Q: Equivalent<K> + Hash + ?Sized,\n    {\n        // Load the root table.\n        let mut table = self.root(guard);\n\n        // The table has not been initialized yet.\n        if table.raw.is_null() {\n            return None;\n        }\n\n        let (h1, h2) = self.hash(key);\n\n        loop {\n            // Initialize the probe state.\n            let mut probe = Probe::start(h1, table.mask);\n\n            // Probe until we reach the limit.\n            'probe: while probe.len <= table.limit {\n                // Load the entry metadata first for cheap searches.\n                //\n                // Safety: `probe.i` is always in-bounds for the table length.\n                let meta = unsafe { table.meta(probe.i) }.load(Ordering::Acquire);\n\n                if meta == h2 {\n                    // Load the full entry.\n                    //\n                    // Safety: `probe.i` is always in-bounds for the table length.\n                    let entry = guard\n                        .protect(unsafe { table.entry(probe.i) }, Ordering::Acquire)\n                        .unpack();\n\n                    // The entry was deleted, keep probing.\n                    if entry.ptr.is_null() {\n                        probe.next(table.mask);\n                        continue 'probe;\n                    }\n\n                    // Safety: We performed a protected load of the pointer using a verified guard with\n                    // `Acquire` and ensured that it is non-null, meaning it is valid for reads as long\n                    // as we hold the guard.\n                    let entry_ref = unsafe { &(*entry.ptr) };\n\n                    // Check for a full match.\n                    if key.equivalent(&entry_ref.key) {\n                        // The entry was copied to the new table.\n                        //\n                        // In blocking resize mode we do not need to perform self check as all writes block\n                        // until any resizes are complete, making the root table the source of truth for readers.\n                        if entry.tag() & Entry::COPIED != 0 {\n                            break 'probe;\n                        }\n\n                        // Found the correct entry, return the key and value.\n                        return Some((&entry_ref.key, &entry_ref.value));\n                    }\n                }\n\n                // The key is not in the table.\n                //\n                // It also cannot be in the next table because we have not went over the probe limit.\n                if meta == meta::EMPTY {\n                    return None;\n                }\n\n                probe.next(table.mask);\n            }\n\n            // In incremental resize mode, we have to check the next table if we found\n            // a copied entry or went over the probe limit.\n            if self.is_incremental() {\n                if let Some(next) = table.next_table() {\n                    table = next;\n                    continue;\n                }\n            }\n\n            // Otherwise, the key is not in the table.\n            return None;\n        }\n    }"
}