{
    "level": "Warning",
    "analyzer": "UnsafeDataflow",
    "op_type": "WriteFlow",
    "description": "Potential unsafe dataflow issue in `rust_tables::<impl LuaRead<L> for [T; N]>::lua_read_at_position`",
    "file": "tlua-6.0.1/src/rust_tables.rs",
    "start_line": 359,
    "start_col": 5,
    "end_line": 420,
    "end_col": 6,
    "code_snippet": "fn lua_read_at_position(lua: L, index: NonZeroI32) -> ReadResult<Self, L> {\n        let table = LuaTable::lua_read_at_position(lua, index)?;\n        let mut res = std::mem::MaybeUninit::uninit();\n        let ptr = &mut res as *mut _ as *mut [T; N] as *mut T;\n        let mut was_assigned = [false; N];\n        let mut err = None;\n\n        for maybe_kv in table.iter::<i32, T>() {\n            match maybe_kv {\n                Ok((key, value)) if 1 <= key && key as usize <= N => {\n                    let i = (key - 1) as usize;\n                    unsafe { std::ptr::write(ptr.add(i), value) }\n                    was_assigned[i] = true;\n                }\n                Err(e) => {\n                    err = Some(Error::Subtype(e));\n                    break;\n                }\n                Ok((index, _)) => {\n                    err = Some(Error::WrongIndex(index));\n                    break;\n                }\n            }\n        }\n\n        if err.is_none() {\n            err = was_assigned\n                .iter()\n                .zip(1..)\n                .find(|(&was_assigned, _)| !was_assigned)\n                .map(|(_, i)| Error::MissingIndex(i));\n        }\n\n        let err = crate::unwrap_or! { err,\n            return Ok(unsafe { res.assume_init() });\n        };\n\n        for i in IntoIterator::into_iter(was_assigned)\n            .enumerate()\n            .flat_map(|(i, was_assigned)| was_assigned.then_some(i))\n        {\n            unsafe { std::ptr::drop_in_place(ptr.add(i)) }\n        }\n\n        let when = \"converting Lua table to array\";\n        let e = match err {\n            Error::Subtype(err) => err.when(when).expected_type::<Self>(),\n            Error::WrongIndex(index) => WrongType::info(when)\n                .expected(format!(\"indexes in range 1..={}\", N))\n                .actual(format!(\"value with index {}\", index)),\n            Error::MissingIndex(index) => WrongType::info(when)\n                .expected(format!(\"indexes in range 1..={}\", N))\n                .actual(format!(\"Lua table with missing index {}\", index)),\n        };\n        return Err((table.into_inner(), e));\n\n        enum Error {\n            Subtype(WrongType),\n            WrongIndex(i32),\n            MissingIndex(i32),\n        }\n    }"
}