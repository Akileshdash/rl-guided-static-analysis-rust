{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `raw::HashMap::<K, V, S>::remove_if`",
    "file": "papaya-0.2.3/src/raw/mod.rs",
    "start_line": 677,
    "start_col": 5,
    "end_line": 815,
    "end_col": 6,
    "code_snippet": "pub fn remove_if<'g, Q, F>(\n        &self,\n        key: &Q,\n        mut should_remove: F,\n        guard: &'g impl VerifiedGuard,\n    ) -> Result<Option<(&'g K, &'g V)>, (&'g K, &'g V)>\n    where\n        Q: Equivalent<K> + Hash + ?Sized,\n        F: FnMut(&K, &V) -> bool,\n    {\n        // Load the root table.\n        let mut table = self.root(guard);\n\n        // The table has not been initialized yet.\n        if table.raw.is_null() {\n            return Ok(None);\n        }\n\n        let (h1, h2) = self.hash(key);\n\n        let mut help_copy = true;\n        loop {\n            // Initialize the probe state.\n            let mut probe = Probe::start(h1, table.mask);\n\n            // Probe until we reach the limit.\n            let copying = 'probe: loop {\n                if probe.len > table.limit {\n                    break None;\n                }\n\n                // Load the entry metadata first for cheap searches.\n                //\n                // Safety: `probe.i` is always in-bounds for the table length.\n                let meta = unsafe { table.meta(probe.i).load(Ordering::Acquire) };\n\n                // The key is not in the table.\n                // It also cannot be in the next table because we have not went over the probe limit.\n                if meta == meta::EMPTY {\n                    return Ok(None);\n                }\n\n                // Check for a potential match.\n                if meta != h2 {\n                    probe.next(table.mask);\n                    continue 'probe;\n                }\n\n                // Load the full entry.\n                //\n                // Safety: `probe.i` is always in-bounds for the table length.\n                let mut entry = guard\n                    .protect(unsafe { table.entry(probe.i) }, Ordering::Acquire)\n                    .unpack();\n\n                // The entry was deleted, keep probing.\n                if entry.ptr.is_null() {\n                    probe.next(table.mask);\n                    continue 'probe;\n                }\n\n                // Check for a full match.\n                //\n                // Safety: We performed a protected load of the pointer using a verified guard with\n                // `Acquire` and ensured that it is non-null, meaning it is valid for reads as long\n                // as we hold the guard.\n                if !key.equivalent(unsafe { &(*entry.ptr).key }) {\n                    probe.next(table.mask);\n                    continue 'probe;\n                }\n\n                // The entry is being copied to the new table, we have to complete the copy before\n                // we can remove it.\n                if entry.tag() & Entry::COPYING != 0 {\n                    break 'probe Some(probe.i);\n                }\n\n                loop {\n                    // Safety: `entry` is a valid, non-null, protected entry that we found in the map.\n                    let entry_ref = unsafe { &(*entry.ptr) };\n\n                    // Ensure that the entry should be removed.\n                    if !should_remove(&entry_ref.key, &entry_ref.value) {\n                        return Err((&entry_ref.key, &entry_ref.value));\n                    }\n\n                    // Safety:\n                    // - `probe.i` is always in-bounds for the table length\n                    // - `entry` is a valid non-null entry that we found in the map.\n                    let status =\n                        unsafe { self.update_at(probe.i, entry, Entry::TOMBSTONE, table, guard) };\n\n                    match status {\n                        // Successfully removed the entry.\n                        UpdateStatus::Replaced(_entry) => {\n                            // Mark the entry as a tombstone.\n                            //\n                            // Note that this might end up being overwritten by the metadata hash\n                            // if the initial insertion is lagging behind, but we avoid the RMW\n                            // and sacrifice reads in the extremely rare case.\n                            //\n                            // Safety: `probe.i` is always in-bounds for the table length.\n                            unsafe {\n                                table\n                                    .meta(probe.i)\n                                    .store(meta::TOMBSTONE, Ordering::Release)\n                            };\n\n                            // Decrement the table length.\n                            self.count.get(guard).fetch_sub(1, Ordering::Relaxed);\n\n                            // Note that `entry_ref` here is the entry that we just replaced.\n                            return Ok(Some((&entry_ref.key, &entry_ref.value)));\n                        }\n\n                        // The entry is being copied to the new table, we have to complete the copy\n                        // before we can remove.\n                        UpdateStatus::Found(EntryStatus::Copied(_)) => break 'probe Some(probe.i),\n\n                        // The entry was deleted.\n                        //\n                        // We know that at some point during our execution the key was not in the map.\n                        UpdateStatus::Found(EntryStatus::Null) => return Ok(None),\n\n                        // Lost to a concurrent update, retry.\n                        UpdateStatus::Found(EntryStatus::Value(found)) => entry = found,\n                    }\n                }\n            };\n\n            // Prepare to retry in the next table.\n            table = match self.prepare_retry(copying, &mut help_copy, table, guard) {\n                Some(table) => table,\n\n                // The search was exhausted.\n                None => return Ok(None),\n            }\n        }\n    }"
}