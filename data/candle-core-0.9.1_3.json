{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `cpu_backend::ReduceIndex::fold_impl`",
    "file": "candle-core-0.9.1/src/cpu_backend/mod.rs",
    "start_line": 113,
    "start_col": 5,
    "end_line": 185,
    "end_col": 6,
    "code_snippet": "fn fold_impl<T, U, F, G>(&self, src: &[T], src_l: &Layout, f: F, g: G) -> Result<Vec<U>>\n    where\n        T: Clone + Copy,\n        U: Clone + Copy,\n        F: Fn(T, T) -> bool,\n        G: Fn(T, usize) -> U,\n    {\n        let reduce_dim_size = src_l.dims()[self.reduce_dim_index];\n        let reduce_dim_stride = src_l.stride()[self.reduce_dim_index];\n        let dst_len = src_l.shape().elem_count() / reduce_dim_size;\n        let mut dst: Vec<U> = Vec::with_capacity(dst_len);\n        let dst_to_set = dst.spare_capacity_mut();\n        let dst_to_set =\n            unsafe { std::mem::transmute::<&mut [std::mem::MaybeUninit<U>], &mut [U]>(dst_to_set) };\n        match src_l.contiguous_offsets() {\n            Some((o1, o2)) => {\n                let src = &src[o1..o2];\n                if reduce_dim_stride == 1 {\n                    for (start_src_i, dst_v) in dst_to_set.iter_mut().enumerate() {\n                        let start_src_i = start_src_i * reduce_dim_size;\n                        let src = &src[start_src_i..start_src_i + reduce_dim_size];\n                        let mut acc = 0;\n                        let mut val = src[0];\n                        for (src_i, &s) in src.iter().enumerate() {\n                            if f(val, s) {\n                                acc = src_i;\n                                val = s\n                            }\n                        }\n                        *dst_v = g(val, acc)\n                    }\n                } else {\n                    for (start_src_i, dst_v) in dst_to_set.iter_mut().enumerate() {\n                        let (p, q) = (\n                            start_src_i / reduce_dim_stride,\n                            start_src_i % reduce_dim_stride,\n                        );\n                        // start_src_i = p * reduce_dim_stride + q\n                        let start_src_i = p * reduce_dim_stride * reduce_dim_size + q;\n                        let src = &src[start_src_i..];\n                        let mut acc = 0;\n                        let mut val = src[0];\n                        for src_i in 0..reduce_dim_size {\n                            let s = src[src_i * reduce_dim_stride];\n                            if f(val, s) {\n                                acc = src_i;\n                                val = s\n                            }\n                        }\n                        *dst_v = g(val, acc)\n                    }\n                }\n            }\n            None => {\n                let l = src_l.narrow(self.reduce_dim_index, 0, 1)?;\n                for (unstr_index, src_index) in l.strided_index().enumerate() {\n                    let src = &src[src_index..];\n                    let mut acc = 0;\n                    let mut val = src[0];\n                    for src_i in 0..reduce_dim_size {\n                        let s = src[src_i * reduce_dim_stride];\n                        if f(val, s) {\n                            acc = src_i;\n                            val = s\n                        }\n                    }\n                    dst_to_set[unstr_index] = g(val, acc)\n                }\n            }\n        }\n        unsafe { dst.set_len(dst_len) };\n        Ok(dst)\n    }"
}