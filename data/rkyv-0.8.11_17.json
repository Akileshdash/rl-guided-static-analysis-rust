{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `collections::btree::map::ArchivedBTreeMap::<K, V, E>::get_key_value_raw`",
    "file": "rkyv-0.8.11/src/collections/btree/map/mod.rs",
    "start_line": 241,
    "start_col": 5,
    "end_line": 333,
    "end_col": 6,
    "code_snippet": "fn get_key_value_raw<Q>(\n        this: *mut Self,\n        key: &Q,\n    ) -> Option<(*mut K, *mut V)>\n    where\n        Q: Ord + ?Sized,\n        K: Borrow<Q> + Ord,\n    {\n        let len = unsafe { (*this).len.to_native() };\n        if len == 0 {\n            return None;\n        }\n\n        let root_ptr = unsafe { addr_of_mut!((*this).root) };\n        let mut current = unsafe { RelPtr::as_ptr_raw(root_ptr) };\n        'outer: loop {\n            let kind = unsafe { (*current).kind };\n\n            match kind {\n                NodeKind::Leaf => {\n                    let leaf = current.cast::<LeafNode<K, V, E>>();\n                    let len = unsafe { (*leaf).len };\n\n                    for i in 0..len.to_native() as usize {\n                        let k = unsafe {\n                            addr_of_mut!((*current).keys[i]).cast::<K>()\n                        };\n                        let ordering = key.cmp(unsafe { (*k).borrow() });\n\n                        match ordering {\n                            Ordering::Equal => {\n                                let v = unsafe {\n                                    addr_of_mut!((*current).values[i])\n                                        .cast::<V>()\n                                };\n                                return Some((k, v));\n                            }\n                            Ordering::Less => return None,\n                            Ordering::Greater => (),\n                        }\n                    }\n\n                    return None;\n                }\n                NodeKind::Inner => {\n                    let inner = current.cast::<InnerNode<K, V, E>>();\n\n                    for i in 0..E {\n                        let k = unsafe {\n                            addr_of_mut!((*current).keys[i]).cast::<K>()\n                        };\n                        let ordering = key.cmp(unsafe { (*k).borrow() });\n\n                        match ordering {\n                            Ordering::Equal => {\n                                let v = unsafe {\n                                    addr_of_mut!((*current).values[i])\n                                        .cast::<V>()\n                                };\n                                return Some((k, v));\n                            }\n                            Ordering::Less => {\n                                let lesser = unsafe {\n                                    addr_of_mut!((*inner).lesser_nodes[i])\n                                };\n                                let lesser_is_invalid =\n                                    unsafe { RelPtr::is_invalid_raw(lesser) };\n                                if !lesser_is_invalid {\n                                    current =\n                                        unsafe { RelPtr::as_ptr_raw(lesser) };\n                                    continue 'outer;\n                                } else {\n                                    return None;\n                                }\n                            }\n                            Ordering::Greater => (),\n                        }\n                    }\n\n                    let inner = current.cast::<InnerNode<K, V, E>>();\n                    let greater =\n                        unsafe { addr_of_mut!((*inner).greater_node) };\n                    let greater_is_invalid =\n                        unsafe { RelPtr::is_invalid_raw(greater) };\n                    if !greater_is_invalid {\n                        current = unsafe { RelPtr::as_ptr_raw(greater) };\n                    } else {\n                        return None;\n                    }\n                }\n            }\n        }\n    }"
}