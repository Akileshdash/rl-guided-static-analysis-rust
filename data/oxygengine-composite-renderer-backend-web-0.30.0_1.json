{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `WebCompositeRenderer::execute_with`",
    "file": "oxygengine-composite-renderer-backend-web-0.30.0/src/lib.rs",
    "start_line": 88,
    "start_col": 5,
    "end_line": 785,
    "end_col": 6,
    "code_snippet": "fn execute_with<'a, I>(\n        &self,\n        context: &CanvasRenderingContext2d,\n        mut current_alpha: Scalar,\n        commands: I,\n    ) -> Result<(usize, usize)>\n    where\n        I: IntoIterator<Item = Command<'a>>,\n    {\n        let mut render_ops = 0;\n        let mut renderables = 0;\n        let mut alpha_stack = vec![current_alpha];\n        for command in commands {\n            match command {\n                Command::Draw(renderable) => match renderable {\n                    Renderable::None => {}\n                    Renderable::Rectangle(rectangle) => {\n                        context.set_fill_style(&rectangle.color.to_string().into());\n                        context.fill_rect(\n                            rectangle.rect.x.into(),\n                            rectangle.rect.y.into(),\n                            rectangle.rect.w.into(),\n                            rectangle.rect.h.into(),\n                        );\n                        render_ops += 2;\n                        renderables += 1;\n                    }\n                    Renderable::FullscreenRectangle(color) => {\n                        context.save();\n                        drop(context.set_transform(1.0, 0.0, 0.0, 1.0, 0.0, 0.0));\n                        context.set_fill_style(&color.to_string().into());\n                        context.fill_rect(\n                            0.0,\n                            0.0,\n                            self.view_size.x.into(),\n                            self.view_size.y.into(),\n                        );\n                        context.restore();\n                        render_ops += 2;\n                        renderables += 1;\n                    }\n                    Renderable::Text(text) => {\n                        let name = if let Some(name) = self.font_family_map.get(text.font.as_ref())\n                        {\n                            name\n                        } else {\n                            text.font.as_ref()\n                        };\n                        context.set_fill_style(&text.color.to_string().into());\n                        context.set_font(&format!(\"{}px \\\"{}\\\"\", text.size, name));\n                        context.set_text_align(match text.align {\n                            TextAlign::Left => \"left\",\n                            TextAlign::Center => \"center\",\n                            TextAlign::Right => \"right\",\n                        });\n                        context.set_text_baseline(match text.baseline {\n                            TextBaseLine::Top => \"top\",\n                            TextBaseLine::Middle => \"middle\",\n                            TextBaseLine::Bottom => \"bottom\",\n                            TextBaseLine::Alphabetic => \"alphabetic\",\n                            TextBaseLine::Hanging => \"hanging\",\n                        });\n                        for (i, line) in text.text.lines().enumerate() {\n                            if let Some(max_width) = text.max_width {\n                                drop(context.fill_text_with_max_width(\n                                    line,\n                                    text.position.x.into(),\n                                    (text.position.y + text.size * i as Scalar).into(),\n                                    max_width.into(),\n                                ));\n                            } else {\n                                drop(context.fill_text(\n                                    line,\n                                    text.position.x.into(),\n                                    (text.position.y + text.size * i as Scalar).into(),\n                                ));\n                            }\n                            render_ops += 1;\n                        }\n                        render_ops += 3;\n                        renderables += 1;\n                    }\n                    Renderable::Path(path) => {\n                        let mut ops = 0;\n                        context.begin_path();\n                        for element in &path.elements {\n                            match element {\n                                PathElement::MoveTo(pos) => {\n                                    context.move_to(pos.x.into(), pos.y.into());\n                                    ops += 1;\n                                }\n                                PathElement::LineTo(pos) => {\n                                    context.line_to(pos.x.into(), pos.y.into());\n                                    ops += 1;\n                                }\n                                PathElement::BezierCurveTo(cpa, cpb, pos) => {\n                                    context.bezier_curve_to(\n                                        cpa.x.into(),\n                                        cpa.y.into(),\n                                        cpb.x.into(),\n                                        cpb.y.into(),\n                                        pos.x.into(),\n                                        pos.y.into(),\n                                    );\n                                    ops += 1;\n                                }\n                                PathElement::QuadraticCurveTo(cp, pos) => {\n                                    context.quadratic_curve_to(\n                                        cp.x.into(),\n                                        cp.y.into(),\n                                        pos.x.into(),\n                                        pos.y.into(),\n                                    );\n                                    ops += 1;\n                                }\n                                PathElement::Arc(pos, r, a) => {\n                                    drop(context.arc(\n                                        pos.x.into(),\n                                        pos.y.into(),\n                                        (*r).into(),\n                                        a.start.into(),\n                                        a.end.into(),\n                                    ));\n                                    ops += 1;\n                                }\n                                PathElement::Ellipse(pos, r, rot, a) => {\n                                    drop(context.ellipse(\n                                        pos.x.into(),\n                                        pos.y.into(),\n                                        r.x.into(),\n                                        r.y.into(),\n                                        (*rot).into(),\n                                        a.start.into(),\n                                        a.end.into(),\n                                    ));\n                                    ops += 1;\n                                }\n                                PathElement::Rectangle(rect) => {\n                                    context.rect(\n                                        rect.x.into(),\n                                        rect.y.into(),\n                                        rect.w.into(),\n                                        rect.h.into(),\n                                    );\n                                    ops += 1;\n                                }\n                            }\n                        }\n                        context.set_fill_style(&path.color.to_string().into());\n                        context.close_path();\n                        context.fill();\n                        render_ops += 4 + ops;\n                        renderables += 1;\n                    }\n                    Renderable::Mask(mask) => {\n                        let mut ops = 0;\n                        context.begin_path();\n                        for element in &mask.elements {\n                            match element {\n                                PathElement::MoveTo(pos) => {\n                                    context.move_to(pos.x.into(), pos.y.into());\n                                    ops += 1;\n                                }\n                                PathElement::LineTo(pos) => {\n                                    context.line_to(pos.x.into(), pos.y.into());\n                                    ops += 1;\n                                }\n                                PathElement::BezierCurveTo(cpa, cpb, pos) => {\n                                    context.bezier_curve_to(\n                                        cpa.x.into(),\n                                        cpa.y.into(),\n                                        cpb.x.into(),\n                                        cpb.y.into(),\n                                        pos.x.into(),\n                                        pos.y.into(),\n                                    );\n                                    ops += 1;\n                                }\n                                PathElement::QuadraticCurveTo(cp, pos) => {\n                                    context.quadratic_curve_to(\n                                        cp.x.into(),\n                                        cp.y.into(),\n                                        pos.x.into(),\n                                        pos.y.into(),\n                                    );\n                                    ops += 1;\n                                }\n                                PathElement::Arc(pos, r, a) => {\n                                    drop(context.arc(\n                                        pos.x.into(),\n                                        pos.y.into(),\n                                        (*r).into(),\n                                        a.start.into(),\n                                        a.end.into(),\n                                    ));\n                                    ops += 1;\n                                }\n                                PathElement::Ellipse(pos, r, rot, a) => {\n                                    drop(context.ellipse(\n                                        pos.x.into(),\n                                        pos.y.into(),\n                                        r.x.into(),\n                                        r.y.into(),\n                                        (*rot).into(),\n                                        a.start.into(),\n                                        a.end.into(),\n                                    ));\n                                    ops += 1;\n                                }\n                                PathElement::Rectangle(rect) => {\n                                    context.rect(\n                                        rect.x.into(),\n                                        rect.y.into(),\n                                        rect.w.into(),\n                                        rect.h.into(),\n                                    );\n                                    ops += 1;\n                                }\n                            }\n                        }\n                        context.close_path();\n                        context.clip();\n                        render_ops += 3 + ops;\n                    }\n                    Renderable::Image(image) => {\n                        let path = image.image.as_ref();\n                        if let Some(elm) = self.images_cache.get(path) {\n                            let mut src = if let Some(src) = image.source {\n                                src\n                            } else {\n                                Rect {\n                                    x: 0.0,\n                                    y: 0.0,\n                                    w: elm.width() as Scalar,\n                                    h: elm.height() as Scalar,\n                                }\n                            };\n                            let dst = if let Some(dst) = image.destination {\n                                dst\n                            } else {\n                                Rect {\n                                    x: 0.0,\n                                    y: 0.0,\n                                    w: src.w,\n                                    h: src.h,\n                                }\n                            }\n                            .align(image.alignment);\n                            src.x += self.state.image_source_inner_margin;\n                            src.y += self.state.image_source_inner_margin;\n                            src.w -= self.state.image_source_inner_margin * 2.0;\n                            src.h -= self.state.image_source_inner_margin * 2.0;\n                            if src.x < 0.0 {\n                                src.w += src.x;\n                                src.x = 0.0;\n                            }\n                            if src.y < 0.0 {\n                                src.h += src.y;\n                                src.y = 0.0;\n                            }\n                            src.w = src.w.max(1.0);\n                            src.h = src.h.max(1.0);\n                            drop(context\n                                .draw_image_with_html_canvas_element_and_sw_and_sh_and_dx_and_dy_and_dw_and_dh(\n                                    elm,\n                                    src.x.into(),\n                                    src.y.into(),\n                                    src.w.into(),\n                                    src.h.into(),\n                                    dst.x.into(),\n                                    dst.y.into(),\n                                    dst.w.into(),\n                                    dst.h.into(),\n                                ));\n                            render_ops += 1;\n                            renderables += 1;\n                        } else if let Some((elm, _)) = self.surfaces_cache.get(path) {\n                            let mut src = if let Some(src) = image.source {\n                                src\n                            } else {\n                                Rect {\n                                    x: 0.0,\n                                    y: 0.0,\n                                    w: elm.width() as Scalar,\n                                    h: elm.height() as Scalar,\n                                }\n                            };\n                            let dst = if let Some(dst) = image.destination {\n                                dst\n                            } else {\n                                Rect {\n                                    x: 0.0,\n                                    y: 0.0,\n                                    w: src.w,\n                                    h: src.h,\n                                }\n                            }\n                            .align(image.alignment);\n                            src.x += self.state.image_source_inner_margin;\n                            src.y += self.state.image_source_inner_margin;\n                            src.w -= self.state.image_source_inner_margin * 2.0;\n                            src.h -= self.state.image_source_inner_margin * 2.0;\n                            if src.x < 0.0 {\n                                src.w += src.x;\n                                src.x = 0.0;\n                            }\n                            if src.y < 0.0 {\n                                src.h += src.y;\n                                src.y = 0.0;\n                            }\n                            src.w = src.w.max(1.0);\n                            src.h = src.h.max(1.0);\n                            drop(context\n                                .draw_image_with_html_canvas_element_and_sw_and_sh_and_dx_and_dy_and_dw_and_dh(\n                                    elm,\n                                    src.x.into(),\n                                    src.y.into(),\n                                    src.w.into(),\n                                    src.h.into(),\n                                    dst.x.into(),\n                                    dst.y.into(),\n                                    dst.w.into(),\n                                    dst.h.into(),\n                                ));\n                            render_ops += 1;\n                            renderables += 1;\n                        }\n                    }\n                    Renderable::Triangles(triangles) => {\n                        let path: &str = &triangles.image;\n                        if let Some(elm) = self.images_cache.get(path) {\n                            let w = elm.width() as Scalar;\n                            let h = elm.height() as Scalar;\n                            let s = Vec2::new(w, h);\n                            for triangle in &triangles.faces {\n                                let a = triangles.vertices[triangle.a];\n                                let b = triangles.vertices[triangle.b];\n                                let c = triangles.vertices[triangle.c];\n                                let nab = (b.0 - a.0).normalized();\n                                let nbc = (c.0 - b.0).normalized();\n                                let nca = (a.0 - c.0).normalized();\n                                if !Vec2::is_clockwise(nab, nbc) {\n                                    continue;\n                                }\n                                let pa = a.0 - nbc.right() * self.state.triangles_outer_margin;\n                                let pb = b.0 - nca.right() * self.state.triangles_outer_margin;\n                                let pc = c.0 - nab.right() * self.state.triangles_outer_margin;\n                                context.save();\n                                context.begin_path();\n                                context.move_to(pa.x.into(), pa.y.into());\n                                context.line_to(pb.x.into(), pb.y.into());\n                                context.line_to(pc.x.into(), pc.y.into());\n                                context.close_path();\n                                context.clip();\n                                let s0 = a.1 * s;\n                                let s1 = b.1 * s;\n                                let s2 = c.1 * s;\n                                let denom = s0.x * (s2.y - s1.y) - s1.x * s2.y\n                                    + s2.x * s1.y\n                                    + (s1.x - s2.x) * s0.y;\n                                if denom.abs() > 0.0 {\n                                    let m11 = -(s0.y * (c.0.x - b.0.x) - s1.y * c.0.x\n                                        + s2.y * b.0.x\n                                        + (s1.y - s2.y) * a.0.x)\n                                        / denom;\n                                    let m12 = (s1.y * c.0.y + s0.y * (b.0.y - c.0.y)\n                                        - s2.y * b.0.y\n                                        + (s2.y - s1.y) * a.0.y)\n                                        / denom;\n                                    let m21 = (s0.x * (c.0.x - b.0.x) - s1.x * c.0.x\n                                        + s2.x * b.0.x\n                                        + (s1.x - s2.x) * a.0.x)\n                                        / denom;\n                                    let m22 = -(s1.x * c.0.y + s0.x * (b.0.y - c.0.y)\n                                        - s2.x * b.0.y\n                                        + (s2.x - s1.x) * a.0.y)\n                                        / denom;\n                                    let dx = (s0.x * (s2.y * b.0.x - s1.y * c.0.x)\n                                        + s0.y * (s1.x * c.0.x - s2.x * b.0.x)\n                                        + (s2.x * s1.y - s1.x * s2.y) * a.0.x)\n                                        / denom;\n                                    let dy = (s0.x * (s2.y * b.0.y - s1.y * c.0.y)\n                                        + s0.y * (s1.x * c.0.y - s2.x * b.0.y)\n                                        + (s2.x * s1.y - s1.x * s2.y) * a.0.y)\n                                        / denom;\n                                    drop(context.transform(\n                                        m11.into(),\n                                        m12.into(),\n                                        m21.into(),\n                                        m22.into(),\n                                        dx.into(),\n                                        dy.into(),\n                                    ));\n                                    drop(\n                                        context.draw_image_with_html_canvas_element(elm, 0.0, 0.0),\n                                    );\n                                    render_ops += 2;\n                                    renderables += 1;\n                                }\n                                context.restore();\n                                render_ops += 8;\n                            }\n                        } else if let Some((elm, _)) = self.surfaces_cache.get(path) {\n                            let w = elm.width() as Scalar;\n                            let h = elm.height() as Scalar;\n                            let s = Vec2::new(w, h);\n                            for triangle in &triangles.faces {\n                                let a = triangles.vertices[triangle.a];\n                                let b = triangles.vertices[triangle.b];\n                                let c = triangles.vertices[triangle.c];\n                                let nab = (b.0 - a.0).normalized();\n                                let nbc = (c.0 - b.0).normalized();\n                                let nca = (a.0 - c.0).normalized();\n                                if !Vec2::is_clockwise(nab, nbc) {\n                                    continue;\n                                }\n                                let pa = a.0 - nbc.right() * self.state.triangles_outer_margin;\n                                let pb = b.0 - nca.right() * self.state.triangles_outer_margin;\n                                let pc = c.0 - nab.right() * self.state.triangles_outer_margin;\n                                context.save();\n                                context.begin_path();\n                                context.move_to(pa.x.into(), pa.y.into());\n                                context.line_to(pb.x.into(), pb.y.into());\n                                context.line_to(pc.x.into(), pc.y.into());\n                                context.close_path();\n                                context.clip();\n                                let s0 = a.1 * s;\n                                let s1 = b.1 * s;\n                                let s2 = c.1 * s;\n                                let denom = s0.x * (s2.y - s1.y) - s1.x * s2.y\n                                    + s2.x * s1.y\n                                    + (s1.x - s2.x) * s0.y;\n                                if denom.abs() > 0.0 {\n                                    let m11 = -(s0.y * (c.0.x - b.0.x) - s1.y * c.0.x\n                                        + s2.y * b.0.x\n                                        + (s1.y - s2.y) * a.0.x)\n                                        / denom;\n                                    let m12 = (s1.y * c.0.y + s0.y * (b.0.y - c.0.y)\n                                        - s2.y * b.0.y\n                                        + (s2.y - s1.y) * a.0.y)\n                                        / denom;\n                                    let m21 = (s0.x * (c.0.x - b.0.x) - s1.x * c.0.x\n                                        + s2.x * b.0.x\n                                        + (s1.x - s2.x) * a.0.x)\n                                        / denom;\n                                    let m22 = -(s1.x * c.0.y + s0.x * (b.0.y - c.0.y)\n                                        - s2.x * b.0.y\n                                        + (s2.x - s1.x) * a.0.y)\n                                        / denom;\n                                    let dx = (s0.x * (s2.y * b.0.x - s1.y * c.0.x)\n                                        + s0.y * (s1.x * c.0.x - s2.x * b.0.x)\n                                        + (s2.x * s1.y - s1.x * s2.y) * a.0.x)\n                                        / denom;\n                                    let dy = (s0.x * (s2.y * b.0.y - s1.y * c.0.y)\n                                        + s0.y * (s1.x * c.0.y - s2.x * b.0.y)\n                                        + (s2.x * s1.y - s1.x * s2.y) * a.0.y)\n                                        / denom;\n                                    drop(context.transform(\n                                        m11.into(),\n                                        m12.into(),\n                                        m21.into(),\n                                        m22.into(),\n                                        dx.into(),\n                                        dy.into(),\n                                    ));\n                                    drop(\n                                        context.draw_image_with_html_canvas_element(elm, 0.0, 0.0),\n                                    );\n                                    render_ops += 2;\n                                    renderables += 1;\n                                }\n                                context.restore();\n                                render_ops += 8;\n                            }\n                        }\n                    }\n                    Renderable::Commands(commands) => {\n                        let (o, r) =\n                            self.execute_with(context, current_alpha, commands.into_iter())?;\n                        render_ops += o;\n                        renderables += r;\n                    }\n                },\n                Command::Stroke(line_width, renderable) => match renderable {\n                    Renderable::None => {}\n                    Renderable::Rectangle(rectangle) => {\n                        context.set_stroke_style(&rectangle.color.to_string().into());\n                        context.set_line_width(line_width.into());\n                        context.stroke_rect(\n                            rectangle.rect.x.into(),\n                            rectangle.rect.y.into(),\n                            rectangle.rect.w.into(),\n                            rectangle.rect.h.into(),\n                        );\n                        render_ops += 3;\n                        renderables += 1;\n                    }\n                    Renderable::FullscreenRectangle(color) => {\n                        context.save();\n                        drop(context.set_transform(1.0, 0.0, 0.0, 1.0, 0.0, 0.0));\n                        context.set_stroke_style(&color.to_string().into());\n                        context.set_line_width(line_width.into());\n                        context.fill_rect(\n                            0.0,\n                            0.0,\n                            self.view_size.x.into(),\n                            self.view_size.y.into(),\n                        );\n                        context.restore();\n                        render_ops += 2;\n                        renderables += 1;\n                    }\n                    Renderable::Text(text) => {\n                        let name = if let Some(name) = self.font_family_map.get(text.font.as_ref())\n                        {\n                            name\n                        } else {\n                            text.font.as_ref()\n                        };\n                        context.set_stroke_style(&text.color.to_string().into());\n                        context.set_line_width(line_width.into());\n                        context.set_font(&format!(\"{}px \\\"{}\\\"\", text.size, name));\n                        context.set_text_align(match text.align {\n                            TextAlign::Left => \"left\",\n                            TextAlign::Center => \"center\",\n                            TextAlign::Right => \"right\",\n                        });\n                        context.set_text_baseline(match text.baseline {\n                            TextBaseLine::Top => \"top\",\n                            TextBaseLine::Middle => \"middle\",\n                            TextBaseLine::Bottom => \"bottom\",\n                            TextBaseLine::Alphabetic => \"alphabetic\",\n                            TextBaseLine::Hanging => \"hanging\",\n                        });\n                        for (i, line) in text.text.lines().enumerate() {\n                            if let Some(max_width) = text.max_width {\n                                drop(context.stroke_text_with_max_width(\n                                    line,\n                                    text.position.x.into(),\n                                    (text.position.y + text.size * i as Scalar).into(),\n                                    max_width.into(),\n                                ));\n                            } else {\n                                drop(context.stroke_text(\n                                    line,\n                                    text.position.x.into(),\n                                    (text.position.y + text.size * i as Scalar).into(),\n                                ));\n                            }\n                            render_ops += 1;\n                        }\n                        render_ops += 4;\n                        renderables += 1;\n                    }\n                    Renderable::Path(path) => {\n                        let mut ops = 0;\n                        context.begin_path();\n                        for element in &path.elements {\n                            match element {\n                                PathElement::MoveTo(pos) => {\n                                    context.move_to(pos.x.into(), pos.y.into());\n                                    ops += 1;\n                                }\n                                PathElement::LineTo(pos) => {\n                                    context.line_to(pos.x.into(), pos.y.into());\n                                    ops += 1;\n                                }\n                                PathElement::BezierCurveTo(cpa, cpb, pos) => {\n                                    context.bezier_curve_to(\n                                        cpa.x.into(),\n                                        cpa.y.into(),\n                                        cpb.x.into(),\n                                        cpb.y.into(),\n                                        pos.x.into(),\n                                        pos.y.into(),\n                                    );\n                                    ops += 1;\n                                }\n                                PathElement::QuadraticCurveTo(cp, pos) => {\n                                    context.quadratic_curve_to(\n                                        cp.x.into(),\n                                        cp.y.into(),\n                                        pos.x.into(),\n                                        pos.y.into(),\n                                    );\n                                    ops += 1;\n                                }\n                                PathElement::Arc(pos, r, a) => {\n                                    drop(context.arc(\n                                        pos.x.into(),\n                                        pos.y.into(),\n                                        (*r).into(),\n                                        a.start.into(),\n                                        a.end.into(),\n                                    ));\n                                    ops += 1;\n                                }\n                                PathElement::Ellipse(pos, r, rot, a) => {\n                                    drop(context.ellipse(\n                                        pos.x.into(),\n                                        pos.y.into(),\n                                        r.x.into(),\n                                        r.y.into(),\n                                        (*rot).into(),\n                                        a.start.into(),\n                                        a.end.into(),\n                                    ));\n                                    ops += 1;\n                                }\n                                PathElement::Rectangle(rect) => {\n                                    context.rect(\n                                        rect.x.into(),\n                                        rect.y.into(),\n                                        rect.w.into(),\n                                        rect.h.into(),\n                                    );\n                                    ops += 1;\n                                }\n                            }\n                        }\n                        context.set_stroke_style(&path.color.to_string().into());\n                        context.set_line_width(line_width.into());\n                        context.close_path();\n                        context.stroke();\n                        render_ops += 5 + ops;\n                        renderables += 1;\n                    }\n                    Renderable::Mask(_) => error!(\"Trying to make stroked mask\"),\n                    Renderable::Image(image) => {\n                        error!(\"Trying to render stroked image: {}\", image.image)\n                    }\n                    Renderable::Triangles(triangles) => {\n                        context.save();\n                        context.set_stroke_style(&triangles.color.to_string().into());\n                        context.set_line_width(line_width.into());\n                        for triangle in &triangles.faces {\n                            let a = triangles.vertices[triangle.a];\n                            let b = triangles.vertices[triangle.b];\n                            let c = triangles.vertices[triangle.c];\n                            context.begin_path();\n                            context.move_to(a.0.x.into(), a.0.y.into());\n                            context.line_to(b.0.x.into(), b.0.y.into());\n                            context.line_to(c.0.x.into(), c.0.y.into());\n                            context.close_path();\n                            context.stroke();\n                            render_ops += 6;\n                            renderables += 1;\n                        }\n                        context.restore();\n                        render_ops += 4;\n                    }\n                    Renderable::Commands(commands) => {\n                        error!(\"Trying to render stroked subcommands: {:#?}\", commands)\n                    }\n                },\n                Command::Transform(a, b, c, d, e, f) => {\n                    drop(context.transform(\n                        a.into(),\n                        b.into(),\n                        c.into(),\n                        d.into(),\n                        e.into(),\n                        f.into(),\n                    ));\n                    render_ops += 1;\n                }\n                Command::Effect(effect) => {\n                    drop(context.set_global_composite_operation(&effect.to_string()));\n                    render_ops += 1;\n                }\n                Command::Alpha(alpha) => {\n                    current_alpha = alpha_stack.last().copied().unwrap_or(1.0) * alpha;\n                    context.set_global_alpha(current_alpha.max(0.0).min(1.0).into());\n                    render_ops += 1;\n                }\n                Command::Filter(data) => {\n                    context.set_filter(data.as_ref());\n                    render_ops += 1;\n                }\n                Command::Smoothing(value) => {\n                    context.set_image_smoothing_enabled(value);\n                    render_ops += 1;\n                }\n                Command::Store => {\n                    alpha_stack.push(current_alpha);\n                    context.save();\n                    render_ops += 1;\n                }\n                Command::Restore => {\n                    current_alpha = alpha_stack.pop().unwrap_or(1.0);\n                    context.restore();\n                    render_ops += 1;\n                }\n                Command::None => {}\n            }\n        }\n        Ok((render_ops, renderables))\n    }"
}