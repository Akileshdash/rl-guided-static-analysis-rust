{
    "level": "Warning",
    "analyzer": "UnsafeDestructor",
    "op_type": null,
    "description": "unsafe block detected in drop",
    "file": "gluon_vm-0.18.2/src/thread.rs",
    "start_line": 601,
    "start_col": 1,
    "end_line": 601,
    "end_col": 27,
    "code_snippet": "impl Drop for RootedThread {\n    fn drop(&mut self) {\n        if self.rooted && self.unroot_() {\n            // The last RootedThread was dropped, there is no way to refer to the global state any\n            // longer so drop everything\n            let mut gc_ref = self.thread.global_state.gc.lock().unwrap_or_else(|err| {\n                // Ignore poisoning since we don't need to interact with the Gc values, only\n                // drop them\n                err.into_inner()\n            });\n            let mut gc_to_drop = std::mem::replace(&mut *gc_ref, Gc::new(Generation::default(), 0));\n            // Make sure that the RefMut is dropped before the Gc itself as the RwLock is dropped\n            // when the Gc is dropped\n            drop(gc_ref);\n\n            // Macros can contain unrooted thread references via the database so we must drop those first\n            self.global_state.get_macros().clear();\n\n            // SAFETY GcPtr's may not leak outside of the `Thread` so we can safely clear it when\n            // droppting the thread\n            unsafe {\n                gc_to_drop.clear();\n            }\n        }\n    }\n}"
}