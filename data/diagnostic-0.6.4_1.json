{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `write::<impl Diagnostic>::write_for_stream`",
    "file": "diagnostic-0.6.4/src/write.rs",
    "start_line": 89,
    "start_col": 5,
    "end_line": 637,
    "end_col": 6,
    "code_snippet": "fn write_for_stream<W: Write>(&self, cache: &SourceCache, mut w: W, s: StreamType) -> std::io::Result<()> {\n        let draw = self.config.characters;\n\n        // --- Header ---\n        let kind_color = self.kind.get_color();\n        let head = match &self.code {\n            Some(s) => format!(\"{:?}[{:04}]:\", self.kind, s),\n            None => format!(\"{:?}:\", self.kind),\n        };\n        write!(w, \"{}\", head.fg(kind_color, s))?;\n        if self.message.is_empty() {\n            writeln!(w)?;\n        }\n        else {\n            writeln!(w, \" {}\", self.message)?;\n        }\n        let groups = self.get_source_groups(&cache);\n\n        // Line number maximum width\n        let line_no_width = groups\n            .iter()\n            .filter_map(|SourceGroup { span, id: src_id, .. }| {\n                let src_name = cache.source_path(src_id).map(|d| d.to_string()).unwrap_or_else(|| \"<unknown>\".to_string());\n\n                let src = match cache.fetch(src_id) {\n                    Ok(src) => src,\n                    Err(e) => {\n                        eprintln!(\"Unable to fetch identifier {}: {:?}\", src_name, e);\n                        return None;\n                    }\n                };\n\n                let line_range = src.get_line_range(span);\n                Some((1..).map(|x| 10u32.pow(x)).take_while(|x| line_range.end as u32 / x != 0).count() + 1)\n            })\n            .max()\n            .unwrap_or(0);\n\n        // --- Source sections ---\n        let groups_len = groups.len();\n        for (group_idx, SourceGroup { id: src_id, span, labels }) in groups.into_iter().enumerate() {\n            let src_name = cache.source_path(src_id).map(|d| d.to_string()).unwrap_or_else(|| \"<unknown>\".to_string());\n\n            let src = match cache.fetch(src_id) {\n                Ok(src) => src,\n                Err(e) => {\n                    eprintln!(\"Unable to fetch identifier {}: {:?}\", src_name, e);\n                    continue;\n                }\n            };\n\n            let line_range = src.get_line_range(&span);\n            let line_ref = self.get_line_column(src_id, &labels, src);\n            // File name & reference\n            writeln!(\n                w,\n                \"{}{}{}{}{}{}{}\",\n                Show((' ', line_no_width + 2)),\n                if group_idx == 0 { draw.ltop } else { draw.lcross }.fg(self.config.margin_color(), s),\n                draw.hbar.fg(self.config.margin_color(), s),\n                draw.lbox.fg(self.config.margin_color(), s),\n                src_name,\n                line_ref,\n                draw.rbox.fg(self.config.margin_color(), s),\n            )?;\n\n            if !self.config.compact {\n                writeln!(w, \"{}{}\", Show((' ', line_no_width + 2)), draw.vbar.fg(self.config.margin_color(), s))?;\n            }\n\n            struct LineLabel<'a> {\n                column: u32,\n                label: &'a Label,\n                multi: bool,\n                draw_msg: bool,\n            }\n\n            // Generate a list of multi-line labels\n            let mut multi_labels = Vec::new();\n            for label_info in &labels {\n                if matches!(label_info.kind, LabelKind::Multiline) {\n                    multi_labels.push(&label_info.label);\n                }\n            }\n\n            // Sort multiline labels by length\n            multi_labels.sort_by_key(|m| -(m.span.length() as isize));\n\n            let write_margin = |w: &mut W,\n                                idx: usize,\n                                is_line: bool,\n                                is_ellipsis: bool,\n                                draw_labels: bool,\n                                report_row: Option<(usize, bool)>,\n                                line_labels: &[LineLabel],\n                                margin_label: &Option<LineLabel>|\n             -> std::io::Result<()> {\n                let line_no_margin = if is_line && !is_ellipsis {\n                    let line_no = format!(\"{}\", idx + 1);\n                    format!(\"{}{} {}\", Show((' ', line_no_width - line_no.chars().count())), line_no, draw.vbar,)\n                        .fg(self.config.margin_color(), s)\n                }\n                else {\n                    format!(\"{}{}\", Show((' ', line_no_width + 1)), if is_ellipsis { draw.vbar_gap } else { draw.vbar })\n                        .fg(self.config.skipped_margin_color(), s)\n                };\n\n                write!(w, \" {}{}\", line_no_margin, Show(Some(' ').filter(|_| !self.config.compact)),)?;\n\n                // Multi-line margins\n                if draw_labels {\n                    for col in 0..multi_labels.len() + (multi_labels.len() > 0) as usize {\n                        let mut corner = None;\n                        let mut hbar = None;\n                        let mut vbar: Option<&&Label> = None;\n                        let mut margin_ptr = None;\n\n                        let multi_label = multi_labels.get(col);\n                        let line_span = src.get_line(idx).unwrap().range();\n\n                        for (i, label) in multi_labels[0..(col + 1).min(multi_labels.len())].iter().enumerate() {\n                            let margin = margin_label.as_ref().filter(|m| **label as *const _ == m.label as *const _);\n\n                            if label.span.start <= line_span.end && label.span.end > line_span.start {\n                                let is_parent = i != col;\n                                let is_start = line_span.contains(&label.span.start);\n                                let is_end = line_span.contains(&label.last_offset());\n\n                                if let Some(margin) = margin.filter(|_| is_line) {\n                                    margin_ptr = Some((margin, is_start));\n                                }\n                                else if !is_start && (!is_end || is_line) {\n                                    vbar = vbar.or(Some(*label).filter(|_| !is_parent));\n                                }\n                                else if let Some((report_row, is_arrow)) = report_row {\n                                    let label_row = line_labels\n                                        .iter()\n                                        .enumerate()\n                                        .find(|(_, l)| **label as *const _ == l.label as *const _)\n                                        .map_or(0, |(r, _)| r);\n                                    if report_row == label_row {\n                                        if let Some(margin) = margin {\n                                            vbar = Some(&margin.label).filter(|_| col == i);\n                                            if is_start {\n                                                continue;\n                                            }\n                                        }\n\n                                        if is_arrow {\n                                            hbar = Some(**label);\n                                            if !is_parent {\n                                                corner = Some((label, is_start));\n                                            }\n                                        }\n                                        else if !is_start {\n                                            vbar = vbar.or(Some(*label).filter(|_| !is_parent));\n                                        }\n                                    }\n                                    else {\n                                        vbar = vbar\n                                            .or(Some(*label).filter(|_| !is_parent && (is_start ^ (report_row < label_row))));\n                                    }\n                                }\n                            }\n                        }\n\n                        if let (Some((margin, _is_start)), true) = (margin_ptr, is_line) {\n                            let is_col = multi_label.map_or(false, |ml| **ml as *const _ == margin.label as *const _);\n                            let is_limit = col + 1 == multi_labels.len();\n                            if !is_col && !is_limit {\n                                hbar = hbar.or(Some(margin.label));\n                            }\n                        }\n\n                        hbar = hbar.filter(|l| {\n                            margin_label.as_ref().map_or(true, |margin| margin.label as *const _ != *l as *const _) || !is_line\n                        });\n\n                        let (a, b) = if let Some((label, is_start)) = corner {\n                            (if is_start { draw.ltop } else { draw.lbot }.fg(label.color, s), draw.hbar.fg(label.color, s))\n                        }\n                        else if let Some(label) = hbar.filter(|_| vbar.is_some() && !self.config.cross_gap) {\n                            (draw.xbar.fg(label.color, s), draw.hbar.fg(label.color, s))\n                        }\n                        else if let Some(label) = hbar {\n                            (draw.hbar.fg(label.color, s), draw.hbar.fg(label.color, s))\n                        }\n                        else if let Some(label) = vbar {\n                            (if is_ellipsis { draw.vbar_gap } else { draw.vbar }.fg(label.color, s), ' '.fg(None, s))\n                        }\n                        else if let (Some((margin, is_start)), true) = (margin_ptr, is_line) {\n                            let is_col = multi_label.map_or(false, |ml| **ml as *const _ == margin.label as *const _);\n                            let is_limit = col == multi_labels.len();\n                            (\n                                if is_limit {\n                                    draw.rarrow\n                                }\n                                else if is_col {\n                                    if is_start { draw.ltop } else { draw.lcross }\n                                }\n                                else {\n                                    draw.hbar\n                                }\n                                .fg(margin.label.color, s),\n                                if !is_limit { draw.hbar } else { ' ' }.fg(margin.label.color, s),\n                            )\n                        }\n                        else {\n                            (' '.fg(None, s), ' '.fg(None, s))\n                        };\n                        write!(w, \"{}\", a)?;\n                        if !self.config.compact {\n                            write!(w, \"{}\", b)?;\n                        }\n                    }\n                }\n\n                Ok(())\n            };\n\n            let mut is_ellipsis = false;\n            for idx in line_range {\n                let line = if let Some(line) = src.get_line(idx) {\n                    line\n                }\n                else {\n                    continue;\n                };\n\n                let margin_label = multi_labels\n                    .iter()\n                    .enumerate()\n                    .filter_map(|(_i, label)| {\n                        let is_start = line.range().contains(&label.span.start);\n                        let is_end = line.range().contains(&label.last_offset());\n                        if is_start {\n                            // TODO: Check to see whether multi is the first on the start line or first on the end line\n                            Some(LineLabel {\n                                column: label.span.start - line.offset,\n                                label: **label,\n                                multi: true,\n                                draw_msg: false, // Multi-line spans don;t have their messages drawn at the start\n                            })\n                        }\n                        else if is_end {\n                            Some(LineLabel {\n                                column: label.last_offset() - line.offset,\n                                label: **label,\n                                multi: true,\n                                draw_msg: true, // Multi-line spans have their messages drawn at the end\n                            })\n                        }\n                        else {\n                            None\n                        }\n                    })\n                    .min_by_key(|ll| (ll.column, !ll.label.span.start));\n\n                // Generate a list of labels for this line, along with their label columns\n                let mut line_labels = multi_labels\n                    .iter()\n                    .enumerate()\n                    .filter_map(|(_i, label)| {\n                        let is_start = line.range().contains(&label.span.start);\n                        let is_end = line.range().contains(&label.last_offset());\n                        if is_start && margin_label.as_ref().map_or(true, |m| **label as *const _ != m.label as *const _) {\n                            // TODO: Check to see whether multi is the first on the start line or first on the end line\n                            Some(LineLabel {\n                                column: label.span.start - line.offset,\n                                label: **label,\n                                multi: true,\n                                draw_msg: false, // Multi-line spans don;t have their messages drawn at the start\n                            })\n                        }\n                        else if is_end {\n                            Some(LineLabel {\n                                column: label.last_offset() - line.offset,\n                                label: **label,\n                                multi: true,\n                                draw_msg: true, // Multi-line spans have their messages drawn at the end\n                            })\n                        }\n                        else {\n                            None\n                        }\n                    })\n                    .collect::<Vec<_>>();\n\n                for label_info in\n                    labels.iter().filter(|l| l.label.span.start >= line.range().start && l.label.span.end <= line.range().end)\n                {\n                    if matches!(label_info.kind, LabelKind::Inline) {\n                        line_labels.push(LineLabel {\n                            column: match &self.config.label_attach {\n                                LabelAttach::Start => label_info.label.span.start,\n                                LabelAttach::Middle => (label_info.label.span.start + label_info.label.span.end) / 2,\n                                LabelAttach::End => label_info.label.last_offset(),\n                            }\n                            .max(label_info.label.span.start)\n                                - line.offset,\n                            label: label_info.label,\n                            multi: false,\n                            draw_msg: true,\n                        });\n                    }\n                }\n\n                // Skip this line if we don't have labels for it\n                if line_labels.len() == 0 && margin_label.is_none() {\n                    let within_label = multi_labels.iter().any(|label| label.span.contains(line.range().start));\n                    if !is_ellipsis && within_label {\n                        is_ellipsis = true;\n                    }\n                    else {\n                        if !self.config.compact && !is_ellipsis {\n                            write_margin(&mut w, idx, false, is_ellipsis, false, None, &[], &None)?;\n                            write!(w, \"\\n\")?;\n                        }\n                        is_ellipsis = true;\n                        continue;\n                    }\n                }\n                else {\n                    is_ellipsis = false;\n                }\n\n                // Sort the labels by their columns\n                line_labels.sort_by_key(|ll| (ll.label.order, ll.column, !ll.label.span.start));\n\n                // Determine label bounds so we know where to put error messages\n                let arrow_end_space = if self.config.compact { 1 } else { 2 };\n                let arrow_len = line_labels\n                    .iter()\n                    .fold(0, |l, ll| if ll.multi { line.length } else { l.max(ll.label.span.end.saturating_sub(line.offset)) })\n                    + arrow_end_space;\n\n                // Should we draw a vertical bar as part of a label arrow on this line?\n                let get_vbar = |col, row| {\n                    line_labels\n                        .iter()\n                        // Only labels with notes get an arrow\n                        .enumerate()\n                        .filter(|(_, ll)| {\n                            ll.label.msg.is_some()\n                                && margin_label.as_ref().map_or(true, |m| ll.label as *const _ != m.label as *const _)\n                        })\n                        .find(|(j, ll)| ll.column == col && ((row <= *j && !ll.multi) || (row <= *j && ll.multi)))\n                        .map(|(_, ll)| ll)\n                };\n\n                let get_highlight = |col: u32| {\n                    margin_label\n                        .iter()\n                        .map(|ll| ll.label)\n                        .chain(multi_labels.iter().map(|l| **l))\n                        .chain(line_labels.iter().map(|l| l.label))\n                        .filter(|l| l.span.contains(line.offset + col))\n                        // Prioritise displaying smaller spans\n                        .min_by_key(|l| (-l.priority, l.span.length()))\n                };\n\n                let get_underline = |col| {\n                    line_labels\n                        .iter()\n                        .filter(|ll| {\n                            self.config.underlines\n                                // Underlines only occur for inline spans (highlighting can occur for all spans)\n                                && !ll.multi\n                                && ll.label.span.contains(line.offset + col)\n                        })\n                        // Prioritise displaying smaller spans\n                        .min_by_key(|ll| (-ll.label.priority, ll.label.span.length()))\n                };\n\n                // Margin\n                write_margin(&mut w, idx, true, is_ellipsis, true, None, &line_labels, &margin_label)?;\n\n                // Line\n                if !is_ellipsis {\n                    for (col, c) in line.chars().enumerate() {\n                        let color = if let Some(highlight) = get_highlight(col as u32) {\n                            highlight.color\n                        }\n                        else {\n                            self.config.unimportant_color()\n                        };\n                        let (c, width) = self.config.char_width(c, col);\n                        if c.is_whitespace() {\n                            for _ in 0..width {\n                                write!(w, \"{}\", c.fg(color, s))?;\n                            }\n                        }\n                        else {\n                            write!(w, \"{}\", c.fg(color, s))?;\n                        };\n                    }\n                }\n                write!(w, \"\\n\")?;\n\n                // Arrows\n                for row in 0..line_labels.len() {\n                    let line_label = &line_labels[row];\n\n                    if !self.config.compact {\n                        // Margin alternate\n                        write_margin(&mut w, idx, false, is_ellipsis, true, Some((row, false)), &line_labels, &margin_label)?;\n                        // Lines alternate\n                        let mut chars = line.chars();\n                        for col in 0..arrow_len {\n                            let width = chars.next().map_or(1, |c| self.config.char_width(c, col as usize).1);\n\n                            let vbar = get_vbar(col, row);\n                            let underline = get_underline(col).filter(|_| row == 0);\n                            let [c, tail] = if let Some(vbar_ll) = vbar {\n                                let [c, tail] = if underline.is_some() {\n                                    // TODO: Is this good?\n                                    if vbar_ll.label.span.length() <= 1 || true {\n                                        [draw.underbar, draw.underline]\n                                    }\n                                    else if line.offset + col == vbar_ll.label.span.start {\n                                        [draw.ltop, draw.underbar]\n                                    }\n                                    else if line.offset + col == vbar_ll.label.last_offset() {\n                                        [draw.rtop, draw.underbar]\n                                    }\n                                    else {\n                                        [draw.underbar, draw.underline]\n                                    }\n                                }\n                                else if vbar_ll.multi && row == 0 && self.config.multiline_arrows {\n                                    [draw.uarrow, ' ']\n                                }\n                                else {\n                                    [draw.vbar, ' ']\n                                };\n                                [c.fg(vbar_ll.label.color, s), tail.fg(vbar_ll.label.color, s)]\n                            }\n                            else if let Some(underline_ll) = underline {\n                                [draw.underline.fg(underline_ll.label.color, s); 2]\n                            }\n                            else {\n                                [' '.fg(None, s); 2]\n                            };\n\n                            for i in 0..width {\n                                write!(w, \"{}\", if i == 0 { c } else { tail })?;\n                            }\n                        }\n                        write!(w, \"\\n\")?;\n                    }\n\n                    // Margin\n                    write_margin(&mut w, idx, false, is_ellipsis, true, Some((row, true)), &line_labels, &margin_label)?;\n                    // Lines\n                    let mut chars = line.chars();\n                    for col in 0..arrow_len {\n                        let width = chars.next().map_or(1, |c| self.config.char_width(c, col as usize).1);\n\n                        let is_hbar = (((col > line_label.column) ^ line_label.multi)\n                            || (line_label.label.msg.is_some() && line_label.draw_msg && col > line_label.column))\n                            && line_label.label.msg.is_some();\n                        let [c, tail] = if col == line_label.column\n                            && line_label.label.msg.is_some()\n                            && margin_label.as_ref().map_or(true, |m| line_label.label as *const _ != m.label as *const _)\n                        {\n                            [\n                                if line_label.multi {\n                                    if line_label.draw_msg { draw.mbot } else { draw.rbot }\n                                }\n                                else {\n                                    draw.lbot\n                                }\n                                .fg(line_label.label.color, s),\n                                draw.hbar.fg(line_label.label.color, s),\n                            ]\n                        }\n                        else if let Some(vbar_ll) =\n                            get_vbar(col, row).filter(|_| (col != line_label.column || line_label.label.msg.is_some()))\n                        {\n                            if !self.config.cross_gap && is_hbar {\n                                [draw.xbar.fg(line_label.label.color, s), ' '.fg(line_label.label.color, s)]\n                            }\n                            else if is_hbar {\n                                [draw.hbar.fg(line_label.label.color, s); 2]\n                            }\n                            else {\n                                [\n                                    if vbar_ll.multi && row == 0 && self.config.compact { draw.uarrow } else { draw.vbar }\n                                        .fg(vbar_ll.label.color, s),\n                                    ' '.fg(line_label.label.color, s),\n                                ]\n                            }\n                        }\n                        else if is_hbar {\n                            [draw.hbar.fg(line_label.label.color, s); 2]\n                        }\n                        else {\n                            [' '.fg(None, s); 2]\n                        };\n\n                        if width > 0 {\n                            write!(w, \"{}\", c)?;\n                        }\n                        for _ in 1..width {\n                            write!(w, \"{}\", tail)?;\n                        }\n                    }\n                    if line_label.draw_msg {\n                        write!(w, \" {}\", Show(line_label.label.msg.as_ref()))?;\n                    }\n                    write!(w, \"\\n\")?;\n                }\n            }\n\n            let is_final_group = group_idx + 1 == groups_len;\n\n            // Help\n            if let (Some(note), true) = (&self.help, is_final_group) {\n                if !self.config.compact {\n                    write_margin(&mut w, 0, false, false, true, Some((0, false)), &[], &None)?;\n                    write!(w, \"\\n\")?;\n                }\n                write_margin(&mut w, 0, false, false, true, Some((0, false)), &[], &None)?;\n                write!(w, \"{}: {}\\n\", \"Help\".fg(self.config.note_color(), s), note)?;\n            }\n\n            // Note\n            if let (Some(note), true) = (&self.note, is_final_group) {\n                if !self.config.compact {\n                    write_margin(&mut w, 0, false, false, true, Some((0, false)), &[], &None)?;\n                    write!(w, \"\\n\")?;\n                }\n                write_margin(&mut w, 0, false, false, true, Some((0, false)), &[], &None)?;\n                write!(w, \"{}: {}\\n\", \"Note\".fg(self.config.note_color(), s), note)?;\n            }\n\n            // Tail of report\n            if !self.config.compact {\n                if is_final_group {\n                    let final_margin = format!(\"{}{}\", Show((draw.hbar, line_no_width + 2)), draw.rbot);\n                    writeln!(w, \"{}\", final_margin.fg(self.config.margin_color(), s))?;\n                }\n                else {\n                    writeln!(w, \"{}{}\", Show((' ', line_no_width + 2)), draw.vbar.fg(self.config.margin_color(), s))?;\n                }\n            }\n        }\n        Ok(())\n    }"
}