{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `desugar::Desugarer::perform_desugar`",
    "file": "erg_parser-0.6.53-nightly.5/desugar.rs",
    "start_line": 147,
    "start_col": 5,
    "end_line": 441,
    "end_col": 6,
    "code_snippet": "fn perform_desugar(mut desugar: impl FnMut(Expr) -> Expr, expr: Expr) -> Expr {\n        match expr {\n            Expr::Literal(_) => expr,\n            Expr::Record(record) => match record {\n                Record::Normal(rec) => {\n                    let mut new_attrs = vec![];\n                    for attr in rec.attrs {\n                        new_attrs.push(enum_unwrap!(desugar(Expr::Def(attr)), Expr::Def));\n                    }\n                    Expr::Record(Record::Normal(NormalRecord::new(\n                        rec.l_brace,\n                        rec.r_brace,\n                        RecordAttrs::new(new_attrs),\n                    )))\n                }\n                Record::Mixed(mixed) => {\n                    let mut new_attrs = vec![];\n                    for attr in mixed.attrs {\n                        match attr {\n                            RecordAttrOrIdent::Attr(attr) => {\n                                let attr = RecordAttrOrIdent::Attr(enum_unwrap!(\n                                    desugar(Expr::Def(attr)),\n                                    Expr::Def\n                                ));\n                                new_attrs.push(attr);\n                            }\n                            RecordAttrOrIdent::Ident(ident) => {\n                                new_attrs.push(RecordAttrOrIdent::Ident(ident));\n                            }\n                        }\n                    }\n                    Expr::Record(Record::Mixed(MixedRecord::new(\n                        mixed.l_brace,\n                        mixed.r_brace,\n                        new_attrs,\n                    )))\n                }\n            },\n            Expr::DataPack(pack) => {\n                let class = desugar(*pack.class);\n                let Expr::Record(args) = desugar(Expr::Record(pack.args)) else {\n                    unreachable!()\n                };\n                Expr::DataPack(DataPack::new(class, pack.connector, args))\n            }\n            Expr::List(list) => match list {\n                List::Normal(lis) => {\n                    let (elems, ..) = lis.elems.deconstruct();\n                    let elems = elems\n                        .into_iter()\n                        .map(|elem| PosArg::new(desugar(elem.expr)))\n                        .collect();\n                    let elems = Args::pos_only(elems, None);\n                    let lis = NormalList::new(lis.l_sqbr, lis.r_sqbr, elems);\n                    Expr::List(List::Normal(lis))\n                }\n                List::WithLength(lis) => {\n                    let elem = PosArg::new(desugar(lis.elem.expr));\n                    let len = desugar(*lis.len);\n                    let lis = ListWithLength::new(lis.l_sqbr, lis.r_sqbr, elem, len);\n                    Expr::List(List::WithLength(lis))\n                }\n                List::Comprehension(lis) => {\n                    let layout = lis.layout.map(|ex| desugar(*ex));\n                    let generators = lis\n                        .generators\n                        .into_iter()\n                        .map(|(ident, gen)| (ident, desugar(gen)))\n                        .collect();\n                    let guard = lis.guard.map(|ex| desugar(*ex));\n                    let lis =\n                        ListComprehension::new(lis.l_sqbr, lis.r_sqbr, layout, generators, guard);\n                    Expr::List(List::Comprehension(lis))\n                }\n            },\n            Expr::Tuple(tuple) => match tuple {\n                Tuple::Normal(tup) => {\n                    let (elems, _, _, _, paren) = tup.elems.deconstruct();\n                    let elems = elems\n                        .into_iter()\n                        .map(|elem| PosArg::new(desugar(elem.expr)))\n                        .collect();\n                    let new_tup = Args::pos_only(elems, paren);\n                    let tup = NormalTuple::new(new_tup);\n                    Expr::Tuple(Tuple::Normal(tup))\n                }\n            },\n            Expr::Set(set) => match set {\n                astSet::Normal(set) => {\n                    let (elems, ..) = set.elems.deconstruct();\n                    let elems = elems\n                        .into_iter()\n                        .map(|elem| PosArg::new(desugar(elem.expr)))\n                        .collect();\n                    let elems = Args::pos_only(elems, None);\n                    let set = NormalSet::new(set.l_brace, set.r_brace, elems);\n                    Expr::Set(astSet::Normal(set))\n                }\n                astSet::WithLength(set) => {\n                    let elem = PosArg::new(desugar(set.elem.expr));\n                    let len = desugar(*set.len);\n                    let set = SetWithLength::new(set.l_brace, set.r_brace, elem, len);\n                    Expr::Set(astSet::WithLength(set))\n                }\n                astSet::Comprehension(set) => {\n                    let elem = set.layout.map(|ex| desugar(*ex));\n                    let mut new_generators = vec![];\n                    for (ident, gen) in set.generators.into_iter() {\n                        new_generators.push((ident, desugar(gen)));\n                    }\n                    let new_guard = set.guard.map(|ex| desugar(*ex));\n                    let set = SetComprehension::new(\n                        set.l_brace,\n                        set.r_brace,\n                        elem,\n                        new_generators,\n                        new_guard,\n                    );\n                    Expr::Set(astSet::Comprehension(set))\n                }\n            },\n            Expr::Dict(dict) => match dict {\n                Dict::Normal(dic) => {\n                    let new_kvs = dic\n                        .kvs\n                        .into_iter()\n                        .map(|elem| {\n                            let key = desugar(elem.key);\n                            let value = desugar(elem.value);\n                            KeyValue::new(key, value)\n                        })\n                        .collect();\n                    let tup = NormalDict::new(dic.l_brace, dic.r_brace, new_kvs);\n                    Expr::Dict(Dict::Normal(tup))\n                }\n                Dict::Comprehension(dic) => {\n                    let key = desugar(dic.kv.key);\n                    let value = desugar(dic.kv.value);\n                    let mut new_generators = vec![];\n                    for (ident, gen) in dic.generators.into_iter() {\n                        new_generators.push((ident, desugar(gen)));\n                    }\n                    let new_guard = dic.guard.map(|ex| desugar(*ex));\n                    let dic = DictComprehension::new(\n                        dic.l_brace,\n                        dic.r_brace,\n                        KeyValue::new(key, value),\n                        new_generators,\n                        new_guard,\n                    );\n                    Expr::Dict(Dict::Comprehension(dic))\n                }\n            },\n            Expr::BinOp(binop) => {\n                let mut args = binop.args.into_iter();\n                let lhs = desugar(*args.next().unwrap());\n                let rhs = desugar(*args.next().unwrap());\n                Expr::BinOp(BinOp::new(binop.op, lhs, rhs))\n            }\n            Expr::UnaryOp(unaryop) => {\n                let mut args = unaryop.args.into_iter();\n                let expr = desugar(*args.next().unwrap());\n                Expr::UnaryOp(UnaryOp::new(unaryop.op, expr))\n            }\n            Expr::Call(call) => {\n                let obj = desugar(*call.obj);\n                let args = Self::desugar_args(desugar, call.args);\n                Expr::Call(Call::new(obj, call.attr_name, args))\n            }\n            Expr::Def(mut def) => {\n                let mut chunks = vec![];\n                for chunk in def.body.block.into_iter() {\n                    chunks.push(desugar(chunk));\n                }\n                if let Some(t_op) = def.sig.t_spec_op_mut() {\n                    *t_op.t_spec_as_expr = desugar(*t_op.t_spec_as_expr.clone());\n                }\n                if let Signature::Subr(mut subr) = def.sig {\n                    subr.params = Self::perform_desugar_params(desugar, subr.params);\n                    def.sig = Signature::Subr(subr);\n                }\n                let body = DefBody::new(def.body.op, Block::new(chunks), def.body.id);\n                Expr::Def(Def::new(def.sig, body))\n            }\n            Expr::ClassDef(class_def) => {\n                let Expr::Def(def) = desugar(Expr::Def(class_def.def)) else {\n                    unreachable!()\n                };\n                let methods = class_def\n                    .methods_list\n                    .into_iter()\n                    .map(|method| enum_unwrap!(desugar(Expr::Methods(method)), Expr::Methods))\n                    .collect();\n                Expr::ClassDef(ClassDef::new(def, methods))\n            }\n            Expr::PatchDef(class_def) => {\n                let Expr::Def(def) = desugar(Expr::Def(class_def.def)) else {\n                    unreachable!()\n                };\n                let methods = class_def\n                    .methods_list\n                    .into_iter()\n                    .map(|method| enum_unwrap!(desugar(Expr::Methods(method)), Expr::Methods))\n                    .collect();\n                Expr::PatchDef(PatchDef::new(def, methods))\n            }\n            Expr::ReDef(mut redef) => {\n                let expr = desugar(*redef.expr);\n                if let Some(t_op) = &mut redef.t_spec {\n                    *t_op.t_spec_as_expr = desugar(*t_op.t_spec_as_expr.clone());\n                }\n                let attr = Self::perform_desugar_acc(desugar, redef.attr);\n                Expr::ReDef(ReDef::new(attr, redef.t_spec.map(|x| *x), expr))\n            }\n            Expr::Lambda(mut lambda) => {\n                let mut chunks = vec![];\n                for chunk in lambda.body.into_iter() {\n                    chunks.push(desugar(chunk));\n                }\n                if let Some(t_op) = &mut lambda.sig.return_t_spec {\n                    *t_op.t_spec_as_expr = desugar(*t_op.t_spec_as_expr.clone());\n                }\n                lambda.sig.params = Self::perform_desugar_params(desugar, lambda.sig.params);\n                let body = Block::new(chunks);\n                Expr::Lambda(Lambda::new(lambda.sig, lambda.op, body, lambda.id))\n            }\n            Expr::TypeAscription(tasc) => {\n                let expr = desugar(*tasc.expr);\n                let t_spec_as_expr = desugar(*tasc.t_spec.t_spec_as_expr);\n                let t_spec =\n                    TypeSpecWithOp::new(tasc.t_spec.op, tasc.t_spec.t_spec, t_spec_as_expr);\n                expr.type_asc_expr(t_spec)\n            }\n            Expr::Methods(method_defs) => {\n                let mut new_attrs = vec![];\n                for attr in method_defs.attrs.into_iter() {\n                    match attr {\n                        ClassAttr::Def(def) => {\n                            let mut chunks = vec![];\n                            for chunk in def.body.block.into_iter() {\n                                chunks.push(desugar(chunk));\n                            }\n                            let body = DefBody::new(def.body.op, Block::new(chunks), def.body.id);\n                            new_attrs.push(ClassAttr::Def(Def::new(def.sig, body)));\n                        }\n                        ClassAttr::Decl(decl) => {\n                            let expr = desugar(*decl.expr);\n                            let t_spec_as_expr = desugar(*decl.t_spec.t_spec_as_expr);\n                            let t_spec = TypeSpecWithOp::new(\n                                decl.t_spec.op,\n                                decl.t_spec.t_spec,\n                                t_spec_as_expr,\n                            );\n                            new_attrs.push(ClassAttr::Decl(expr.type_asc(t_spec)));\n                        }\n                        ClassAttr::Doc(doc) => {\n                            new_attrs.push(ClassAttr::Doc(doc));\n                        }\n                    }\n                }\n                let new_attrs = ClassAttrs::from(new_attrs);\n                Expr::Methods(Methods::new(\n                    method_defs.id,\n                    method_defs.class,\n                    *method_defs.class_as_expr,\n                    method_defs.vis,\n                    new_attrs,\n                ))\n            }\n            Expr::Accessor(acc) => Expr::Accessor(Self::perform_desugar_acc(desugar, acc)),\n            Expr::Compound(exprs) => {\n                let mut chunks = vec![];\n                for chunk in exprs.into_iter() {\n                    chunks.push(desugar(chunk));\n                }\n                Expr::Compound(Compound::new(chunks))\n            }\n            Expr::InlineModule(inline) => {\n                let mut chunks = vec![];\n                for chunk in inline.ast.module.into_iter() {\n                    chunks.push(desugar(chunk));\n                }\n                let ast = AST::new(inline.ast.name, Module::new(chunks));\n                Expr::InlineModule(InlineModule::new(inline.input, ast, inline.import))\n            }\n            Expr::Dummy(exprs) => {\n                let loc = exprs.loc;\n                let mut chunks = vec![];\n                for chunk in exprs.into_iter() {\n                    chunks.push(desugar(chunk));\n                }\n                Expr::Dummy(Dummy::new(loc, chunks))\n            }\n        }\n    }"
}