{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `glm::<impl linfa::prelude::Fit<ndarray::ArrayBase<D, ndarray::Dim<[usize; 2]>>, T, error::LinearError<F>> for glm::hyperparams::TweedieRegressorValidParams<F>>::fit`",
    "file": "linfa-linear-0.7.1/src/glm/mod.rs",
    "start_line": 48,
    "start_col": 5,
    "end_line": 106,
    "end_col": 6,
    "code_snippet": "fn fit(&self, ds: &DatasetBase<ArrayBase<D, Ix2>, T>) -> Result<Self::Object, F> {\n        let (x, y) = (ds.records(), ds.as_single_targets());\n\n        let dist = TweedieDistribution::new(self.power())?;\n        let link = self.link();\n\n        // If link is not set we automatically select an appropriate\n        // link function\n\n        if !dist.in_range(&y) {\n            // An error is sent when y has values in the range not applicable\n            // for the distribution\n            return Err(LinearError::InvalidTargetRange(self.power()));\n        }\n        // We initialize the coefficients and intercept\n        let mut coef = Array::zeros(x.ncols());\n        if self.fit_intercept() {\n            let temp = link.link(&array![y.mean().unwrap()]);\n            coef = concatenate!(Axis(0), temp, coef);\n        }\n\n        // Constructing a struct that satisfies the requirements of the L-BFGS solver\n        // with functions implemented for the objective function and the parameter\n        // gradient\n        let problem = TweedieProblem {\n            x: x.view(),\n            y,\n            fit_intercept: self.fit_intercept(),\n            link: &link,\n            dist,\n            alpha: self.alpha(),\n        };\n        let linesearch = MoreThuenteLineSearch::new();\n\n        // L-BFGS maintains a history of the past m updates of the\n        // position x and gradient \u2207f(x), where generally the history\n        // size m can be small (often m < 10)\n        // For our problem we set m as 7\n        let solver = LBFGS::new(linesearch, 7).with_tolerance_grad(F::cast(self.tol()))?;\n\n        let mut result = Executor::new(problem, solver)\n            .configure(|state| state.param(coef).max_iters(self.max_iter() as u64))\n            .run()?;\n        coef = result.state.take_best_param().unwrap();\n\n        if self.fit_intercept() {\n            Ok(TweedieRegressor {\n                coef: coef.slice(s![1..]).to_owned(),\n                intercept: *coef.get(0).unwrap(),\n                link,\n            })\n        } else {\n            Ok(TweedieRegressor {\n                coef: coef.to_owned(),\n                intercept: F::cast(0.),\n                link,\n            })\n        }\n    }"
}