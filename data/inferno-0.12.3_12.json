{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `flamegraph::from_lines`",
    "file": "inferno-0.12.3/src/flamegraph/mod.rs",
    "start_line": 396,
    "start_col": 1,
    "end_line": 743,
    "end_col": 2,
    "code_snippet": "pub fn from_lines<'a, I, W>(opt: &mut Options<'_>, lines: I, writer: W) -> io::Result<()>\nwhere\n    I: IntoIterator<Item = &'a str>,\n    W: Write,\n{\n    let mut reversed = StrStack::new();\n    let lines = lines\n        .into_iter()\n        .map(|line| line.trim())\n        .filter(|line| !(line.is_empty() || line.starts_with(\"# \")));\n\n    let (mut frames, time, ignored, delta_max) = if opt.reverse_stack_order {\n        if opt.no_sort {\n            warn!(\n                \"Input lines are always sorted when `reverse_stack_order` is `true`. \\\n                 The `no_sort` option is being ignored.\"\n            );\n        }\n        // Reverse order of stacks and sort.\n        let mut stack = String::new();\n        for line in lines {\n            stack.clear();\n            let samples_idx = merge::rfind_samples(line)\n                .map(|(i, _)| i)\n                .unwrap_or_else(|| line.len());\n            let samples_idx = merge::rfind_samples(&line[..samples_idx - 1])\n                .map(|(i, _)| i)\n                .unwrap_or(samples_idx);\n            for (i, func) in line[..samples_idx].trim().split(';').rev().enumerate() {\n                if i != 0 {\n                    stack.push(';');\n                }\n                stack.push_str(func);\n            }\n            stack.push(' ');\n            stack.push_str(&line[samples_idx..]);\n            // Trim to handle the case where functions names internally contain `;`.\n            // This can happen, for example, with types like `[u8; 8]` in Rust.\n            // See https://github.com/jonhoo/inferno/pull/338.\n            let stack = stack.trim();\n            reversed.push(stack);\n        }\n        let mut reversed: Vec<&str> = reversed.iter().collect();\n        reversed.sort_unstable();\n        merge::frames(reversed, false)?\n    } else if opt.flame_chart {\n        // In flame chart mode, just reverse the data so time moves from left to right.\n        let mut lines: Vec<&str> = lines.into_iter().collect();\n        lines.reverse();\n        merge::frames(lines, true)?\n    } else if opt.no_sort {\n        // Lines don't need sorting.\n        merge::frames(lines, false)?\n    } else {\n        // Sort lines by default.\n        let mut lines: Vec<&str> = if opt.base.is_empty() {\n            lines.into_iter().collect()\n        } else {\n            lines\n                .into_iter()\n                .filter_map(|line| {\n                    let mut cursor = line.len();\n                    for symbol in line.rsplit(';') {\n                        cursor -= symbol.len();\n                        if opt.base.iter().any(|b| b == symbol) {\n                            break;\n                        }\n                        cursor = cursor.saturating_sub(1);\n                    }\n                    if cursor == 0 {\n                        None\n                    } else {\n                        Some(&line[cursor..])\n                    }\n                })\n                .collect()\n        };\n        lines.sort_unstable();\n        merge::frames(lines, false)?\n    };\n\n    if ignored != 0 {\n        warn!(\"Ignored {} lines with invalid format\", ignored);\n    }\n\n    let mut buffer = StrStack::new();\n\n    // let's start writing the svg!\n    let mut svg = if opt.pretty_xml {\n        Writer::new_with_indent(writer, b' ', 4)\n    } else {\n        Writer::new(writer)\n    };\n\n    if time == 0 {\n        error!(\"No stack counts found\");\n        // emit an error message SVG, for tools automating flamegraph use\n        let imageheight = opt.font_size * 5;\n        svg::write_header(&mut svg, imageheight, opt)?;\n        svg::write_str(\n            &mut svg,\n            &mut buffer,\n            svg::TextItem {\n                x: Dimension::Percent(50.0),\n                y: (opt.font_size * 2) as f64,\n                text: \"ERROR: No valid input provided to flamegraph\".into(),\n                extra: None,\n            },\n        )?;\n        svg.write_event(Event::End(BytesEnd::new(\"svg\")))?;\n        svg.write_event(Event::Eof)?;\n        return Err(io::Error::new(\n            io::ErrorKind::InvalidData,\n            \"No stack counts found\",\n        ));\n    }\n\n    let image_width = opt.image_width.unwrap_or(DEFAULT_IMAGE_WIDTH) as f64;\n    let timemax = time;\n    let widthpertime_pct = 100.0 / timemax as f64;\n    let minwidth_time = opt.min_width / widthpertime_pct;\n\n    // prune blocks that are too narrow\n    let mut depthmax = 0;\n    frames.retain(|frame| {\n        if ((frame.end_time - frame.start_time) as f64) < minwidth_time {\n            false\n        } else {\n            depthmax = std::cmp::max(depthmax, frame.location.depth);\n            true\n        }\n    });\n\n    // draw canvas, and embed interactive JavaScript program\n    let imageheight = ((depthmax + 1) * opt.frame_height) + opt.ypad1() + opt.ypad2();\n    svg::write_header(&mut svg, imageheight, opt)?;\n\n    let (bgcolor1, bgcolor2) = color::bgcolor_for(opt.bgcolors, opt.colors);\n    let strokecolor = match opt.stroke_color {\n        StrokeColor::Color(c) => Some(c.to_string()),\n        StrokeColor::None => None,\n    };\n    let uicolor = opt.uicolor.to_string();\n    let style_options = StyleOptions {\n        imageheight,\n        bgcolor1,\n        bgcolor2,\n        uicolor,\n        strokecolor,\n    };\n\n    svg::write_prelude(&mut svg, &style_options, opt)?;\n\n    // Used when picking color parameters at random, when no option determines how to pick these\n    // parameters. We instantiate it here because it may be called once for each iteration in the\n    // frames loop.\n    let mut thread_rng = rand::thread_rng();\n\n    // structs to reuse across loops to avoid allocations\n    let mut cache_g = Event::Start(BytesStart::new(\"g\"));\n    let mut cache_a = Event::Start(BytesStart::new(\"a\"));\n    let mut cache_rect = Event::Empty(BytesStart::new(\"rect\"));\n    let cache_g_end = Event::End(BytesEnd::new(\"g\"));\n    let cache_a_end = Event::End(BytesEnd::new(\"a\"));\n\n    // create frames container\n    let container_x = format!(\"{}\", XPAD);\n    let container_width = format!(\"{}\", image_width as usize - XPAD - XPAD);\n    svg.write_event(Event::Start(BytesStart::new(\"svg\").with_attributes(vec![\n        (\"id\", \"frames\"),\n        (\"x\", &container_x),\n        (\"width\", &container_width),\n        (\"total_samples\", &format!(\"{}\", timemax)),\n    ])))?;\n\n    // draw frames\n    let mut samples_txt_buffer = num_format::Buffer::default();\n    for frame in frames {\n        let x1_pct = frame.start_time as f64 * widthpertime_pct;\n        let x2_pct = frame.end_time as f64 * widthpertime_pct;\n\n        let (y1, y2) = match opt.direction {\n            Direction::Straight => {\n                let y1 = imageheight - opt.ypad2() - (frame.location.depth + 1) * opt.frame_height\n                    + FRAMEPAD;\n                let y2 = imageheight - opt.ypad2() - frame.location.depth * opt.frame_height;\n                (y1, y2)\n            }\n            Direction::Inverted => {\n                let y1 = opt.ypad1() + frame.location.depth * opt.frame_height;\n                let y2 = opt.ypad1() + (frame.location.depth + 1) * opt.frame_height - FRAMEPAD;\n                (y1, y2)\n            }\n        };\n\n        let rect = Rectangle {\n            x1_pct,\n            x1_samples: frame.start_time,\n            y1,\n            x2_pct,\n            x2_samples: frame.end_time,\n            y2,\n        };\n\n        // The rounding here can differ from the Perl version when the fractional part is `0.5`.\n        // The Perl version does `my $samples = sprintf \"%.0f\", ($etime - $stime) * $factor;`,\n        // but this can format in strange ways as shown in these examples:\n        //     `sprintf \"%.0f\", 1.5` produces \"2\"\n        //     `sprintf \"%.0f\", 2.5` produces \"2\"\n        //     `sprintf \"%.0f\", 3.5` produces \"4\"\n        let samples = ((frame.end_time - frame.start_time) as f64 * opt.factor).round() as usize;\n\n        // add thousands separators to `samples`\n        let _ = samples_txt_buffer.write_formatted(&samples, &Locale::en);\n        let samples_txt = samples_txt_buffer.as_str();\n\n        let info = if frame.location.function.is_empty() && frame.location.depth == 0 {\n            write!(buffer, \"all ({} {}, 100%)\", samples_txt, opt.count_name)\n        } else {\n            let pct = (100 * samples) as f64 / (timemax as f64 * opt.factor);\n            let function = deannotate(frame.location.function);\n            match frame.delta {\n                None => write!(\n                    buffer,\n                    \"{} ({} {}, {:.2}%)\",\n                    function, samples_txt, opt.count_name, pct\n                ),\n                // Special case delta == 0 so we don't format percentage with a + sign.\n                Some(0) => write!(\n                    buffer,\n                    \"{} ({} {}, {:.2}%; 0.00%)\",\n                    function, samples_txt, opt.count_name, pct,\n                ),\n                Some(mut delta) => {\n                    if opt.negate_differentials {\n                        delta = -delta;\n                    }\n                    let delta_pct = (100 * delta) as f64 / (timemax as f64 * opt.factor);\n                    write!(\n                        buffer,\n                        \"{} ({} {}, {:.2}%; {:+.2}%)\",\n                        function, samples_txt, opt.count_name, pct, delta_pct\n                    )\n                }\n            }\n        };\n\n        let (has_href, title) = write_container_start(\n            opt,\n            &mut svg,\n            &mut cache_a,\n            &mut cache_g,\n            &frame,\n            &buffer[info],\n        )?;\n\n        svg.write_event(Event::Start(BytesStart::new(\"title\")))?;\n        svg.write_event(Event::Text(BytesText::new(title)))?;\n        svg.write_event(Event::End(BytesEnd::new(\"title\")))?;\n\n        // select the color of the rectangle\n        let color = if frame.location.function == \"--\" {\n            color::VDGREY\n        } else if frame.location.function == \"-\" {\n            color::DGREY\n        } else if opt.color_diffusion {\n            // We want to visually highlight high priority regions for\n            // optimization: wider frames are redder. Typically when optimizing,\n            // a frame that is 50% of width is high priority, so it seems wrong\n            // to give it half the saturation of 100%. So we use sqrt to make\n            // the red dropoff less linear.\n            color::color_scale((((x2_pct - x1_pct) / 100.0).sqrt() * 2000.0) as isize, 2000)\n        } else if let Some(mut delta) = frame.delta {\n            if opt.negate_differentials {\n                delta = -delta;\n            }\n            color::color_scale(delta, delta_max)\n        } else if let Some(ref mut palette_map) = opt.palette_map {\n            let colors = opt.colors;\n            let hash = opt.hash;\n            let deterministic = opt.deterministic;\n            palette_map.find_color_for(frame.location.function, |name| {\n                color::color(colors, hash, deterministic, name, &mut thread_rng)\n            })\n        } else {\n            color::color(\n                opt.colors,\n                opt.hash,\n                opt.deterministic,\n                frame.location.function,\n                &mut thread_rng,\n            )\n        };\n        filled_rectangle(&mut svg, &mut buffer, &rect, color, &mut cache_rect)?;\n\n        let fitchars = (rect.width_pct()\n            / (100.0 * opt.font_size as f64 * opt.font_width / image_width))\n            .trunc() as usize;\n        let text: svg::TextArgument<'_> = if fitchars >= 3 {\n            // room for one char plus two dots\n            let f = deannotate(frame.location.function);\n\n            // TODO: use Unicode grapheme clusters instead\n            if f.len() < fitchars {\n                // no need to truncate\n                f.into()\n            } else {\n                // need to truncate :'(\n                use std::fmt::Write;\n                let mut w = buffer.writer();\n                for c in f.chars().take(fitchars - 2) {\n                    w.write_char(c).expect(\"writing to buffer shouldn't fail\");\n                }\n                w.write_str(\"..\").expect(\"writing to buffer shouldn't fail\");\n                w.finish().into()\n            }\n        } else {\n            // don't show the function name\n            \"\".into()\n        };\n\n        // write the text\n        svg::write_str(\n            &mut svg,\n            &mut buffer,\n            svg::TextItem {\n                x: Dimension::Percent(rect.x1_pct + 100.0 * 3.0 / image_width),\n                y: 3.0 + (rect.y1 + rect.y2) as f64 / 2.0,\n                text,\n                extra: None,\n            },\n        )?;\n\n        buffer.clear();\n        if has_href {\n            svg.write_event(cache_a_end.borrow())?;\n        } else {\n            svg.write_event(cache_g_end.borrow())?;\n        }\n    }\n\n    svg.write_event(Event::End(BytesEnd::new(\"svg\")))?;\n    svg.write_event(Event::End(BytesEnd::new(\"svg\")))?;\n    svg.write_event(Event::Eof)?;\n\n    svg.into_inner().flush()?;\n    Ok(())\n}"
}