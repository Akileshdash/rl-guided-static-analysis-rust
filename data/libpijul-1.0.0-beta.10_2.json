{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `pristine::check_alive`",
    "file": "libpijul-1.0.0-beta.10/src/pristine/mod.rs",
    "start_line": 1123,
    "start_col": 1,
    "end_line": 1203,
    "end_col": 2,
    "code_snippet": "pub fn check_alive<T: ChannelTxnT + GraphIter>(\n    txn: &T,\n    channel: &T::Graph,\n) -> (\n    HashMap<Vertex<ChangeId>, Option<Vertex<ChangeId>>>,\n    Vec<(Vertex<ChangeId>, Option<Vertex<ChangeId>>)>,\n) {\n    // Find the reachable with a DFS.\n    let mut reachable = HashSet::default();\n    let mut stack = vec![Vertex::ROOT];\n    while let Some(v) = stack.pop() {\n        if !reachable.insert(v) {\n            continue;\n        }\n        for e in iter_adjacent(\n            txn,\n            &channel,\n            v,\n            EdgeFlags::empty(),\n            EdgeFlags::all() - EdgeFlags::DELETED - EdgeFlags::PARENT,\n        )\n        .unwrap()\n        {\n            let e = e.unwrap();\n            stack.push(*txn.find_block(&channel, e.dest()).unwrap());\n        }\n    }\n    debug!(\"reachable = {:#?}\", reachable);\n\n    // Find the alive\n    let mut alive_unreachable = HashMap::default();\n    let mut cursor = txn.graph_cursor(&channel, None).unwrap();\n\n    let mut visited = HashSet::default();\n    let mut k0 = Vertex::ROOT;\n    let mut k0_has_pseudo_parents = false;\n    let mut k0_has_regular_parents = false;\n    let mut reachable_pseudo = Vec::new();\n    while let Some(x) = txn.next_graph(&channel, &mut cursor) {\n        let (&k, &v) = x.unwrap();\n        debug!(\"check_alive, k = {:?}, v = {:?}\", k, v);\n        if k0 != k {\n            if k0_has_pseudo_parents && !k0_has_regular_parents {\n                reachable_pseudo.push((\n                    k0,\n                    find_file(txn, &channel, k0, &mut stack, &mut visited).unwrap(),\n                ))\n            }\n            k0 = k;\n            k0_has_pseudo_parents = false;\n            k0_has_regular_parents = false;\n        }\n        if v.flag().contains(EdgeFlags::PARENT)\n            && !v.flag().contains(EdgeFlags::FOLDER)\n            && !v.flag().contains(EdgeFlags::DELETED)\n        {\n            if v.flag().contains(EdgeFlags::PSEUDO) {\n                k0_has_pseudo_parents = true\n            } else {\n                k0_has_regular_parents = true\n            }\n        }\n\n        if v.flag().contains(EdgeFlags::PARENT)\n            && (v.flag().contains(EdgeFlags::BLOCK) || k.is_empty())\n            && !v.flag().contains(EdgeFlags::DELETED)\n            && !reachable.contains(&k)\n        {\n            let file = find_file(txn, &channel, k, &mut stack, &mut visited).unwrap();\n            alive_unreachable.insert(k, file);\n        }\n    }\n    if !k0.is_root() && k0_has_pseudo_parents && !k0_has_regular_parents {\n        reachable_pseudo.push((\n            k0,\n            find_file(txn, &channel, k0, &mut stack, &mut visited).unwrap(),\n        ));\n    }\n\n    (alive_unreachable, reachable_pseudo)\n}"
}