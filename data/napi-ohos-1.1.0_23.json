{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `bindgen_runtime::js_values::arraybuffer::ArrayBuffer::<'env>::from_external`",
    "file": "napi-ohos-1.1.0/src/bindgen_runtime/js_values/arraybuffer.rs",
    "start_line": 214,
    "start_col": 3,
    "end_line": 275,
    "end_col": 4,
    "code_snippet": "pub unsafe fn from_external<T: 'env, F: FnOnce(Env, T)>(\n    env: &Env,\n    data: *mut u8,\n    len: usize,\n    finalize_hint: T,\n    finalize_callback: F,\n  ) -> Result<Self> {\n    if data.is_null() || std::ptr::eq(data, crate::EMPTY_VEC.as_ptr()) {\n      return Err(Error::new(\n        Status::InvalidArg,\n        \"Borrowed data should not be null\".to_owned(),\n      ));\n    }\n    #[cfg(all(debug_assertions, not(windows)))]\n    {\n      let is_existed = super::BUFFER_DATA.with(|buffer_data| {\n        let buffer = buffer_data.lock().expect(\"Unlock buffer data failed\");\n        buffer.contains(&data)\n      });\n      if is_existed {\n        panic!(\"Share the same data between different buffers is not allowed, see: https://github.com/nodejs/node/issues/32463#issuecomment-631974747\");\n      }\n    }\n    let hint_ptr = Box::into_raw(Box::new((finalize_hint, finalize_callback)));\n    let mut arraybuffer_value = ptr::null_mut();\n    let mut status = unsafe {\n      sys::napi_create_external_arraybuffer(\n        env.0,\n        data.cast(),\n        len,\n        Some(crate::env::raw_finalize_with_custom_callback::<T, F>),\n        hint_ptr.cast(),\n        &mut arraybuffer_value,\n      )\n    };\n    status = if status == sys::Status::napi_no_external_buffers_allowed {\n      let (hint, finalize) = *Box::from_raw(hint_ptr);\n      let mut underlying_data = ptr::null_mut();\n      let status = unsafe {\n        sys::napi_create_arraybuffer(env.0, len, &mut underlying_data, &mut arraybuffer_value)\n      };\n      unsafe { std::ptr::copy_nonoverlapping(data.cast(), underlying_data, len) };\n      finalize(*env, hint);\n      status\n    } else {\n      status\n    };\n    check_status!(status, \"Failed to create arraybuffer from data\")?;\n\n    Ok(Self {\n      value: Value {\n        env: env.0,\n        value: arraybuffer_value,\n        value_type: ValueType::Object,\n      },\n      data: if len == 0 {\n        &[]\n      } else {\n        unsafe { std::slice::from_raw_parts(data.cast(), len) }\n      },\n    })\n  }"
}