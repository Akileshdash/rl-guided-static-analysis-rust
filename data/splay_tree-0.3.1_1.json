{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `tree_core::Tree::<K, V>::splay_by`",
    "file": "splay_tree-0.3.1/src/tree_core.rs",
    "start_line": 278,
    "start_col": 5,
    "end_line": 341,
    "end_col": 6,
    "code_snippet": "fn splay_by<F>(&mut self, mut curr_idx: NodeIndex, cmp: F) -> (NodeIndex, Ordering)\n    where\n        F: Fn(&K) -> Ordering,\n    {\n        use std::mem::replace;\n        let mut lft_root_idx = NULL_NODE;\n        let mut rgt_root_idx = NULL_NODE;\n        let mut curr_mut = unsafe { self.aliasable_node_mut(curr_idx) };\n        let mut order = cmp(curr_mut.key.borrow());\n        {\n            let mut lft_rgtmost_idx = &mut lft_root_idx;\n            let mut rgt_lftmost_idx = &mut rgt_root_idx;\n            loop {\n                let mut child_idx;\n                let mut child_mut;\n                match order {\n                    Ordering::Less if curr_mut.lft != NULL_NODE => {\n                        // zig\n                        child_idx = replace(&mut curr_mut.lft, NULL_NODE);\n                        child_mut = unsafe { self.aliasable_node_mut(child_idx) };\n                        order = cmp(child_mut.key.borrow());\n                        if Ordering::Less == order && child_mut.lft != NULL_NODE {\n                            // zig-zig\n                            let grand_child_idx = replace(&mut child_mut.lft, NULL_NODE);\n                            curr_mut.lft = replace(&mut child_mut.rgt, curr_idx);\n                            curr_idx = replace(&mut child_idx, grand_child_idx);\n                            curr_mut = replace(&mut child_mut, unsafe {\n                                self.aliasable_node_mut(grand_child_idx)\n                            });\n                            order = cmp(child_mut.key.borrow());\n                        }\n                        *rgt_lftmost_idx = curr_idx;\n                        rgt_lftmost_idx = unsafe { &mut *(&mut curr_mut.lft as *mut _) };\n                    }\n                    Ordering::Greater if curr_mut.rgt != NULL_NODE => {\n                        // zag\n                        child_idx = replace(&mut curr_mut.rgt, NULL_NODE);\n                        child_mut = unsafe { self.aliasable_node_mut(child_idx) };\n                        order = cmp(child_mut.key.borrow());\n                        if Ordering::Greater == order && child_mut.rgt != NULL_NODE {\n                            // zag-zag\n                            let grand_child_idx = replace(&mut child_mut.rgt, NULL_NODE);\n                            curr_mut.rgt = replace(&mut child_mut.lft, curr_idx);\n                            curr_idx = replace(&mut child_idx, grand_child_idx);\n                            curr_mut = replace(&mut child_mut, unsafe {\n                                self.aliasable_node_mut(grand_child_idx)\n                            });\n                            order = cmp(child_mut.key.borrow());\n                        }\n                        *lft_rgtmost_idx = curr_idx;\n                        lft_rgtmost_idx = unsafe { &mut *(&mut curr_mut.rgt as *mut _) };\n                    }\n                    _ => break,\n                }\n                curr_mut = child_mut;\n                curr_idx = child_idx;\n            }\n            *lft_rgtmost_idx = replace(&mut curr_mut.lft, NULL_NODE);\n            *rgt_lftmost_idx = replace(&mut curr_mut.rgt, NULL_NODE);\n        }\n        curr_mut.lft = lft_root_idx;\n        curr_mut.rgt = rgt_root_idx;\n        (curr_idx, order)\n    }"
}