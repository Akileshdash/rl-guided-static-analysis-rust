{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `packet::signature::config::SignatureConfig::sign_certification_third_party`",
    "file": "pgp-0.16.0/src/packet/signature/config.rs",
    "start_line": 235,
    "start_col": 5,
    "end_line": 308,
    "end_col": 6,
    "code_snippet": "pub fn sign_certification_third_party<P>(\n        self,\n        signer: &impl SecretKeyTrait,\n        signer_pw: &Password,\n        signee: &P,\n        tag: Tag,\n        id: &impl Serialize,\n    ) -> Result<Signature>\n    where\n        P: PublicKeyTrait + Serialize,\n    {\n        ensure!(\n            (self.version() == SignatureVersion::V4 && signer.version() == KeyVersion::V4)\n                || (self.version() == SignatureVersion::V6 && signer.version() == KeyVersion::V6),\n            \"signature version {:?} not allowed for signer key version {:?}\",\n            self.version(),\n            signer.version()\n        );\n        ensure!(\n            self.is_certification(),\n            \"can not sign non certification as certification\"\n        );\n\n        debug!(\"signing certification {:#?}\", self.typ);\n\n        let mut hasher = self.hash_alg.new_hasher()?;\n\n        if let SignatureVersionSpecific::V6 { salt } = &self.version_specific {\n            hasher.update(salt.as_ref())\n        }\n\n        serialize_for_hashing(signee, &mut hasher)?;\n\n        let mut packet_buf = Vec::new();\n        id.to_writer(&mut packet_buf)?;\n\n        match self.version() {\n            SignatureVersion::V2 | SignatureVersion::V3 => {\n                // Nothing to do\n            }\n            SignatureVersion::V4 | SignatureVersion::V6 => {\n                let prefix = match tag {\n                    Tag::UserId => 0xB4,\n                    Tag::UserAttribute => 0xD1,\n                    _ => bail!(\"invalid tag for certification signature: {:?}\", tag),\n                };\n\n                let mut prefix_buf = [prefix, 0u8, 0u8, 0u8, 0u8];\n                BigEndian::write_u32(&mut prefix_buf[1..], packet_buf.len().try_into()?);\n\n                // prefixes\n                hasher.update(&prefix_buf);\n            }\n            SignatureVersion::V5 => {\n                bail!(\"v5 signature unsupported sign tps\")\n            }\n            SignatureVersion::Other(version) => {\n                bail!(\"unsupported signature version {}\", version)\n            }\n        }\n\n        // the packet content\n        hasher.update(&packet_buf);\n\n        let len = self.hash_signature_data(&mut hasher)?;\n        hasher.update(&self.trailer(len)?);\n\n        let hash = &hasher.finalize()[..];\n\n        let signed_hash_value = [hash[0], hash[1]];\n        let signature = signer.create_signature(signer_pw, self.hash_alg, hash)?;\n\n        Signature::from_config(self, signed_hash_value, signature)\n    }"
}