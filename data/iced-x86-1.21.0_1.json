{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `formatter::fast::SpecializedFormatter::<TraitOptions>::format`",
    "file": "iced-x86-1.21.0/src/formatter/fast.rs",
    "start_line": 819,
    "start_col": 2,
    "end_line": 1511,
    "end_col": 3,
    "code_snippet": "pub fn format(&mut self, instruction: &Instruction, output: &mut String) {\n\t\t// SAFETY: We only append data that come from a `&str`, a `String` or ASCII chars so the data is always valid utf8\n\t\tlet dst = unsafe { output.as_mut_vec() };\n\t\t// The code assumes there's enough bytes (or it will panic) so reserve enough bytes here\n\t\tdst.reserve(MAX_FMT_INSTR_LEN);\n\t\t// SAFETY:\n\t\t// - ptr is in bounds (after last valid byte)\n\t\t// - it's reloaded when using 'dst' to write to the vector\n\t\tlet mut dst_next_p = unsafe { dst.as_mut_ptr().add(dst.len()) };\n\n\t\tlet code = instruction.code();\n\t\tlet mut mnemonic = self.d.code_mnemonics[code as usize];\n\t\tlet mut op_count = instruction.op_count();\n\t\tif TraitOptions::use_pseudo_ops(&self.d.options) {\n\t\t\tlet flags = self.d.code_flags[code as usize];\n\t\t\tlet pseudo_ops_num = flags >> FastFmtFlags::PSEUDO_OPS_KIND_SHIFT;\n\t\t\tif pseudo_ops_num != 0 && instruction.op_kind(op_count - 1) == OpKind::Immediate8 {\n\t\t\t\tlet mut index = instruction.immediate8() as usize;\n\t\t\t\t// SAFETY: the generator generates only valid values (1-based)\n\t\t\t\tlet pseudo_ops_kind: PseudoOpsKind = unsafe { mem::transmute(pseudo_ops_num - 1) };\n\t\t\t\t// Not enough bits to store all values so some are mapped to the same value. Fix that here.\n\t\t\t\tlet pseudo_ops_kind = if pseudo_ops_kind == PseudoOpsKind::vpcmpd6 {\n\t\t\t\t\tmatch code {\n\t\t\t\t\t\t#[cfg(feature = \"mvex\")]\n\t\t\t\t\t\tCode::MVEX_Vpcmpud_kr_k1_zmm_zmmmt_imm8 => PseudoOpsKind::vpcmpud6,\n\t\t\t\t\t\t_ => pseudo_ops_kind,\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpseudo_ops_kind\n\t\t\t\t};\n\t\t\t\tlet pseudo_ops = get_pseudo_ops(pseudo_ops_kind);\n\t\t\t\tif pseudo_ops_kind == PseudoOpsKind::pclmulqdq || pseudo_ops_kind == PseudoOpsKind::vpclmulqdq {\n\t\t\t\t\tif index <= 1 {\n\t\t\t\t\t\t// nothing\n\t\t\t\t\t} else if index == 0x10 {\n\t\t\t\t\t\tindex = 2;\n\t\t\t\t\t} else if index == 0x11 {\n\t\t\t\t\t\tindex = 3;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tindex = usize::MAX;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif let Some(&pseudo_op_mnemonic) = pseudo_ops.get(index) {\n\t\t\t\t\tmnemonic = pseudo_op_mnemonic;\n\t\t\t\t\top_count -= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet prefix_seg = instruction_internal::internal_segment_prefix_raw(instruction);\n\t\tconst _: () = assert!(Register::None as u32 == 0);\n\t\tif prefix_seg < 6 || instruction_internal::internal_has_any_of_lock_rep_repne_prefix(instruction) != 0 {\n\t\t\tconst DS_REG: u32 = Register::DS as u32 - Register::ES as u32;\n\t\t\tlet has_notrack_prefix = prefix_seg == DS_REG && is_notrack_prefix_branch(code);\n\t\t\tif !has_notrack_prefix && prefix_seg < 6 && SpecializedFormatter::<TraitOptions>::show_segment_prefix(instruction, op_count) {\n\t\t\t\tlet prefix_seg = unsafe { mem::transmute((Register::ES as u32 + prefix_seg) as RegisterUnderlyingType) };\n\t\t\t\tcall_format_register!(self, dst, dst_next_p, prefix_seg);\n\t\t\t\twrite_fast_ascii_char_lit!(dst, dst_next_p, ' ', true);\n\t\t\t}\n\n\t\t\tlet mut has_xacquire_xrelease = false;\n\t\t\tif instruction.has_xacquire_prefix() {\n\t\t\t\tconst FAST_STR: FastString12 = mk_const_fast_str!(FastString12, \"\\x09xacquire    \");\n\t\t\t\twrite_fast_str!(dst, dst_next_p, FastString12, FAST_STR);\n\t\t\t\thas_xacquire_xrelease = true;\n\t\t\t}\n\t\t\tif instruction.has_xrelease_prefix() {\n\t\t\t\tconst FAST_STR: FastString12 = mk_const_fast_str!(FastString12, \"\\x09xrelease    \");\n\t\t\t\twrite_fast_str!(dst, dst_next_p, FastString12, FAST_STR);\n\t\t\t\thas_xacquire_xrelease = true;\n\t\t\t}\n\t\t\tif instruction.has_lock_prefix() {\n\t\t\t\tconst FAST_STR: FastString8 = mk_const_fast_str!(FastString8, \"\\x05lock    \");\n\t\t\t\twrite_fast_str!(dst, dst_next_p, FastString8, FAST_STR);\n\t\t\t}\n\t\t\tif has_notrack_prefix {\n\t\t\t\tconst FAST_STR: FastString8 = mk_const_fast_str!(FastString8, \"\\x08notrack \");\n\t\t\t\twrite_fast_str!(dst, dst_next_p, FastString8, FAST_STR);\n\t\t\t}\n\t\t\tif !has_xacquire_xrelease {\n\t\t\t\tif instruction.has_repe_prefix()\n\t\t\t\t\t&& (SpecializedFormatter::<TraitOptions>::SHOW_USELESS_PREFIXES\n\t\t\t\t\t\t|| show_rep_or_repe_prefix_bool(code, SpecializedFormatter::<TraitOptions>::SHOW_USELESS_PREFIXES))\n\t\t\t\t{\n\t\t\t\t\tif is_repe_or_repne_instruction(code) {\n\t\t\t\t\t\tconst FAST_STR: FastString8 = mk_const_fast_str!(FastString8, \"\\x05repe    \");\n\t\t\t\t\t\twrite_fast_str!(dst, dst_next_p, FastString8, FAST_STR);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst FAST_STR: FastString4 = mk_const_fast_str!(FastString4, \"\\x04rep \");\n\t\t\t\t\t\twrite_fast_str!(dst, dst_next_p, FastString4, FAST_STR);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif instruction.has_repne_prefix() {\n\t\t\t\t\tif (Code::Retnw_imm16 <= code && code <= Code::Retnq)\n\t\t\t\t\t\t|| (Code::Call_rel16 <= code && code <= Code::Jmp_rel32_64)\n\t\t\t\t\t\t|| (Code::Call_rm16 <= code && code <= Code::Call_rm64)\n\t\t\t\t\t\t|| (Code::Jmp_rm16 <= code && code <= Code::Jmp_rm64)\n\t\t\t\t\t\t|| code.is_jcc_short_or_near()\n\t\t\t\t\t{\n\t\t\t\t\t\tconst FAST_STR: FastString4 = mk_const_fast_str!(FastString4, \"\\x04bnd \");\n\t\t\t\t\t\twrite_fast_str!(dst, dst_next_p, FastString4, FAST_STR);\n\t\t\t\t\t} else if SpecializedFormatter::<TraitOptions>::SHOW_USELESS_PREFIXES\n\t\t\t\t\t\t|| show_repne_prefix_bool(code, SpecializedFormatter::<TraitOptions>::SHOW_USELESS_PREFIXES)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst FAST_STR: FastString8 = mk_const_fast_str!(FastString8, \"\\x06repne   \");\n\t\t\t\t\t\twrite_fast_str!(dst, dst_next_p, FastString8, FAST_STR);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twrite_fast_str!(dst, dst_next_p, FastStringMnemonic, mnemonic);\n\n\t\tlet is_declare_data;\n\t\tlet declare_data_kind = if !TraitOptions::ENABLE_DB_DW_DD_DQ {\n\t\t\tis_declare_data = false;\n\t\t\tOpKind::Register\n\t\t} else if (code as u32).wrapping_sub(Code::DeclareByte as u32) <= (Code::DeclareQword as u32 - Code::DeclareByte as u32) {\n\t\t\top_count = instruction.declare_data_len() as u32;\n\t\t\tis_declare_data = true;\n\t\t\tmatch code {\n\t\t\t\tCode::DeclareByte => OpKind::Immediate8,\n\t\t\t\tCode::DeclareWord => OpKind::Immediate16,\n\t\t\t\tCode::DeclareDword => OpKind::Immediate32,\n\t\t\t\t_ => {\n\t\t\t\t\tdebug_assert_eq!(code, Code::DeclareQword);\n\t\t\t\t\tOpKind::Immediate64\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tis_declare_data = false;\n\t\t\tOpKind::Register\n\t\t};\n\n\t\tif op_count > 0 {\n\t\t\twrite_fast_ascii_char_lit!(dst, dst_next_p, ' ', true);\n\n\t\t\t#[cfg(feature = \"mvex\")]\n\t\t\tlet mvex_rm_operand = {\n\t\t\t\tif IcedConstants::is_mvex(instruction.code()) {\n\t\t\t\t\tdebug_assert_ne!(op_count, 0);\n\t\t\t\t\tif instruction.op_kind(op_count.wrapping_sub(1)) == OpKind::Immediate8 {\n\t\t\t\t\t\top_count.wrapping_sub(2)\n\t\t\t\t\t} else {\n\t\t\t\t\t\top_count.wrapping_sub(1)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tu32::MAX\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tlet mut operand = 0;\n\t\t\tloop {\n\t\t\t\tlet imm8;\n\t\t\t\tlet imm16;\n\t\t\t\tlet imm32;\n\t\t\t\tlet imm64;\n\t\t\t\tlet imm_size;\n\t\t\t\tlet op_kind = if TraitOptions::ENABLE_DB_DW_DD_DQ && is_declare_data { declare_data_kind } else { instruction.op_kind(operand) };\n\n\t\t\t\t// Share as much code as possible so put these in macros\n\t\t\t\tmacro_rules! fmt_near_branch {\n\t\t\t\t\t($slf:ident, $dst:ident, $dst_next_p:ident, $instruction:ident, $imm_size:expr, $imm:ident) => {{\n\t\t\t\t\t\tif TraitOptions::ENABLE_SYMBOL_RESOLVER {\n\t\t\t\t\t\t\t// PERF: Symbols should be rare when using fast fmt with a symbol resolver so clone\n\t\t\t\t\t\t\t// the symbol (forced by borrowck).\n\t\t\t\t\t\t\t// This results in slightly faster code when we do NOT support a symbol resolver since\n\t\t\t\t\t\t\t// we don't need to pass in the options to various methods and can instead pass in &Self\n\t\t\t\t\t\t\t// (i.e., use a method instead of a func).\n\t\t\t\t\t\t\tlet mut vec: Vec<SymResTextPart<'_>> = Vec::new();\n\t\t\t\t\t\t\tif let Some(ref symbol) = if let Some(ref mut symbol_resolver) = $slf.symbol_resolver {\n\t\t\t\t\t\t\t\tto_owned(symbol_resolver.symbol($instruction, operand, Some(operand), $imm, $imm_size), &mut vec)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tNone\n\t\t\t\t\t\t\t} {\n\t\t\t\t\t\t\t\tcall_write_symbol!($slf, $dst, $dst_next_p, $imm, symbol);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcall_format_number!($slf, $dst, $dst_next_p, $imm);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcall_format_number!($slf, $dst, $dst_next_p, $imm);\n\t\t\t\t\t\t}\n\t\t\t\t\t}};\n\t\t\t\t}\n\t\t\t\tmacro_rules! fmt_far_branch {\n\t\t\t\t\t($slf:ident, $dst:ident, $dst_next_p:ident, $instruction:ident, $op_kind:ident, $imm_size_ident:ident, $imm64:ident) => {{\n\t\t\t\t\t\tif $op_kind == OpKind::FarBranch32 {\n\t\t\t\t\t\t\t$imm_size_ident = 4;\n\t\t\t\t\t\t\t$imm64 = $instruction.far_branch32() as u64;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$imm_size_ident = 2;\n\t\t\t\t\t\t\t$imm64 = $instruction.far_branch16() as u64;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif TraitOptions::ENABLE_SYMBOL_RESOLVER {\n\t\t\t\t\t\t\t// See fmt_near_branch!() above for why we clone the symbols\n\t\t\t\t\t\t\tlet mut vec: Vec<SymResTextPart<'_>> = Vec::new();\n\t\t\t\t\t\t\tlet mut vec2: Vec<SymResTextPart<'_>> = Vec::new();\n\t\t\t\t\t\t\tif let Some(ref symbol) = if let Some(ref mut symbol_resolver) = $slf.symbol_resolver {\n\t\t\t\t\t\t\t\tto_owned(\n\t\t\t\t\t\t\t\t\tsymbol_resolver.symbol($instruction, operand, Some(operand), $imm64 as u32 as u64, $imm_size_ident),\n\t\t\t\t\t\t\t\t\t&mut vec,\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tNone\n\t\t\t\t\t\t\t} {\n\t\t\t\t\t\t\t\tdebug_assert!(operand + 1 == 1);\n\t\t\t\t\t\t\t\tlet selector_symbol = if let Some(ref mut symbol_resolver) = $slf.symbol_resolver {\n\t\t\t\t\t\t\t\t\tto_owned(\n\t\t\t\t\t\t\t\t\t\tsymbol_resolver.symbol(\n\t\t\t\t\t\t\t\t\t\t\t$instruction,\n\t\t\t\t\t\t\t\t\t\t\toperand + 1,\n\t\t\t\t\t\t\t\t\t\t\tSome(operand),\n\t\t\t\t\t\t\t\t\t\t\t$instruction.far_branch_selector() as u64,\n\t\t\t\t\t\t\t\t\t\t\t2,\n\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t&mut vec2,\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tNone\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tif let Some(ref selector_symbol) = selector_symbol {\n\t\t\t\t\t\t\t\t\tcall_write_symbol!($slf, $dst, $dst_next_p, $instruction.far_branch_selector() as u64, selector_symbol);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcall_format_number!($slf, $dst, $dst_next_p, $instruction.far_branch_selector() as u64);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twrite_fast_ascii_char_lit!(dst, dst_next_p, ':', true);\n\t\t\t\t\t\t\t\tcall_write_symbol!($slf, $dst, $dst_next_p, $imm64, symbol);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcall_format_number!($slf, $dst, $dst_next_p, $instruction.far_branch_selector() as u64);\n\t\t\t\t\t\t\t\twrite_fast_ascii_char_lit!(dst, dst_next_p, ':', true);\n\t\t\t\t\t\t\t\tcall_format_number!($slf, $dst, $dst_next_p, $imm64);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcall_format_number!($slf, $dst, $dst_next_p, $instruction.far_branch_selector() as u64);\n\t\t\t\t\t\t\twrite_fast_ascii_char_lit!(dst, dst_next_p, ':', true);\n\t\t\t\t\t\t\tcall_format_number!($slf, $dst, $dst_next_p, $imm64);\n\t\t\t\t\t\t}\n\t\t\t\t\t}};\n\t\t\t\t}\n\t\t\t\tmacro_rules! fmt_imm {\n\t\t\t\t\t($slf:ident, $dst:ident, $dst_next_p:ident, $instruction:ident, $imm:ident, $imm_size:literal) => {\n\t\t\t\t\t\t#[allow(trivial_numeric_casts)]\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif TraitOptions::ENABLE_SYMBOL_RESOLVER {\n\t\t\t\t\t\t\t\t// See fmt_near_branch!() above for why we clone the symbols\n\t\t\t\t\t\t\t\tlet mut vec: Vec<SymResTextPart<'_>> = Vec::new();\n\t\t\t\t\t\t\t\tif let Some(ref symbol) = if let Some(ref mut symbol_resolver) = $slf.symbol_resolver {\n\t\t\t\t\t\t\t\t\tto_owned(symbol_resolver.symbol($instruction, operand, Some(operand), $imm as u64, $imm_size), &mut vec)\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tNone\n\t\t\t\t\t\t\t\t} {\n\t\t\t\t\t\t\t\t\tif (symbol.flags & SymbolFlags::RELATIVE) == 0 {\n\t\t\t\t\t\t\t\t\t\tconst FAST_STR: FastString8 = mk_const_fast_str!(FastString8, \"\\x07offset  \");\n\t\t\t\t\t\t\t\t\t\twrite_fast_str!($dst, $dst_next_p, FastString8, FAST_STR);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcall_write_symbol!($slf, $dst, $dst_next_p, $imm as u64, symbol);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcall_format_number!($slf, $dst, $dst_next_p, $imm as u64);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcall_format_number!($slf, $dst, $dst_next_p, $imm as u64);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tmacro_rules! fmt_register {\n\t\t\t\t\t() => {{\n\t\t\t\t\t\tcall_format_register!(self, dst, dst_next_p, instruction_internal::internal_op_register(instruction, operand))\n\t\t\t\t\t}};\n\t\t\t\t}\n\t\t\t\tmacro_rules! fmt_far_br_16_32 {\n\t\t\t\t\t() => {{\n\t\t\t\t\t\tfmt_far_branch!(self, dst, dst_next_p, instruction, op_kind, imm_size, imm64)\n\t\t\t\t\t}};\n\t\t\t\t}\n\t\t\t\tmacro_rules! fmt_memory_seg_si {\n\t\t\t\t\t() => {{\n\t\t\t\t\t\tcall_format_memory!(\n\t\t\t\t\t\t\tself,\n\t\t\t\t\t\t\tdst,\n\t\t\t\t\t\t\tdst_next_p,\n\t\t\t\t\t\t\tinstruction,\n\t\t\t\t\t\t\toperand,\n\t\t\t\t\t\t\t(instruction.memory_segment()),\n\t\t\t\t\t\t\t(Register::SI),\n\t\t\t\t\t\t\t(Register::None),\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t2,\n\t\t\t\t\t\t)\n\t\t\t\t\t}};\n\t\t\t\t}\n\t\t\t\tmacro_rules! fmt_memory_seg_esi {\n\t\t\t\t\t() => {{\n\t\t\t\t\t\tcall_format_memory!(\n\t\t\t\t\t\t\tself,\n\t\t\t\t\t\t\tdst,\n\t\t\t\t\t\t\tdst_next_p,\n\t\t\t\t\t\t\tinstruction,\n\t\t\t\t\t\t\toperand,\n\t\t\t\t\t\t\t(instruction.memory_segment()),\n\t\t\t\t\t\t\t(Register::ESI),\n\t\t\t\t\t\t\t(Register::None),\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t4,\n\t\t\t\t\t\t)\n\t\t\t\t\t}};\n\t\t\t\t}\n\t\t\t\tmacro_rules! fmt_memory_seg_rsi {\n\t\t\t\t\t() => {{\n\t\t\t\t\t\tcall_format_memory!(\n\t\t\t\t\t\t\tself,\n\t\t\t\t\t\t\tdst,\n\t\t\t\t\t\t\tdst_next_p,\n\t\t\t\t\t\t\tinstruction,\n\t\t\t\t\t\t\toperand,\n\t\t\t\t\t\t\t(instruction.memory_segment()),\n\t\t\t\t\t\t\t(Register::RSI),\n\t\t\t\t\t\t\t(Register::None),\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t8,\n\t\t\t\t\t\t)\n\t\t\t\t\t}};\n\t\t\t\t}\n\t\t\t\tmacro_rules! fmt_memory_seg_di {\n\t\t\t\t\t() => {{\n\t\t\t\t\t\tcall_format_memory!(\n\t\t\t\t\t\t\tself,\n\t\t\t\t\t\t\tdst,\n\t\t\t\t\t\t\tdst_next_p,\n\t\t\t\t\t\t\tinstruction,\n\t\t\t\t\t\t\toperand,\n\t\t\t\t\t\t\t(instruction.memory_segment()),\n\t\t\t\t\t\t\t(Register::DI),\n\t\t\t\t\t\t\t(Register::None),\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t2,\n\t\t\t\t\t\t)\n\t\t\t\t\t}};\n\t\t\t\t}\n\t\t\t\tmacro_rules! fmt_memory_seg_edi {\n\t\t\t\t\t() => {{\n\t\t\t\t\t\tcall_format_memory!(\n\t\t\t\t\t\t\tself,\n\t\t\t\t\t\t\tdst,\n\t\t\t\t\t\t\tdst_next_p,\n\t\t\t\t\t\t\tinstruction,\n\t\t\t\t\t\t\toperand,\n\t\t\t\t\t\t\t(instruction.memory_segment()),\n\t\t\t\t\t\t\t(Register::EDI),\n\t\t\t\t\t\t\t(Register::None),\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t4,\n\t\t\t\t\t\t)\n\t\t\t\t\t}};\n\t\t\t\t}\n\t\t\t\tmacro_rules! fmt_memory_seg_rdi {\n\t\t\t\t\t() => {{\n\t\t\t\t\t\tcall_format_memory!(\n\t\t\t\t\t\t\tself,\n\t\t\t\t\t\t\tdst,\n\t\t\t\t\t\t\tdst_next_p,\n\t\t\t\t\t\t\tinstruction,\n\t\t\t\t\t\t\toperand,\n\t\t\t\t\t\t\t(instruction.memory_segment()),\n\t\t\t\t\t\t\t(Register::RDI),\n\t\t\t\t\t\t\t(Register::None),\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t8,\n\t\t\t\t\t\t)\n\t\t\t\t\t}};\n\t\t\t\t}\n\t\t\t\tmacro_rules! fmt_memory_es_di {\n\t\t\t\t\t() => {{\n\t\t\t\t\t\tcall_format_memory!(self, dst, dst_next_p, instruction, operand, (Register::ES), (Register::DI), (Register::None), 0, 0, 0, 2)\n\t\t\t\t\t}};\n\t\t\t\t}\n\t\t\t\tmacro_rules! fmt_memory_es_edi {\n\t\t\t\t\t() => {{\n\t\t\t\t\t\tcall_format_memory!(\n\t\t\t\t\t\t\tself,\n\t\t\t\t\t\t\tdst,\n\t\t\t\t\t\t\tdst_next_p,\n\t\t\t\t\t\t\tinstruction,\n\t\t\t\t\t\t\toperand,\n\t\t\t\t\t\t\t(Register::ES),\n\t\t\t\t\t\t\t(Register::EDI),\n\t\t\t\t\t\t\t(Register::None),\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t4\n\t\t\t\t\t\t)\n\t\t\t\t\t}};\n\t\t\t\t}\n\t\t\t\tmacro_rules! fmt_memory_es_rdi {\n\t\t\t\t\t() => {{\n\t\t\t\t\t\tcall_format_memory!(\n\t\t\t\t\t\t\tself,\n\t\t\t\t\t\t\tdst,\n\t\t\t\t\t\t\tdst_next_p,\n\t\t\t\t\t\t\tinstruction,\n\t\t\t\t\t\t\toperand,\n\t\t\t\t\t\t\t(Register::ES),\n\t\t\t\t\t\t\t(Register::RDI),\n\t\t\t\t\t\t\t(Register::None),\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t8\n\t\t\t\t\t\t)\n\t\t\t\t\t}};\n\t\t\t\t}\n\t\t\t\tmacro_rules! fmt_memory {\n\t\t\t\t\t() => {{\n\t\t\t\t\t\tlet displ_size = instruction.memory_displ_size();\n\t\t\t\t\t\tlet base_reg = instruction.memory_base();\n\t\t\t\t\t\tlet mut index_reg = instruction.memory_index();\n\t\t\t\t\t\tlet addr_size = get_address_size_in_bytes(base_reg, index_reg, displ_size, instruction.code_size());\n\t\t\t\t\t\tlet displ =\n\t\t\t\t\t\t\tif addr_size == 8 { instruction.memory_displacement64() as i64 } else { instruction.memory_displacement32() as i64 };\n\t\t\t\t\t\tif code == Code::Xlat_m8 {\n\t\t\t\t\t\t\tindex_reg = Register::None;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcall_format_memory!(\n\t\t\t\t\t\t\tself,\n\t\t\t\t\t\t\tdst,\n\t\t\t\t\t\t\tdst_next_p,\n\t\t\t\t\t\t\tinstruction,\n\t\t\t\t\t\t\toperand,\n\t\t\t\t\t\t\t(instruction.memory_segment()),\n\t\t\t\t\t\t\tbase_reg,\n\t\t\t\t\t\t\tindex_reg,\n\t\t\t\t\t\t\t(instruction_internal::internal_get_memory_index_scale(instruction)),\n\t\t\t\t\t\t\tdispl_size,\n\t\t\t\t\t\t\tdispl,\n\t\t\t\t\t\t\taddr_size,\n\t\t\t\t\t\t);\n\t\t\t\t\t\t#[cfg(feature = \"mvex\")]\n\t\t\t\t\t\tif instruction.is_mvex_eviction_hint() {\n\t\t\t\t\t\t\tconst FAST_STR: FastString4 = mk_const_fast_str!(FastString4, \"\\x04{eh}\");\n\t\t\t\t\t\t\twrite_fast_str!(dst, dst_next_p, FastString4, FAST_STR);\n\t\t\t\t\t\t}\n\t\t\t\t\t}};\n\t\t\t\t}\n\n\t\t\t\t// This speeds up SpecializedFormatter since every option is hard coded, but makes FastFormatter\n\t\t\t\t// slower because every option is dynamic (more code). Detect FastFormatter and generate smaller\n\t\t\t\t// and faster code. Both paths are tested (same tests).\n\t\t\t\t// The whole point of this formatter is to be fast so unfortunately it can result in fugly code...\n\t\t\t\tif TraitOptions::__IS_FAST_FORMATTER {\n\t\t\t\t\tmatch op_kind {\n\t\t\t\t\t\tOpKind::Register => fmt_register!(),\n\n\t\t\t\t\t\tOpKind::NearBranch16 | OpKind::NearBranch32 | OpKind::NearBranch64 => {\n\t\t\t\t\t\t\tif op_kind == OpKind::NearBranch64 {\n\t\t\t\t\t\t\t\timm_size = 8;\n\t\t\t\t\t\t\t\timm64 = instruction.near_branch64();\n\t\t\t\t\t\t\t} else if op_kind == OpKind::NearBranch32 {\n\t\t\t\t\t\t\t\timm_size = 4;\n\t\t\t\t\t\t\t\timm64 = instruction.near_branch32() as u64;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\timm_size = 2;\n\t\t\t\t\t\t\t\timm64 = instruction.near_branch16() as u64;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfmt_near_branch!(self, dst, dst_next_p, instruction, imm_size, imm64);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tOpKind::FarBranch16 | OpKind::FarBranch32 => fmt_far_br_16_32!(),\n\n\t\t\t\t\t\tOpKind::Immediate8 | OpKind::Immediate8_2nd => {\n\t\t\t\t\t\t\tif TraitOptions::ENABLE_DB_DW_DD_DQ && is_declare_data {\n\t\t\t\t\t\t\t\timm8 = instruction.get_declare_byte_value(operand as usize);\n\t\t\t\t\t\t\t} else if op_kind == OpKind::Immediate8 {\n\t\t\t\t\t\t\t\timm8 = instruction.immediate8();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdebug_assert_eq!(op_kind, OpKind::Immediate8_2nd);\n\t\t\t\t\t\t\t\timm8 = instruction.immediate8_2nd();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfmt_imm!(self, dst, dst_next_p, instruction, imm8, 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tOpKind::Immediate16 | OpKind::Immediate8to16 => {\n\t\t\t\t\t\t\tif TraitOptions::ENABLE_DB_DW_DD_DQ && is_declare_data {\n\t\t\t\t\t\t\t\timm16 = instruction.get_declare_word_value(operand as usize);\n\t\t\t\t\t\t\t} else if op_kind == OpKind::Immediate16 {\n\t\t\t\t\t\t\t\timm16 = instruction.immediate16();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdebug_assert_eq!(op_kind, OpKind::Immediate8to16);\n\t\t\t\t\t\t\t\timm16 = instruction.immediate8to16() as u16;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfmt_imm!(self, dst, dst_next_p, instruction, imm16, 2)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tOpKind::Immediate32 | OpKind::Immediate8to32 => {\n\t\t\t\t\t\t\tif TraitOptions::ENABLE_DB_DW_DD_DQ && is_declare_data {\n\t\t\t\t\t\t\t\timm32 = instruction.get_declare_dword_value(operand as usize);\n\t\t\t\t\t\t\t} else if op_kind == OpKind::Immediate32 {\n\t\t\t\t\t\t\t\timm32 = instruction.immediate32();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdebug_assert_eq!(op_kind, OpKind::Immediate8to32);\n\t\t\t\t\t\t\t\timm32 = instruction.immediate8to32() as u32;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfmt_imm!(self, dst, dst_next_p, instruction, imm32, 4)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tOpKind::Immediate64 | OpKind::Immediate8to64 | OpKind::Immediate32to64 => {\n\t\t\t\t\t\t\tif TraitOptions::ENABLE_DB_DW_DD_DQ && is_declare_data {\n\t\t\t\t\t\t\t\timm64 = instruction.get_declare_qword_value(operand as usize);\n\t\t\t\t\t\t\t} else if op_kind == OpKind::Immediate32to64 {\n\t\t\t\t\t\t\t\timm64 = instruction.immediate32to64() as u64;\n\t\t\t\t\t\t\t} else if op_kind == OpKind::Immediate8to64 {\n\t\t\t\t\t\t\t\timm64 = instruction.immediate8to64() as u64;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdebug_assert_eq!(op_kind, OpKind::Immediate64);\n\t\t\t\t\t\t\t\timm64 = instruction.immediate64();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfmt_imm!(self, dst, dst_next_p, instruction, imm64, 8)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tOpKind::MemorySegSI => fmt_memory_seg_si!(),\n\t\t\t\t\t\tOpKind::MemorySegESI => fmt_memory_seg_esi!(),\n\t\t\t\t\t\tOpKind::MemorySegRSI => fmt_memory_seg_rsi!(),\n\t\t\t\t\t\tOpKind::MemorySegDI => fmt_memory_seg_di!(),\n\t\t\t\t\t\tOpKind::MemorySegEDI => fmt_memory_seg_edi!(),\n\t\t\t\t\t\tOpKind::MemorySegRDI => fmt_memory_seg_rdi!(),\n\t\t\t\t\t\tOpKind::MemoryESDI => fmt_memory_es_di!(),\n\t\t\t\t\t\tOpKind::MemoryESEDI => fmt_memory_es_edi!(),\n\t\t\t\t\t\tOpKind::MemoryESRDI => fmt_memory_es_rdi!(),\n\t\t\t\t\t\tOpKind::Memory => fmt_memory!(),\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmatch op_kind {\n\t\t\t\t\t\tOpKind::Register => fmt_register!(),\n\n\t\t\t\t\t\tOpKind::NearBranch16 => {\n\t\t\t\t\t\t\timm64 = instruction.near_branch16() as u64;\n\t\t\t\t\t\t\tfmt_near_branch!(self, dst, dst_next_p, instruction, 2, imm64);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tOpKind::NearBranch32 => {\n\t\t\t\t\t\t\timm64 = instruction.near_branch32() as u64;\n\t\t\t\t\t\t\tfmt_near_branch!(self, dst, dst_next_p, instruction, 4, imm64);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tOpKind::NearBranch64 => {\n\t\t\t\t\t\t\timm64 = instruction.near_branch64();\n\t\t\t\t\t\t\tfmt_near_branch!(self, dst, dst_next_p, instruction, 8, imm64);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tOpKind::FarBranch16 | OpKind::FarBranch32 => fmt_far_br_16_32!(),\n\n\t\t\t\t\t\tOpKind::Immediate8 => {\n\t\t\t\t\t\t\timm8 = if TraitOptions::ENABLE_DB_DW_DD_DQ && is_declare_data {\n\t\t\t\t\t\t\t\tinstruction.get_declare_byte_value(operand as usize)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tinstruction.immediate8()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfmt_imm!(self, dst, dst_next_p, instruction, imm8, 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tOpKind::Immediate8_2nd => {\n\t\t\t\t\t\t\timm8 = instruction.immediate8_2nd();\n\t\t\t\t\t\t\tfmt_imm!(self, dst, dst_next_p, instruction, imm8, 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tOpKind::Immediate16 => {\n\t\t\t\t\t\t\timm16 = if TraitOptions::ENABLE_DB_DW_DD_DQ && is_declare_data {\n\t\t\t\t\t\t\t\tinstruction.get_declare_word_value(operand as usize)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tinstruction.immediate16()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfmt_imm!(self, dst, dst_next_p, instruction, imm16, 2)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tOpKind::Immediate8to16 => {\n\t\t\t\t\t\t\timm16 = instruction.immediate8to16() as u16;\n\t\t\t\t\t\t\tfmt_imm!(self, dst, dst_next_p, instruction, imm16, 2)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tOpKind::Immediate32 => {\n\t\t\t\t\t\t\timm32 = if TraitOptions::ENABLE_DB_DW_DD_DQ && is_declare_data {\n\t\t\t\t\t\t\t\tinstruction.get_declare_dword_value(operand as usize)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tinstruction.immediate32()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfmt_imm!(self, dst, dst_next_p, instruction, imm32, 4)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tOpKind::Immediate8to32 => {\n\t\t\t\t\t\t\timm32 = instruction.immediate8to32() as u32;\n\t\t\t\t\t\t\tfmt_imm!(self, dst, dst_next_p, instruction, imm32, 4)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tOpKind::Immediate64 => {\n\t\t\t\t\t\t\timm64 = if TraitOptions::ENABLE_DB_DW_DD_DQ && is_declare_data {\n\t\t\t\t\t\t\t\tinstruction.get_declare_qword_value(operand as usize)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tinstruction.immediate64()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfmt_imm!(self, dst, dst_next_p, instruction, imm64, 8)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tOpKind::Immediate8to64 => {\n\t\t\t\t\t\t\timm64 = instruction.immediate8to64() as u64;\n\t\t\t\t\t\t\tfmt_imm!(self, dst, dst_next_p, instruction, imm64, 8)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tOpKind::Immediate32to64 => {\n\t\t\t\t\t\t\timm64 = instruction.immediate32to64() as u64;\n\t\t\t\t\t\t\tfmt_imm!(self, dst, dst_next_p, instruction, imm64, 8)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tOpKind::MemorySegSI => fmt_memory_seg_si!(),\n\t\t\t\t\t\tOpKind::MemorySegESI => fmt_memory_seg_esi!(),\n\t\t\t\t\t\tOpKind::MemorySegRSI => fmt_memory_seg_rsi!(),\n\t\t\t\t\t\tOpKind::MemorySegDI => fmt_memory_seg_di!(),\n\t\t\t\t\t\tOpKind::MemorySegEDI => fmt_memory_seg_edi!(),\n\t\t\t\t\t\tOpKind::MemorySegRDI => fmt_memory_seg_rdi!(),\n\t\t\t\t\t\tOpKind::MemoryESDI => fmt_memory_es_di!(),\n\t\t\t\t\t\tOpKind::MemoryESEDI => fmt_memory_es_edi!(),\n\t\t\t\t\t\tOpKind::MemoryESRDI => fmt_memory_es_rdi!(),\n\t\t\t\t\t\tOpKind::Memory => fmt_memory!(),\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif operand == 0 && instruction_internal::internal_has_op_mask_or_zeroing_masking(instruction) {\n\t\t\t\t\tif instruction.has_op_mask() {\n\t\t\t\t\t\twrite_fast_ascii_char_lit!(dst, dst_next_p, '{', true);\n\t\t\t\t\t\tcall_format_register!(self, dst, dst_next_p, instruction.op_mask());\n\t\t\t\t\t\twrite_fast_ascii_char_lit!(dst, dst_next_p, '}', true);\n\t\t\t\t\t}\n\t\t\t\t\tif instruction.zeroing_masking() {\n\t\t\t\t\t\tconst FAST_STR: FastString4 = mk_const_fast_str!(FastString4, \"\\x03{z} \");\n\t\t\t\t\t\twrite_fast_str!(dst, dst_next_p, FastString4, FAST_STR);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#[cfg(feature = \"mvex\")]\n\t\t\t\tif mvex_rm_operand == operand {\n\t\t\t\t\tlet conv = instruction.mvex_reg_mem_conv();\n\t\t\t\t\tif conv != MvexRegMemConv::None {\n\t\t\t\t\t\tlet mvex = crate::mvex::get_mvex_info(instruction.code());\n\t\t\t\t\t\tif mvex.conv_fn != MvexConvFn::None {\n\t\t\t\t\t\t\tlet tbl = if mvex.is_conv_fn_32() { &MVEX_REG_MEM_CONSTS_32 } else { &MVEX_REG_MEM_CONSTS_64 };\n\t\t\t\t\t\t\tlet s = tbl[conv as usize];\n\t\t\t\t\t\t\twrite_fast_str!(dst, dst_next_p, FastString12, s);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\toperand += 1;\n\t\t\t\tif operand >= op_count {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif TraitOptions::space_after_operand_separator(&self.d.options) {\n\t\t\t\t\tconst FAST_STR: FastString4 = mk_const_fast_str!(FastString4, \"\\x02,   \");\n\t\t\t\t\twrite_fast_str!(dst, dst_next_p, FastString4, FAST_STR);\n\t\t\t\t} else {\n\t\t\t\t\twrite_fast_ascii_char_lit!(dst, dst_next_p, ',', true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif instruction_internal::internal_has_rounding_control_or_sae(instruction) {\n\t\t\t\tlet rc = instruction.rounding_control();\n\t\t\t\tif rc != RoundingControl::None {\n\t\t\t\t\tif IcedConstants::is_mvex(instruction.code()) && !instruction.suppress_all_exceptions() {\n\t\t\t\t\t\tlet fast_str = RC_STRINGS[rc as usize];\n\t\t\t\t\t\twrite_fast_str!(dst, dst_next_p, FastString4, fast_str);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet fast_str = RC_SAE_STRINGS[rc as usize];\n\t\t\t\t\t\twrite_fast_str!(dst, dst_next_p, FastString8, fast_str);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdebug_assert!(instruction.suppress_all_exceptions());\n\t\t\t\t\tconst FAST_STR: FastString8 = mk_const_fast_str!(FastString8, \"\\x05{sae}   \");\n\t\t\t\t\twrite_fast_str!(dst, dst_next_p, FastString8, FAST_STR);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tupdate_vec_len!(dst, dst_next_p);\n\t}"
}