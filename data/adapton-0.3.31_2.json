{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<engine::DCG as engine::Adapton>::thunk`",
    "file": "adapton-0.3.31/src/engine.rs",
    "start_line": 1627,
    "start_col": 5,
    "end_line": 1812,
    "end_col": 6,
    "code_snippet": "fn thunk<Arg:Eq+Hash+Debug+Clone+'static,Spurious:'static+Clone,Res:Eq+Debug+Clone+Hash+'static>\n        (self:&mut DCG,\n         id:NameChoice,\n         prog_pt:ProgPt,\n         fn_box:Rc<Box<dyn Fn(Arg, Spurious) -> Res>>,\n         arg:Arg, spurious:Spurious)\n         -> AbsArt<Res,Self::Loc>\n    {\n        wf::check_dcg(self);\n        let id =\n        // Apply the logic of engine's flags:\n            match id { NameChoice::Nominal(_)\n                       if self.flags.ignore_nominal_use_structural\n                       => NameChoice::Structural,\n                       id => id } ;\n        match id {\n            // Eagerly do the computation now, and store the result.\n            NameChoice::Eager => {\n                AbsArt::Rc(Rc::new(fn_box(arg,spurious)))\n            },\n\n            NameChoice::Naive => {\n                // TODO/XXX\n                // Tried to implement this, but got stuck because of `Self::Loc`.\n                // Perhaps now is the time to completely ditch this `Adapton` trait, and the `Self::Loc` type.\n                unimplemented!()\n            }\n            \n            // Name the computation structurally, based on the args and prog point.\n            NameChoice::Structural => {\n                wf::check_dcg(self);\n                let hash = my_hash (&(&prog_pt, &arg)) ;\n                let loc = loc_of_id(current_path(self),\n                                    Rc::new(ArtId::Structural(hash)));\n                {   // If the node exists, return early.\n                    let node = self.table.get_mut(&loc);\n                    match node { None    => { },\n                                 Some(_) => { return AbsArt::Loc(loc) }, // Nothing to do; it already exists.\n                    }\n                } ;\n                // assert: node does not exist.\n                match self.stack.last_mut() {\n                    None => (),\n                    Some(frame) => {\n                        let succ =\n                            Succ{loc:loc.clone(),\n                                 dep:Rc::new(Box::new(AllocStructuralThunk)),\n                                 effect:Effect::Allocate,\n                                 dirty:false};\n                        frame.succs.push((succ, None))\n                    }};\n                let producer : Box<dyn Producer<Res>> =\n                    Box::new(App{prog_pt:prog_pt,\n                                 fn_box:fn_box,\n                                 arg:arg.clone(),\n                                 spurious:spurious.clone()})\n                    ;\n                let node : CompNode<Res> = CompNode{\n                    preds:Vec::new(),\n                    succs:Vec::new(),\n                    producer:producer,\n                    res:None,\n                } ;\n                //self.cnt.create += 1;\n                self.table.insert(loc.clone(),\n                                  Box::new(Node::Comp(node)));\n                wf::check_dcg(self);\n                AbsArt::Loc(loc)\n            },\n\n            // Name the thunk explicitly by `nm`\n            NameChoice::Nominal(nm) => {\n                wf::check_dcg(self);\n                let loc = loc_of_id(current_path(self),\n                                    Rc::new(ArtId::Nominal(nm)));\n                let producer : App<Arg,Spurious,Res> =\n                    App{prog_pt:prog_pt.clone(),\n                        fn_box:fn_box,\n                        arg:arg.clone(),\n                        spurious:spurious.clone(),\n                    }\n                ;\n                let top_loc = get_top_stack_loc( self );\n                let (do_dirty, do_insert, is_fresh) = { match self.table.get_mut( &loc ) {\n                    None => {\n                        // do_dirty=false; do_insert=true\n                        (false, true, true)\n                    },\n                    Some(node) => {\n                        let node: &mut Box<dyn GraphNode> = node ;\n                        assert_graphnode_res_type::<Res>(&loc, node, top_loc);\n                        let res_nd: &mut Box<Node<Res>> = unsafe { transmute::<_,_>( node ) } ;\n                        match ** res_nd {\n                            Node::Pure(_)=> unreachable!(),\n                            Node::Mut(_) => {\n                                (true, true, false) // Todo: Do we need to preserve preds?\n                            },\n                            Node::Comp(ref mut comp_nd) => {\n                                let equal_producer_prog_pts : bool =\n                                    comp_nd.producer.prog_pt().eq( producer.prog_pt() ) ;\n                                if equal_producer_prog_pts { // => safe cast to Box<Consumer<Arg>>\n                                    let app: &mut Box<App<Arg,Spurious,Res>> =\n                                    // TODO-Soon: Follow pattern above for assert_graphnode_res_type to dynamically check the safety of this cast\n                                        unsafe { transmute::<_,_>( &mut comp_nd.producer ) }\n                                    ;\n                                    if app.get_arg() == arg {\n                                        // Case: Same argument; Nothing else to do:\n                                        // do_dirty=false; do_insert=false\n                                        (false, false, false)\n                                    }\n                                    else { // Case: Not the same argument:\n                                        app.consume(arg.clone()); // overwrite the old argument\n                                        comp_nd.res = None ; // clear the cache\n                                        // do_dirty=true; do_insert=false\n                                        (true, false, false)\n                                    }}\n                                else {\n                                    panic!(\"Memozied functions not equal!\n                            Function was: {:?}\n                           with Producer: {:?}\n\n                            Function now: {:?}\n                           with Producer: {:?}\n\n                        Common location: {:?}\n\n                        ** Hint: Consider using distinct namespaces, via `Adapton::ns`\n                           (See: https://docs.rs/adapton/0/adapton/engine/fn.ns.html)\n                        \",\n                                           comp_nd.producer.prog_pt(), &comp_nd.producer,\n                                           producer.prog_pt(), &producer,\n                                           &loc,\n                                    )\n                                }\n                            },\n                        }\n                    }\n                } } ;\n\n                dcg_effect_begin!(\n                    reflect::trace::Effect::Alloc(\n                        if is_fresh { reflect::trace::AllocCase::LocFresh }\n                        else {\n                            let cf =\n                                if do_dirty { reflect::trace::ChangeFlag::ContentDiff }\n                            else { reflect::trace::ChangeFlag::ContentSame };\n                            reflect::trace::AllocCase::LocExists(cf) },\n                        reflect::trace::AllocKind::Thunk\n                    ),\n                    current_loc!(self),\n                    reflect::Succ{\n                        loc:loc.reflect(),\n                        effect:reflect::Effect::Alloc,\n                        value:reflect::Val::ValTODO,\n                        dirty:false,\n                        is_dup:false, // XXX -- Actually: Not checked here.\n                    });\n                if do_dirty {dirty_alloc(self, &loc) };\n                dcg_effect_end!();\n\n                match self.stack.last_mut() { None => (), Some(frame) => {\n                    let succ =\n                        Succ{loc:loc.clone(),\n                             dep:Rc::new(Box::new(AllocNominalThunk{val:arg.clone()})),\n                             effect:Effect::Allocate,\n                             dirty:false};\n                    frame.succs.push((succ, None))\n                }};\n                if do_insert {\n                    let node : CompNode<Res> = CompNode{\n                        preds:Vec::new(),\n                        succs:Vec::new(),\n                        producer:Box::new(producer),\n                        res:None,\n                    } ;\n                    self.table.insert(loc.clone(), Box::new(Node::Comp(node)));\n                    wf::check_dcg(self);\n                    AbsArt::Loc(loc)\n                }\n                else {\n                    wf::check_dcg(self);\n                    AbsArt::Loc(loc)\n                }\n            }\n        }\n    }"
}