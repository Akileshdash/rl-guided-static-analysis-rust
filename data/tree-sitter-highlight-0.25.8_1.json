{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `HighlightIterLayer::<'a>::new`",
    "file": "tree-sitter-highlight-0.25.8/src/lib.rs",
    "start_line": 509,
    "start_col": 5,
    "end_line": 631,
    "end_col": 6,
    "code_snippet": "fn new<F: FnMut(&str) -> Option<&'a HighlightConfiguration> + 'a>(\n        source: &'a [u8],\n        parent_name: Option<&str>,\n        highlighter: &mut Highlighter,\n        cancellation_flag: Option<&'a AtomicUsize>,\n        injection_callback: &mut F,\n        mut config: &'a HighlightConfiguration,\n        mut depth: usize,\n        mut ranges: Vec<Range>,\n    ) -> Result<Vec<Self>, Error> {\n        let mut result = Vec::with_capacity(1);\n        let mut queue = Vec::new();\n        loop {\n            if highlighter.parser.set_included_ranges(&ranges).is_ok() {\n                highlighter\n                    .parser\n                    .set_language(&config.language)\n                    .map_err(|_| Error::InvalidLanguage)?;\n\n                let tree = highlighter\n                    .parser\n                    .parse_with_options(\n                        &mut |i, _| {\n                            if i < source.len() {\n                                &source[i..]\n                            } else {\n                                &[]\n                            }\n                        },\n                        None,\n                        Some(ParseOptions::new().progress_callback(&mut |_| {\n                            if let Some(cancellation_flag) = cancellation_flag {\n                                cancellation_flag.load(Ordering::SeqCst) != 0\n                            } else {\n                                false\n                            }\n                        })),\n                    )\n                    .ok_or(Error::Cancelled)?;\n                let mut cursor = highlighter.cursors.pop().unwrap_or_default();\n\n                // Process combined injections.\n                if let Some(combined_injections_query) = &config.combined_injections_query {\n                    let mut injections_by_pattern_index =\n                        vec![(None, Vec::new(), false); combined_injections_query.pattern_count()];\n                    let mut matches =\n                        cursor.matches(combined_injections_query, tree.root_node(), source);\n                    while let Some(mat) = matches.next() {\n                        let entry = &mut injections_by_pattern_index[mat.pattern_index];\n                        let (language_name, content_node, include_children) = injection_for_match(\n                            config,\n                            parent_name,\n                            combined_injections_query,\n                            mat,\n                            source,\n                        );\n                        if language_name.is_some() {\n                            entry.0 = language_name;\n                        }\n                        if let Some(content_node) = content_node {\n                            entry.1.push(content_node);\n                        }\n                        entry.2 = include_children;\n                    }\n                    for (lang_name, content_nodes, includes_children) in injections_by_pattern_index\n                    {\n                        if let (Some(lang_name), false) = (lang_name, content_nodes.is_empty()) {\n                            if let Some(next_config) = (injection_callback)(lang_name) {\n                                let ranges = Self::intersect_ranges(\n                                    &ranges,\n                                    &content_nodes,\n                                    includes_children,\n                                );\n                                if !ranges.is_empty() {\n                                    queue.push((next_config, depth + 1, ranges));\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // The `captures` iterator borrows the `Tree` and the `QueryCursor`, which\n                // prevents them from being moved. But both of these values are really just\n                // pointers, so it's actually ok to move them.\n                let tree_ref = unsafe { mem::transmute::<&Tree, &'static Tree>(&tree) };\n                let cursor_ref = unsafe {\n                    mem::transmute::<&mut QueryCursor, &'static mut QueryCursor>(&mut cursor)\n                };\n                let captures = unsafe {\n                    std::mem::transmute::<QueryCaptures<_, _>, _QueryCaptures<_, _>>(\n                        cursor_ref.captures(&config.query, tree_ref.root_node(), source),\n                    )\n                }\n                .peekable();\n\n                result.push(HighlightIterLayer {\n                    highlight_end_stack: Vec::new(),\n                    scope_stack: vec![LocalScope {\n                        inherits: false,\n                        range: 0..usize::MAX,\n                        local_defs: Vec::new(),\n                    }],\n                    cursor,\n                    depth,\n                    _tree: tree,\n                    captures,\n                    config,\n                    ranges,\n                });\n            }\n\n            if queue.is_empty() {\n                break;\n            }\n\n            let (next_config, next_depth, next_ranges) = queue.remove(0);\n            config = next_config;\n            depth = next_depth;\n            ranges = next_ranges;\n        }\n\n        Ok(result)\n    }"
}