{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `conversions::sse::rgb_xyz_q2_13_opt::TransformShaperQ2_13OptSse::<T, SRC_LAYOUT, DST_LAYOUT, LINEAR_CAP, GAMMA_LUT, BIT_DEPTH, PRECISION>::transform_impl`",
    "file": "moxcms-0.7.3/src/conversions/sse/rgb_xyz_q2_13_opt.rs",
    "start_line": 65,
    "start_col": 5,
    "end_line": 145,
    "end_col": 6,
    "code_snippet": "unsafe fn transform_impl(&self, src: &[T], dst: &mut [T]) -> Result<(), CmsError> {\n        let src_cn = Layout::from(SRC_LAYOUT);\n        let dst_cn = Layout::from(DST_LAYOUT);\n        let src_channels = src_cn.channels();\n        let dst_channels = dst_cn.channels();\n\n        let mut temporary = SseAlignedU16([0; 8]);\n\n        if src.len() / src_channels != dst.len() / dst_channels {\n            return Err(CmsError::LaneSizeMismatch);\n        }\n        if src.len() % src_channels != 0 {\n            return Err(CmsError::LaneMultipleOfChannels);\n        }\n        if dst.len() % dst_channels != 0 {\n            return Err(CmsError::LaneMultipleOfChannels);\n        }\n\n        let t = self.profile.adaptation_matrix.transpose();\n\n        let max_colors = ((1 << BIT_DEPTH) - 1).as_();\n\n        unsafe {\n            let m0 = _mm_setr_epi16(\n                t.v[0][0], t.v[1][0], t.v[0][1], t.v[1][1], t.v[0][2], t.v[1][2], 0, 0,\n            );\n            let m2 = _mm_setr_epi16(t.v[2][0], 1, t.v[2][1], 1, t.v[2][2], 1, 0, 0);\n\n            let rnd_val = ((1i32 << (PRECISION - 1)) as i16).to_ne_bytes();\n            let rnd = _mm_set1_epi32(i32::from_ne_bytes([0, 0, rnd_val[0], rnd_val[1]]));\n\n            let v_max_value = _mm_set1_epi32(GAMMA_LUT as i32 - 1);\n\n            for (src, dst) in src\n                .chunks_exact(src_channels)\n                .zip(dst.chunks_exact_mut(dst_channels))\n            {\n                let rp = &self.profile.linear[src[src_cn.r_i()]._as_usize()];\n                let gp = &self.profile.linear[src[src_cn.g_i()]._as_usize()];\n                let bp = &self.profile.linear[src[src_cn.b_i()]._as_usize()];\n\n                let mut r = _xmm_load_epi32(rp);\n                let mut g = _xmm_load_epi32(gp);\n                let mut b = _xmm_load_epi32(bp);\n                let a = if src_channels == 4 {\n                    src[src_cn.a_i()]\n                } else {\n                    max_colors\n                };\n\n                r = _mm_shuffle_epi32::<0>(r);\n                g = _mm_shuffle_epi32::<0>(g);\n                b = _mm_shuffle_epi32::<0>(b);\n\n                g = _mm_slli_epi32::<16>(g);\n\n                let zrg0 = _mm_or_si128(r, g);\n                let zbz0 = _mm_or_si128(b, rnd);\n\n                let v0 = _mm_madd_epi16(zrg0, m0);\n                let v1 = _mm_madd_epi16(zbz0, m2);\n\n                let mut v = _mm_add_epi32(v0, v1);\n\n                v = _mm_srai_epi32::<PRECISION>(v);\n                v = _mm_max_epi32(v, _mm_setzero_si128());\n                v = _mm_min_epi32(v, v_max_value);\n\n                _mm_store_si128(temporary.0.as_mut_ptr() as *mut _, v);\n\n                dst[dst_cn.r_i()] = self.profile.gamma[temporary.0[0] as usize];\n                dst[dst_cn.g_i()] = self.profile.gamma[temporary.0[2] as usize];\n                dst[dst_cn.b_i()] = self.profile.gamma[temporary.0[4] as usize];\n                if dst_channels == 4 {\n                    dst[dst_cn.a_i()] = a;\n                }\n            }\n        }\n\n        Ok(())\n    }"
}