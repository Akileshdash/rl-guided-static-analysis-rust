{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `branch::PartialBranch::<'a, C, A>::walk`",
    "file": "microkelvin-0.17.0/src/branch.rs",
    "start_line": 125,
    "start_col": 5,
    "end_line": 213,
    "end_col": 6,
    "code_snippet": "fn walk<W>(&mut self, walker: &mut W) -> Option<()>\n    where\n        W: Walker<C, A>,\n    {\n        enum State<'a, C, A> {\n            Init,\n            Push(Level<'a, C, A>),\n            Pop,\n        }\n\n        let mut state = State::Init;\n        loop {\n            match core::mem::replace(&mut state, State::Init) {\n                State::Init => (),\n                State::Push(push) => self.0.push(push),\n                State::Pop => match self.pop() {\n                    Some(_) => {\n                        self.advance();\n                    }\n                    None => return None,\n                },\n            }\n\n            let top = self.top_mut();\n            let step = walker.walk(Walk::new(&**top, top.index()));\n\n            match step {\n                Step::Found(walk_index) => {\n                    *top.index_mut() += walk_index;\n                    return Some(());\n                }\n                Step::Into(walk_index) => {\n                    *top.index_mut() += walk_index;\n                    let index = top.index();\n                    let top_child = top.child(index);\n                    if let Child::Node(n) = top_child {\n                        let level: Level<'_, C, A> = Level::new_val(n);\n\n                        // Extend the lifetime of the Level.\n                        //\n                        // JUSTIFICATION\n                        //\n                        // The `Vec<Level<'a, C, A>>` used here cannot be\n                        // expressed in safe rust, since it relies on the\n                        // elements of the `Vec` referring to prior elements in\n                        // the same `Vec`.\n                        //\n                        // This vec from the start contains one single `Level`\n                        // of variant in turn containing a `LevelNode::Root(&'a\n                        // C)`\n                        //\n                        // The first step `Into` will add a `Level` with the\n                        // following reference structure\n                        // `LevelNode::Val(AnnRef<'a, C, A>)` -> `Val<'a, C>` ->\n                        // ReprInner (from canonical) which in turns contains\n                        // the value of the next node behind an `Rc<C>`.\n                        //\n                        // The address of the pointed-to `C` thus remains\n                        // unchanged, even if the `Vec` in `PartialBranch`\n                        // re-allocates.\n                        //\n                        // The same is true of `LevelNode::Root` since it is a\n                        // reference that just gets copied over to the new\n                        // allocation.\n                        //\n                        // Additionally, the `Vec` is only ever changed at its\n                        // end, either pushed or popped, so any reference \"Up\"\n                        // the branch will always remain valid.\n                        //\n                        // Since `'a` controls the whole lifetime of the access\n                        // to the tree, there is also no\n                        // way for the tree to change in\n                        // the meantime, thus invalidating the pointers is\n                        // not possible, and this extension of the lifetime of\n                        // the level is safe.\n                        let extended: Level<'a, C, A> =\n                            unsafe { core::mem::transmute(level) };\n                        state = State::Push(extended);\n                    } else {\n                        panic!(\"Attempted descent into non-node\")\n                    }\n                }\n                Step::Advance => state = State::Pop,\n                Step::Abort => {\n                    return None;\n                }\n            }\n        }\n    }"
}