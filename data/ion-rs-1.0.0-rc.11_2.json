{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `lazy::expanded::ExpandingReader::<Encoding, Input>::next_item`",
    "file": "ion-rs-1.0.0-rc.11/src/lazy/expanded/mod.rs",
    "start_line": 516,
    "start_col": 5,
    "end_line": 586,
    "end_col": 6,
    "code_snippet": "pub fn next_item(&mut self) -> IonResult<ExpandedStreamItem<'_, Encoding>> {\n        // If there's already an active macro evaluator, that means the reader is still in the process\n        // of expanding a macro invocation it previously encountered. See if it has a value to give us.\n        if let Some(ptr) = self.evaluator_ptr.get() {\n            // If there's already an evaluator, dereference the pointer.\n            let evaluator = Self::ptr_to_evaluator(ptr);\n            match evaluator.next() {\n                Ok(Some(value)) => {\n                    if evaluator.is_empty() {\n                        // If the evaluator is empty, unset the pointer so we know not to query it\n                        // further.\n                        self.evaluator_ptr.set(None);\n                    }\n                    return Ok(self.interpret_value(value)?.as_expanded_stream_item());\n                }\n                Ok(None) => {}\n                Err(e) => return Err(e),\n            }\n        }\n\n        // Otherwise, we're now between top level expressions. Take this opportunity to apply any\n        // pending changes to the encoding context and reset state as needed.\n        self.between_top_level_expressions();\n\n        // See if the raw reader can get another expression from the input stream. It's possible\n        // to find an expression that yields no values (for example: `(:none)`), so we perform this\n        // step in a loop until we get a value or end-of-stream.\n        let context_ref = self.context();\n\n        // Pull another top-level expression from the input stream if one is available.\n        use crate::lazy::raw_stream_item::RawStreamItem::*;\n        let raw_reader = unsafe { &mut *self.raw_reader.get() };\n        match raw_reader.next(context_ref)? {\n            VersionMarker(marker) => {\n                let _system_item = self.interpret_ivm(marker)?;\n                Ok(ExpandedStreamItem::VersionMarker(marker))\n            }\n            // We got our value; return it.\n            Value(raw_value) => {\n                let value = LazyExpandedValue::from_literal(context_ref, raw_value);\n                Ok(self.interpret_value(value)?.as_expanded_stream_item())\n            }\n            // It's another macro invocation, we'll add it to the evaluator so it will be evaluated\n            // on the next call and then we'll return the e-expression itself.\n            EExp(e_exp) => {\n                let resolved_e_exp = e_exp.resolve(context_ref)?;\n\n                // Get the current evaluator or make a new one\n                let evaluator = match self.evaluator_ptr.get() {\n                    // If there's already an evaluator in the bump, it's empty. Overwrite it with our new one.\n                    Some(ptr) => {\n                        let bump_evaluator_ref = Self::ptr_to_evaluator(ptr);\n                        bump_evaluator_ref.push(resolved_e_exp.expand()?);\n                        bump_evaluator_ref\n                    }\n                    // If there's not an evaluator in the bump, make a new one.\n                    None => {\n                        let new_evaluator = MacroEvaluator::for_eexp(resolved_e_exp)?;\n                        context_ref.allocator.alloc_with(|| new_evaluator)\n                    }\n                };\n\n                // Save the pointer to the evaluator\n                self.evaluator_ptr\n                    .set(Some(Self::evaluator_to_ptr(evaluator)));\n\n                Ok(ExpandedStreamItem::EExp(resolved_e_exp))\n            }\n            EndOfStream(end_position) => Ok(ExpandedStreamItem::EndOfStream(end_position)),\n        }\n    }"
}