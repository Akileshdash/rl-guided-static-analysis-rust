{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `pk::Pk::decrypt`",
    "file": "mbedtls-0.13.3/src/pk/mod.rs",
    "start_line": 794,
    "start_col": 5,
    "end_line": 832,
    "end_col": 6,
    "code_snippet": "pub fn decrypt<F: Random>(&mut self, cipher: &[u8], plain: &mut [u8], rng: &mut F) -> Result<usize> {\n        if self.pk_type() == Type::Rsa {\n            let ctx = self.inner.pk_ctx as *mut rsa_context;\n            if unsafe { (*ctx).padding == RAW_RSA_DECRYPT } {\n                let olen = self.len() / 8;\n                if plain.len() < olen {\n                    return Err(codes::RsaOutputTooLarge.into());\n                }\n\n                // Don't process outside of {2, ..., n-2}\n                let nm1 = self.rsa_public_modulus()?.sub(&Mpi::new(1)?)?;\n                let c_mpi = Mpi::from_binary(cipher)?;\n                if c_mpi <= Mpi::new(1).unwrap() || c_mpi >= nm1 {\n                    return Err(codes::MpiBadInputData.into());\n                }\n\n                unsafe {\n                    rsa_private(ctx, Some(F::call), rng.data_ptr(), cipher.as_ptr(), plain.as_mut_ptr()).into_result()?;\n                };\n                return Ok(olen);\n            }\n        }\n\n        let mut ret = 0usize;\n        unsafe {\n            pk_decrypt(\n                &mut self.inner,\n                cipher.as_ptr(),\n                cipher.len(),\n                plain.as_mut_ptr(),\n                &mut ret,\n                plain.len(),\n                Some(F::call),\n                rng.data_ptr(),\n            )\n            .into_result()?;\n        };\n        Ok(ret)\n    }"
}