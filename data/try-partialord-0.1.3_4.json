{
    "level": "Warning",
    "analyzer": "UnsafeDataflow",
    "op_type": "ReadFlow",
    "description": "Potential unsafe dataflow issue in `sort::std_mergesort::insert_head`",
    "file": "try-partialord-0.1.3/src/sort/std_mergesort.rs",
    "start_line": 7,
    "start_col": 1,
    "end_line": 72,
    "end_col": 2,
    "code_snippet": "fn insert_head<T, F>(v: &mut [T], is_less: &mut F) -> Option<()>\nwhere\n    F: FnMut(&T, &T) -> Option<bool>,\n{\n    if v.len() >= 2 && is_less(&v[1], &v[0])? {\n        unsafe {\n            // There are three ways to implement insertion here:\n            //\n            // 1. Swap adjacent elements until the first one gets to its final destination.\n            //    However, this way we copy data around more than is necessary. If elements are big\n            //    structures (costly to copy), this method will be slow.\n            //\n            // 2. Iterate until the right place for the first element is found. Then shift the\n            //    elements succeeding it to make room for it and finally place it into the\n            //    remaining hole. This is a good method.\n            //\n            // 3. Copy the first element into a temporary variable. Iterate until the right place\n            //    for it is found. As we go along, copy every traversed element into the slot\n            //    preceding it. Finally, copy data from the temporary variable into the remaining\n            //    hole. This method is very good. Benchmarks demonstrated slightly better\n            //    performance than with the 2nd method.\n            //\n            // All methods were benchmarked, and the 3rd showed best results. So we chose that one.\n            let mut tmp = mem::ManuallyDrop::new(ptr::read(&v[0]));\n\n            // Intermediate state of the insertion process is always tracked by `hole`, which\n            // serves two purposes:\n            // 1. Protects integrity of `v` from panics in `is_less`.\n            // 2. Fills the remaining hole in `v` in the end.\n            //\n            // Panic safety:\n            //\n            // If `is_less` panics at any point during the process, `hole` will get dropped and\n            // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object it\n            // initially held exactly once.\n            let mut hole = InsertionHole {\n                src: &mut *tmp,\n                dest: &mut v[1],\n            };\n            ptr::copy_nonoverlapping(&v[1], &mut v[0], 1);\n\n            for i in 2..v.len() {\n                if !is_less(&v[i], &*tmp)? {\n                    break;\n                }\n                ptr::copy_nonoverlapping(&v[i], &mut v[i - 1], 1);\n                hole.dest = &mut v[i];\n            }\n            // `hole` gets dropped and thus copies `tmp` into the remaining hole in `v`.\n        }\n    }\n    // When dropped, copies from `src` into `dest`.\n    struct InsertionHole<T> {\n        src: *mut T,\n        dest: *mut T,\n    }\n\n    impl<T> Drop for InsertionHole<T> {\n        fn drop(&mut self) {\n            unsafe {\n                ptr::copy_nonoverlapping(self.src, self.dest, 1);\n            }\n        }\n    }\n    Some(())\n}"
}