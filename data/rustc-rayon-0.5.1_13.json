{
    "level": "Warning",
    "analyzer": "UnsafeDataflow",
    "op_type": "ReadFlow/Transmute",
    "description": "Potential unsafe dataflow issue in `slice::quicksort::shift_tail`",
    "file": "rustc-rayon-0.5.1/src/slice/quicksort.rs",
    "start_line": 93,
    "start_col": 1,
    "end_line": 136,
    "end_col": 2,
    "code_snippet": "fn shift_tail<T, F>(v: &mut [T], is_less: &F)\nwhere\n    F: Fn(&T, &T) -> bool,\n{\n    let len = v.len();\n    // SAFETY: The unsafe operations below involves indexing without a bound check (by offsetting a\n    // pointer) and copying memory (`ptr::copy_nonoverlapping`).\n    //\n    // a. Indexing:\n    //  1. We checked the size of the array to >= 2.\n    //  2. All the indexing that we will do is always between `0 <= index < len-1` at most.\n    //\n    // b. Memory copying\n    //  1. We are obtaining pointers to references which are guaranteed to be valid.\n    //  2. They cannot overlap because we obtain pointers to difference indices of the slice.\n    //     Namely, `i` and `i+1`.\n    //  3. If the slice is properly aligned, the elements are properly aligned.\n    //     It is the caller's responsibility to make sure the slice is properly aligned.\n    //\n    // See comments below for further detail.\n    unsafe {\n        // If the last two elements are out-of-order...\n        if len >= 2 && is_less(v.get_unchecked(len - 1), v.get_unchecked(len - 2)) {\n            // Read the last element into a stack-allocated variable. If a following comparison\n            // operation panics, `hole` will get dropped and automatically write the element back\n            // into the slice.\n            let tmp = mem::ManuallyDrop::new(ptr::read(v.get_unchecked(len - 1)));\n            let v = v.as_mut_ptr();\n            let mut hole = CopyOnDrop::new(&*tmp, v.add(len - 2));\n            ptr::copy_nonoverlapping(v.add(len - 2), v.add(len - 1), 1);\n\n            for i in (0..len - 2).rev() {\n                if !is_less(&*tmp, &*v.add(i)) {\n                    break;\n                }\n\n                // Move `i`-th element one place to the right, thus shifting the hole to the left.\n                ptr::copy_nonoverlapping(v.add(i), v.add(i + 1), 1);\n                hole.dest = v.add(i);\n            }\n            // `hole` gets dropped and thus copies `tmp` into the remaining hole in `v`.\n        }\n    }\n}"
}