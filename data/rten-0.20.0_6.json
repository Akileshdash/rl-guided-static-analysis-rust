{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `ops::binary_elementwise::binary_op`",
    "file": "rten-0.20.0/src/ops/binary_elementwise.rs",
    "start_line": 141,
    "start_col": 1,
    "end_line": 239,
    "end_col": 2,
    "code_snippet": "pub fn binary_op<T: Copy, U: Copy, R, F: Fn(T, U) -> R>(\n    pool: &TensorPool,\n    a: TensorView<T>,\n    b: TensorView<U>,\n    op: F,\n) -> Result<Tensor<R>, OpError> {\n    let out_shape = broadcast_shapes(a.shape(), b.shape())\n        .ok_or(OpError::IncompatibleInputShapes(\"Cannot broadcast inputs\"))?;\n\n    // Fast path for when LHS and RHS are contiguous, and fast broadcasting is\n    // possible.\n    if let (true, Some(a_data), Some(b_data)) =\n        (a.shape() == out_shape.as_slice(), a.data(), b.data())\n    {\n        if let Some((cycles, repeats)) = fast_broadcast_cycles_repeats(b.shape(), a.shape()) {\n            assert!(cycles * b_data.len() * repeats == a.len());\n\n            let mut output = Tensor::uninit_in(pool, &out_shape);\n\n            // Unsafe access used to skip bounds checks in inner loop.\n            let out_data = output.data_mut().unwrap();\n            let a_ptr = a_data.as_ptr();\n\n            let mut i = 0;\n            for _ in 0..cycles {\n                if repeats == 1 {\n                    for b_elt in b_data {\n                        // Safety: We checked the total loop count is in `[0,\n                        // out_data.len())` above, which is the same as\n                        // `a_data.len().\n                        let (a_elt, out_elt) =\n                            unsafe { (*a_ptr.add(i), out_data.get_unchecked_mut(i)) };\n                        out_elt.write(op(a_elt, *b_elt));\n                        i += 1;\n                    }\n                } else {\n                    for b_elt in b_data {\n                        for _ in 0..repeats {\n                            // Safety: We checked the total loop count is in `[0,\n                            // out_data.len())` above, which is the same as\n                            // `a_data.len().\n                            let (a_elt, out_elt) =\n                                unsafe { (*a_ptr.add(i), out_data.get_unchecked_mut(i)) };\n                            out_elt.write(op(a_elt, *b_elt));\n                            i += 1;\n                        }\n                    }\n                }\n            }\n\n            // Safety: We initialized all output elements.\n            assert!(i == output.len());\n            let output = unsafe { output.assume_init() };\n            return Ok(output);\n        }\n    }\n\n    let mut a = a.broadcast(out_shape.as_slice());\n    let mut b = b.broadcast(out_shape.as_slice());\n    let mut out_data = pool.alloc(a.len());\n    let out_uninit = &mut out_data.spare_capacity_mut()[..a.len()];\n    let mut out_offset = 0;\n\n    // Loop over a statically known number of inner dims for efficiency.\n    while a.ndim() <= 4 {\n        a.insert_axis(0);\n        b.insert_axis(0);\n    }\n\n    a.inner_iter::<4>()\n        .zip(b.inner_iter::<4>())\n        .for_each(|(a, b)| {\n            for i0 in 0..a.size(0) {\n                for i1 in 0..a.size(1) {\n                    for i2 in 0..a.size(2) {\n                        for i3 in 0..a.size(3) {\n                            // Safety:\n                            // - `a` and `b` have the same shape, and i0..i3 are in `[0, a.size(i))`.\n                            // - The length of `out_uninit` is the same as `a.len()`.\n                            unsafe {\n                                let a_elt = a.get_unchecked([i0, i1, i2, i3]);\n                                let b_elt = b.get_unchecked([i0, i1, i2, i3]);\n                                out_uninit\n                                    .get_unchecked_mut(out_offset)\n                                    .write(op(*a_elt, *b_elt));\n                                out_offset += 1;\n                            }\n                        }\n                    }\n                }\n            }\n        });\n\n    // Safety: We initialized `out_offset` elements.\n    unsafe {\n        out_data.set_len(out_offset);\n    }\n    Ok(Tensor::from_data(&out_shape, out_data))\n}"
}