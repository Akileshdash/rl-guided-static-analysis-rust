{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `avx::avx_raders::RadersAvx2::<A, T>::perform_fft_immut`",
    "file": "rustfft-6.4.0/src/avx/avx_raders.rs",
    "start_line": 356,
    "start_col": 5,
    "end_line": 412,
    "end_col": 6,
    "code_snippet": "fn perform_fft_immut(\n        &self,\n        input: &[Complex<T>],\n        output: &mut [Complex<T>],\n        scratch: &mut [Complex<T>],\n    ) {\n        unsafe {\n            // Specialization workaround: See the comments in FftPlannerAvx::new() for why these calls to array_utils::workaround_transmute are necessary\n            let transmuted_input: &[Complex<A>] = array_utils::workaround_transmute(input);\n            let transmuted_output: &mut [Complex<A>] =\n                array_utils::workaround_transmute_mut(output);\n            self.prepare_raders(transmuted_input, transmuted_output)\n        }\n\n        let (first_input, _) = input.split_first().unwrap();\n        let (first_output, inner_output) = output.split_first_mut().unwrap();\n        let (scratch2, extra_scratch) = scratch.split_at_mut(self.len());\n        let (_, scratch) = scratch2.split_first_mut().unwrap();\n\n        self.inner_fft.process_with_scratch(inner_output, scratch);\n\n        // inner_output[0] now contains the sum of elements 1..n. we want the sum of all inputs, so all we need to do is add the first input\n        *first_output = inner_output[0] + *first_input;\n\n        // multiply the inner result with our cached setup data\n        // also conjugate every entry. this sets us up to do an inverse FFT\n        // (because an inverse FFT is equivalent to a normal FFT where you conjugate both the inputs and outputs)\n        unsafe {\n            // Specialization workaround: See the comments in FftPlannerAvx::new() for why these calls to array_utils::workaround_transmute are necessary\n            let transmuted_inner_input: &mut [Complex<A>] =\n                array_utils::workaround_transmute_mut(scratch);\n            let transmuted_inner_output: &mut [Complex<A>] =\n                array_utils::workaround_transmute_mut(inner_output);\n            avx_vector::pairwise_complex_mul_conjugated(\n                transmuted_inner_output,\n                transmuted_inner_input,\n                &self.twiddles,\n            )\n        };\n\n        // We need to add the first input value to all output values. We can accomplish this by adding it to the DC input of our inner ifft.\n        // Of course, we have to conjugate it, just like we conjugated the complex multiplied above\n        scratch[0] = scratch[0] + first_input.conj();\n\n        self.inner_fft.process_with_scratch(scratch, extra_scratch);\n        scratch2[0] = *first_input;\n\n        // copy the final values into the output, reordering as we go\n        unsafe {\n            // Specialization workaround: See the comments in FftPlannerAvx::new() for why these calls to array_utils::workaround_transmute are necessary\n            let transmuted_input: &mut [Complex<A>] =\n                array_utils::workaround_transmute_mut(scratch2);\n            let transmuted_output: &mut [Complex<A>] =\n                array_utils::workaround_transmute_mut(output);\n            self.finalize_raders(transmuted_input, transmuted_output);\n        }\n    }"
}