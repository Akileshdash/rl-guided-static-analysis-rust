{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<stream::futures_unordered::FuturesUnordered<Fut> as futures_core::Stream>::poll_next`",
    "file": "futures-util-0.3.31/src/stream/futures_unordered/mod.rs",
    "start_line": 400,
    "start_col": 5,
    "end_line": 554,
    "end_col": 6,
    "code_snippet": "fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n        let len = self.len();\n\n        // Keep track of how many child futures we have polled,\n        // in case we want to forcibly yield.\n        let mut polled = 0;\n        let mut yielded = 0;\n\n        // Ensure `parent` is correctly set.\n        self.ready_to_run_queue.waker.register(cx.waker());\n\n        loop {\n            // Safety: &mut self guarantees the mutual exclusion `dequeue`\n            // expects\n            let task = match unsafe { self.ready_to_run_queue.dequeue() } {\n                Dequeue::Empty => {\n                    if self.is_empty() {\n                        // We can only consider ourselves terminated once we\n                        // have yielded a `None`\n                        *self.is_terminated.get_mut() = true;\n                        return Poll::Ready(None);\n                    } else {\n                        return Poll::Pending;\n                    }\n                }\n                Dequeue::Inconsistent => {\n                    // At this point, it may be worth yielding the thread &\n                    // spinning a few times... but for now, just yield using the\n                    // task system.\n                    cx.waker().wake_by_ref();\n                    return Poll::Pending;\n                }\n                Dequeue::Data(task) => task,\n            };\n\n            debug_assert!(task != self.ready_to_run_queue.stub());\n\n            // Safety:\n            // - `task` is a valid pointer.\n            // - We are the only thread that accesses the `UnsafeCell` that\n            //   contains the future\n            let future = match unsafe { &mut *(*task).future.get() } {\n                Some(future) => future,\n\n                // If the future has already gone away then we're just\n                // cleaning out this task. See the comment in\n                // `release_task` for more information, but we're basically\n                // just taking ownership of our reference count here.\n                None => {\n                    // This case only happens when `release_task` was called\n                    // for this task before and couldn't drop the task\n                    // because it was already enqueued in the ready to run\n                    // queue.\n\n                    // Safety: `task` is a valid pointer\n                    let task = unsafe { Arc::from_raw(task) };\n\n                    // Double check that the call to `release_task` really\n                    // happened. Calling it required the task to be unlinked.\n                    debug_assert_eq!(task.next_all.load(Relaxed), self.pending_next_all());\n                    unsafe {\n                        debug_assert!((*task.prev_all.get()).is_null());\n                    }\n                    continue;\n                }\n            };\n\n            // Safety: `task` is a valid pointer\n            let task = unsafe { self.unlink(task) };\n\n            // Unset queued flag: This must be done before polling to ensure\n            // that the future's task gets rescheduled if it sends a wake-up\n            // notification **during** the call to `poll`.\n            let prev = task.queued.swap(false, SeqCst);\n            assert!(prev);\n\n            // We're going to need to be very careful if the `poll`\n            // method below panics. We need to (a) not leak memory and\n            // (b) ensure that we still don't have any use-after-frees. To\n            // manage this we do a few things:\n            //\n            // * A \"bomb\" is created which if dropped abnormally will call\n            //   `release_task`. That way we'll be sure the memory management\n            //   of the `task` is managed correctly. In particular\n            //   `release_task` will drop the future. This ensures that it is\n            //   dropped on this thread and not accidentally on a different\n            //   thread (bad).\n            // * We unlink the task from our internal queue to preemptively\n            //   assume it'll panic, in which case we'll want to discard it\n            //   regardless.\n            struct Bomb<'a, Fut> {\n                queue: &'a mut FuturesUnordered<Fut>,\n                task: Option<Arc<Task<Fut>>>,\n            }\n\n            impl<Fut> Drop for Bomb<'_, Fut> {\n                fn drop(&mut self) {\n                    if let Some(task) = self.task.take() {\n                        self.queue.release_task(task);\n                    }\n                }\n            }\n\n            let mut bomb = Bomb { task: Some(task), queue: &mut *self };\n\n            // Poll the underlying future with the appropriate waker\n            // implementation. This is where a large bit of the unsafety\n            // starts to stem from internally. The waker is basically just\n            // our `Arc<Task<Fut>>` and can schedule the future for polling by\n            // enqueuing itself in the ready to run queue.\n            //\n            // Critically though `Task<Fut>` won't actually access `Fut`, the\n            // future, while it's floating around inside of wakers.\n            // These structs will basically just use `Fut` to size\n            // the internal allocation, appropriately accessing fields and\n            // deallocating the task if need be.\n            let res = {\n                let task = bomb.task.as_ref().unwrap();\n                // We are only interested in whether the future is awoken before it\n                // finishes polling, so reset the flag here.\n                task.woken.store(false, Relaxed);\n                // SAFETY: see the comments of Bomb and this block.\n                let waker = unsafe { Task::waker_ref(task) };\n                let mut cx = Context::from_waker(&waker);\n\n                // Safety: We won't move the future ever again\n                let future = unsafe { Pin::new_unchecked(future) };\n\n                future.poll(&mut cx)\n            };\n            polled += 1;\n\n            match res {\n                Poll::Pending => {\n                    let task = bomb.task.take().unwrap();\n                    // If the future was awoken during polling, we assume\n                    // the future wanted to explicitly yield.\n                    yielded += task.woken.load(Relaxed) as usize;\n                    bomb.queue.link(task);\n\n                    // If a future yields, we respect it and yield here.\n                    // If all futures have been polled, we also yield here to\n                    // avoid starving other tasks waiting on the executor.\n                    // (polling the same future twice per iteration may cause\n                    // the problem: https://github.com/rust-lang/futures-rs/pull/2333)\n                    if yielded >= 2 || polled == len {\n                        cx.waker().wake_by_ref();\n                        return Poll::Pending;\n                    }\n                    continue;\n                }\n                Poll::Ready(output) => return Poll::Ready(Some(output)),\n            }\n        }\n    }"
}