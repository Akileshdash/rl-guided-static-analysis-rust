{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<keyexpr_tree::iters::includer::IncluderMut<'a, Children, Node, Weight> as std::iter::Iterator>::next`",
    "file": "zenoh-keyexpr-1.5.0/src/keyexpr_tree/iters/includer.rs",
    "start_line": 233,
    "start_col": 5,
    "end_line": 337,
    "end_col": 6,
    "code_snippet": "fn next(&mut self) -> Option<Self::Item> {\n        loop {\n            let StackFrameMut {\n                iterator,\n                start,\n                end,\n                _marker,\n            } = self.iterators.last_mut()?;\n            match iterator.next() {\n                Some(node) => {\n                    let mut node_matches = false;\n                    let new_start = *end;\n                    let mut new_end = *end;\n                    macro_rules! push {\n                        ($index: expr) => {\n                            let index = $index;\n                            if new_end == new_start\n                                || self.ke_indices[new_start..new_end]\n                                    .iter()\n                                    .rev()\n                                    .all(|c| *c < index)\n                            {\n                                self.ke_indices.push(index);\n                                new_end += 1;\n                            }\n                        };\n                    }\n                    let chunk = node.chunk();\n                    let chunk_is_super = chunk == \"**\";\n                    if chunk_is_super {\n                        let mut latest_idx = usize::MAX;\n                        'outer: for i in *start..*end {\n                            let mut kec_start = self.ke_indices[i];\n                            if kec_start == self.key.len() {\n                                node_matches = true;\n                                break;\n                            }\n                            if latest_idx <= kec_start && latest_idx != usize::MAX {\n                                continue;\n                            }\n                            loop {\n                                push!(kec_start);\n                                latest_idx = kec_start;\n                                let key = &self.key.as_bytes()[kec_start..];\n                                if key[0] == b'@' {\n                                    break;\n                                }\n                                match key.iter().position(|&c| c == b'/') {\n                                    Some(kec_end) => kec_start += kec_end + 1,\n                                    None => {\n                                        node_matches = true;\n                                        break 'outer;\n                                    }\n                                }\n                            }\n                        }\n                    } else {\n                        for i in *start..*end {\n                            let kec_start = self.ke_indices[i];\n                            if kec_start == self.key.len() {\n                                break;\n                            }\n                            let key = &self.key.as_bytes()[kec_start..];\n                            unsafe { keyexpr::from_slice_unchecked(key) };\n                            match key.iter().position(|&c| c == b'/') {\n                                Some(kec_end) => {\n                                    let subkey =\n                                        unsafe { keyexpr::from_slice_unchecked(&key[..kec_end]) };\n                                    if chunk.includes(subkey) {\n                                        push!(kec_start + kec_end + 1);\n                                    }\n                                }\n                                None => {\n                                    let key = unsafe { keyexpr::from_slice_unchecked(key) };\n                                    if chunk.includes(key) {\n                                        push!(self.key.len());\n                                        node_matches = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if new_end > new_start {\n                        let iterator = unsafe { &mut *(node.as_node_mut() as *mut Node) }\n                            .children_mut()\n                            .children_mut();\n                        self.iterators.push(StackFrameMut {\n                            iterator,\n                            start: new_start,\n                            end: new_end,\n                            _marker: Default::default(),\n                        })\n                    }\n                    if node_matches {\n                        return Some(node);\n                    }\n                }\n                None => {\n                    if let Some(StackFrameMut { start, .. }) = self.iterators.pop() {\n                        self.ke_indices.truncate(start);\n                    }\n                }\n            }\n        }\n    }"
}