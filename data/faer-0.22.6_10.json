{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `sort::partition_in_blocks`",
    "file": "faer-0.22.6/src/sort.rs",
    "start_line": 397,
    "start_col": 1,
    "end_line": 650,
    "end_col": 2,
    "code_snippet": "unsafe fn partition_in_blocks<P: Ptr, F: FnMut(P, P) -> bool>(v: P, v_len: usize, pivot: P, is_less: &mut F) -> usize {\n\t// Number of elements in a typical block.\n\tconst BLOCK: usize = 128;\n\n\t// The partitioning algorithm repeats the following steps until completion:\n\t//\n\t// 1. Trace a block from the left side to identify elements greater than or equal to the pivot.\n\t// 2. Trace a block from the right side to identify elements smaller than the pivot.\n\t// 3. Exchange the identified elements between the left and right side.\n\t//\n\t// We keep the following variables for a block of elements:\n\t//\n\t// 1. `block` - Number of elements in the block.\n\t// 2. `start` - Start pointer into the `offsets` array.\n\t// 3. `end` - End pointer into the `offsets` array.\n\t// 4. `offsets` - Indices of out-of-order elements within the block.\n\n\t// The current block on the left side (from `l` to `l.add(block_l)`).\n\tlet mut l = v;\n\tlet mut block_l = BLOCK;\n\tlet mut start_l = core::ptr::null_mut();\n\tlet mut end_l = core::ptr::null_mut();\n\tlet mut offsets_l = [core::mem::MaybeUninit::<u8>::uninit(); BLOCK];\n\n\t// The current block on the right side (from `r.sub(block_r)` to `r`).\n\t// SAFETY: The documentation for .add() specifically mention that `vec.as_ptr().add(vec.len())`\n\t// is always safe\n\tlet mut r = unsafe { l.add(v_len) };\n\tlet mut block_r = BLOCK;\n\tlet mut start_r = core::ptr::null_mut();\n\tlet mut end_r = core::ptr::null_mut();\n\tlet mut offsets_r = [core::mem::MaybeUninit::<u8>::uninit(); BLOCK];\n\n\t// FIXME: When we get VLAs, try creating one array of length `min(v.len(), 2 * BLOCK)` rather\n\t// than two fixed-size arrays of length `BLOCK`. VLAs might be more cache-efficient.\n\n\t// Returns the number of elements between pointers `l` (inclusive) and `r` (exclusive).\n\tunsafe fn width<P: Ptr>(l: P, r: P) -> usize {\n\t\tr.offset_from(l) as usize\n\t}\n\n\tloop {\n\t\t// We are done with partitioning block-by-block when `l` and `r` get very close. Then we do\n\t\t// some patch-up work in order to partition the remaining elements in between.\n\t\tlet is_done = width(l, r) <= 2 * BLOCK;\n\n\t\tif is_done {\n\t\t\t// Number of remaining elements (still not compared to the pivot).\n\t\t\tlet mut rem = width(l, r);\n\t\t\tif start_l < end_l || start_r < end_r {\n\t\t\t\trem -= BLOCK;\n\t\t\t}\n\n\t\t\t// Adjust block sizes so that the left and right block don't overlap, but get perfectly\n\t\t\t// aligned to cover the whole remaining gap.\n\t\t\tif start_l < end_l {\n\t\t\t\tblock_r = rem;\n\t\t\t} else if start_r < end_r {\n\t\t\t\tblock_l = rem;\n\t\t\t} else {\n\t\t\t\t// There were the same number of elements to switch on both blocks during the last\n\t\t\t\t// iteration, so there are no remaining elements on either block. Cover the\n\t\t\t\t// remaining items with roughly equally-sized blocks.\n\t\t\t\tblock_l = rem / 2;\n\t\t\t\tblock_r = rem - block_l;\n\t\t\t}\n\t\t\tdebug_assert!(block_l <= BLOCK && block_r <= BLOCK);\n\t\t\tdebug_assert!(width(l, r) == block_l + block_r);\n\t\t}\n\n\t\tif start_l == end_l {\n\t\t\t// Trace `block_l` elements from the left side.\n\t\t\tstart_l = offsets_l.as_mut_ptr() as *mut u8;\n\t\t\tend_l = start_l;\n\t\t\tlet mut elem = l;\n\n\t\t\tfor i in 0..block_l {\n\t\t\t\t// SAFETY: The unsafety operations below involve the usage of the `offset`.\n\t\t\t\t//         According to the conditions required by the function, we satisfy them\n\t\t\t\t// because:\n\t\t\t\t//         1. `offsets_l` is stack-allocated, and thus considered separate allocated object.\n\t\t\t\t//         2. The function `is_less` returns a `bool`. Casting a `bool` will never overflow `isize`.\n\t\t\t\t//         3. We have guaranteed that `block_l` will be `<= BLOCK`. Plus, `end_l` was initially set\n\t\t\t\t//            to the begin pointer of `offsets_` which was declared on the stack. Thus, we know that\n\t\t\t\t//            even in the worst case (all invocations of `is_less` returns false) we will only be at\n\t\t\t\t//            most 1 byte pass the end.\n\t\t\t\t//        Another unsafety operation here is dereferencing `elem`.\n\t\t\t\t//        However, `elem` was initially the begin pointer to the slice which is\n\t\t\t\t// always valid.\n\t\t\t\tunsafe {\n\t\t\t\t\t// Branchless comparison.\n\t\t\t\t\t*end_l = i as u8;\n\t\t\t\t\tend_l = end_l.add(!is_less(elem, pivot) as usize);\n\t\t\t\t\telem = elem.add(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif start_r == end_r {\n\t\t\t// Trace `block_r` elements from the right side.\n\t\t\tstart_r = offsets_r.as_mut_ptr() as *mut u8;\n\t\t\tend_r = start_r;\n\t\t\tlet mut elem = r;\n\n\t\t\tfor i in 0..block_r {\n\t\t\t\t// SAFETY: The unsafety operations below involve the usage of the `offset`.\n\t\t\t\t//         According to the conditions required by the function, we satisfy them\n\t\t\t\t// because:\n\t\t\t\t//         1. `offsets_r` is stack-allocated, and thus considered separate allocated object.\n\t\t\t\t//         2. The function `is_less` returns a `bool`. Casting a `bool` will never overflow `isize`.\n\t\t\t\t//         3. We have guaranteed that `block_r` will be `<= BLOCK`. Plus, `end_r` was initially set\n\t\t\t\t//            to the begin pointer of `offsets_` which was declared on the stack. Thus, we know that\n\t\t\t\t//            even in the worst case (all invocations of `is_less` returns true) we will only be at\n\t\t\t\t//            most 1 byte pass the end.\n\t\t\t\t//        Another unsafety operation here is dereferencing `elem`.\n\t\t\t\t//        However, `elem` was initially `1 * sizeof(T)` past the end and we\n\t\t\t\t// decrement it by `1 * sizeof(T)` before accessing it.        Plus,\n\t\t\t\t// `block_r` was asserted to be less than `BLOCK` and `elem` will therefore at most\n\t\t\t\t// be pointing to the beginning of the slice.\n\t\t\t\tunsafe {\n\t\t\t\t\t// Branchless comparison.\n\t\t\t\t\telem = elem.sub(1);\n\t\t\t\t\t*end_r = i as u8;\n\t\t\t\t\tend_r = end_r.add(is_less(elem, pivot) as usize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Number of out-of-order elements to swap between the left and right side.\n\t\tlet count = Ord::min(width(start_l, end_l), width(start_r, end_r));\n\n\t\tif count > 0 {\n\t\t\tmacro_rules! left {\n\t\t\t\t() => {\n\t\t\t\t\tl.add(usize::from(*start_l))\n\t\t\t\t};\n\t\t\t}\n\t\t\tmacro_rules! right {\n\t\t\t\t() => {\n\t\t\t\t\tr.sub(usize::from(*start_r) + 1)\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Instead of swapping one pair at the time, it is more efficient to perform a cyclic\n\t\t\t// permutation. This is not strictly equivalent to swapping, but produces a similar\n\t\t\t// result using fewer memory operations.\n\n\t\t\t// SAFETY: The use of `ptr::read` is valid because there is at least one element in\n\t\t\t// both `offsets_l` and `offsets_r`, so `left!` is a valid pointer to read from.\n\t\t\t//\n\t\t\t// The uses of `left!` involve calls to `offset` on `l`, which points to the\n\t\t\t// beginning of `v`. All the offsets pointed-to by `start_l` are at most `block_l`, so\n\t\t\t// these `offset` calls are safe as all reads are within the block. The same argument\n\t\t\t// applies for the uses of `right!`.\n\t\t\t//\n\t\t\t// The calls to `start_l.offset` are valid because there are at most `count-1` of them,\n\t\t\t// plus the final one at the end of the unsafe block, where `count` is the minimum\n\t\t\t// number of collected offsets in `offsets_l` and `offsets_r`, so there is\n\t\t\t// no risk of there not being enough elements. The same reasoning applies to\n\t\t\t// the calls to `start_r.offset`.\n\t\t\t//\n\t\t\t// The calls to `copy_nonoverlapping` are safe because `left!` and `right!` are\n\t\t\t// guaranteed not to overlap, and are valid because of the reasoning above.\n\t\t\tunsafe {\n\t\t\t\tlet tmp = P::read(left!());\n\t\t\t\tlet tmp_ptr = P::get_ptr(&tmp as *const P::Item as *mut P::Item);\n\t\t\t\tP::copy_nonoverlapping(right!(), left!(), 1);\n\n\t\t\t\tfor _ in 1..count {\n\t\t\t\t\tstart_l = start_l.add(1);\n\t\t\t\t\tP::copy_nonoverlapping(left!(), right!(), 1);\n\t\t\t\t\tstart_r = start_r.add(1);\n\t\t\t\t\tP::copy_nonoverlapping(right!(), left!(), 1);\n\t\t\t\t}\n\n\t\t\t\tP::copy_nonoverlapping(tmp_ptr, right!(), 1);\n\t\t\t\t// core::mem::forget(tmp);\n\t\t\t\tstart_l = start_l.add(1);\n\t\t\t\tstart_r = start_r.add(1);\n\t\t\t}\n\t\t}\n\n\t\tif start_l == end_l {\n\t\t\t// All out-of-order elements in the left block were moved. Move to the next block.\n\n\t\t\t// block-width-guarantee\n\t\t\t// SAFETY: if `!is_done` then the slice width is guaranteed to be at least `2*BLOCK`\n\t\t\t// wide. There are at most `BLOCK` elements in `offsets_l` because of its\n\t\t\t// size, so the `offset` operation is safe. Otherwise, the debug assertions\n\t\t\t// in the `is_done` case guarantee that `width(l, r) == block_l + block_r`,\n\t\t\t// namely, that the block sizes have been adjusted to account\n\t\t\t// for the smaller number of remaining elements.\n\t\t\tl = unsafe { l.add(block_l) };\n\t\t}\n\n\t\tif start_r == end_r {\n\t\t\t// All out-of-order elements in the right block were moved. Move to the previous block.\n\n\t\t\t// SAFETY: Same argument as [block-width-guarantee]. Either this is a full block\n\t\t\t// `2*BLOCK`-wide, or `block_r` has been adjusted for the last handful of\n\t\t\t// elements.\n\t\t\tr = unsafe { r.sub(block_r) };\n\t\t}\n\n\t\tif is_done {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// All that remains now is at most one block (either the left or the right) with out-of-order\n\t// elements that need to be moved. Such remaining elements can be simply shifted to the end\n\t// within their block.\n\n\tif start_l < end_l {\n\t\t// The left block remains.\n\t\t// Move its remaining out-of-order elements to the far right.\n\t\tdebug_assert_eq!(width(l, r), block_l);\n\t\twhile start_l < end_l {\n\t\t\t// remaining-elements-safety\n\t\t\t// SAFETY: while the loop condition holds there are still elements in `offsets_l`, so it\n\t\t\t// is safe to point `end_l` to the previous element.\n\t\t\t//\n\t\t\t// The `ptr::swap` is safe if both its arguments are valid for reads and writes:\n\t\t\t//  - Per the debug assert above, the distance between `l` and `r` is `block_l` elements, so there\n\t\t\t//    can be at most `block_l` remaining offsets between `start_l` and `end_l`. This means `r` will\n\t\t\t//    be moved at most `block_l` steps back, which makes the `r.offset` calls valid (at that point\n\t\t\t//    `l == r`).\n\t\t\t//  - `offsets_l` contains valid offsets into `v` collected during the partitioning of the last\n\t\t\t//    block, so the `l.offset` calls are valid.\n\t\t\tunsafe {\n\t\t\t\tend_l = end_l.sub(1);\n\t\t\t\tP::swap(l.add(usize::from(*end_l)), r.sub(1));\n\t\t\t\tr = r.sub(1);\n\t\t\t}\n\t\t}\n\t\twidth(v, r)\n\t} else if start_r < end_r {\n\t\t// The right block remains.\n\t\t// Move its remaining out-of-order elements to the far left.\n\t\tdebug_assert_eq!(width(l, r), block_r);\n\t\twhile start_r < end_r {\n\t\t\t// SAFETY: See the reasoning in [remaining-elements-safety].\n\t\t\tunsafe {\n\t\t\t\tend_r = end_r.sub(1);\n\t\t\t\tP::swap(l, r.sub(usize::from(*end_r) + 1));\n\t\t\t\tl = l.add(1);\n\t\t\t}\n\t\t}\n\t\twidth(v, l)\n\t} else {\n\t\t// Nothing else to do, we're done.\n\t\twidth(v, l)\n\t}\n}"
}