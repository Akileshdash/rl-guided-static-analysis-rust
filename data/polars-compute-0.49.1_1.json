{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `rolling::quantile_filter::rolling_quantile`",
    "file": "polars-compute-0.49.1/src/rolling/quantile_filter.rs",
    "start_line": 671,
    "start_col": 1,
    "end_line": 776,
    "end_col": 2,
    "code_snippet": "pub(super) fn rolling_quantile<A, Out: Pushable<<A as Indexable>::Item>>(\n    method: QuantileMethod,\n    min_periods: usize,\n    k: usize,\n    values: A,\n    quantile: f64,\n) -> Out\nwhere\n    A: Indexable + SliceAble + Bounded + NullCount + Clone,\n    <A as Indexable>::Item: Default + TotalOrd + Copy + FinishLinear + Debug,\n{\n    let mut scratch_left = vec![];\n    let mut prev_left = vec![];\n    let mut next_left = vec![];\n\n    let mut scratch_right = vec![];\n    let mut prev_right = vec![];\n    let mut next_right = vec![];\n\n    let k = std::cmp::min(k, values.len());\n    let alpha = values.slice(0..k);\n\n    let mut out = Out::with_capacity(values.len());\n\n    let scratch_right_ptr = &mut scratch_right as *mut Vec<u8>;\n    let scratch_left_ptr = &mut scratch_left as *mut Vec<u8>;\n    let prev_right_ptr = &mut prev_right as *mut Vec<_>;\n    let prev_left_ptr = &mut prev_left as *mut Vec<_>;\n    let next_right_ptr = &mut next_right as *mut Vec<_>;\n    let next_left_ptr = &mut next_left as *mut Vec<_>;\n\n    let n_blocks = values.len() / k;\n\n    let mut block_left = unsafe {\n        Block::new(\n            alpha,\n            &mut *scratch_left_ptr,\n            &mut *prev_left_ptr,\n            &mut *next_left_ptr,\n        )\n    };\n    let mut block_right = unsafe {\n        Block::new(\n            values.slice(0..1),\n            &mut *scratch_right_ptr,\n            &mut *prev_right_ptr,\n            &mut *next_right_ptr,\n        )\n    };\n\n    let ptr_left = &mut block_left as *mut Block<'_, _>;\n    let ptr_right = &mut block_right as *mut Block<'_, _>;\n\n    block_left.unwind();\n\n    for i in 0..block_left.capacity() {\n        // SAFETY: bounded by capacity\n        unsafe { block_left.undelete(i) };\n\n        let mut mu = QuantileUpdate::new(method, min_periods, quantile, &mut block_left);\n        out.push(mu.quantile());\n    }\n    for i in 1..n_blocks + 1 {\n        // Block left is now completely full as it is completely filled coming from the boundary effects.\n        debug_assert!(block_left.n_element == k);\n\n        // Windows state at this point.\n        //\n        //  - BLOCK_LEFT -- BLOCK_RIGHT -\n        // |-------------||-------------|\n        //   - WINDOW -\n        // |--------------|\n        let end = std::cmp::min((i + 1) * k, values.len());\n        let alpha = unsafe { values.slice_unchecked(i * k..end) };\n\n        if alpha.is_empty() {\n            break;\n        }\n\n        // Find the scratch that belongs to the left window that has gone out of scope\n        let (scratch, prev, next) = if i % 2 == 0 {\n            (scratch_left_ptr, prev_left_ptr, next_left_ptr)\n        } else {\n            (scratch_right_ptr, prev_right_ptr, next_right_ptr)\n        };\n\n        block_right = unsafe { Block::new(alpha, &mut *scratch, &mut *prev, &mut *next) };\n\n        // Time reverse the rhs so we can undelete in sorted order.\n        block_right.unwind();\n\n        // Here the window will move from BLOCK_LEFT into BLOCK_RIGHT\n        for j in 0..block_right.capacity() {\n            unsafe {\n                let mut union = BlockUnion::new(&mut *ptr_left, &mut *ptr_right);\n                union.set_state(j);\n                let q: <A as Indexable>::Item =\n                    QuantileUpdate::new(method, min_periods, quantile, union).quantile();\n                out.push(q);\n            }\n        }\n\n        std::mem::swap(&mut block_left, &mut block_right);\n    }\n    out\n}"
}