{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `armv7::thumb::decode_into`",
    "file": "yaxpeax-arm-0.3.1/src/armv7/thumb.rs",
    "start_line": 94,
    "start_col": 1,
    "end_line": 4229,
    "end_col": 2,
    "code_snippet": "pub fn decode_into<T: Reader<<ARMv7 as Arch>::Address, <ARMv7 as Arch>::Word>>(decoder: &InstDecoder, inst: &mut Instruction, words: &mut T) -> Result<(), <ARMv7 as Arch>::DecodeError> {\n    // these are cleared in `armv7::InstDecoder::decode_into`.\n    // they must be reset when switching out of thumb decoding or decoding a new thumb instruction,\n    // which that `decode_into` is the entrypoint for in all cases.\n    // inst.set_w(false);\n    // inst.set_wide(false);\n    inst.set_thumb(true);\n    let mut word_bytes = [0u8; 2];\n    words.next_n(&mut word_bytes)?;\n    let word = u16::from_le_bytes(word_bytes);\n    let instr = word;\n\n    let mut instr2 = bitarr![u16, Lsb0; 0u16; 16];\n    instr2[0..16].store(word);\n\n    let opword = instr2[11..].load::<u16>();\n\n    // `A6.1 Thumb instruction set encoding`\n    if opword >= 0b11101 {\n        inst.set_w(true);\n        inst.set_wide(true);\n\n        // 32b instruction - `A6-228, 32-bit Thumb instruction encoding`\n        // opword low bits 01, 10, and 11 correspond to `op1` in table `A6-9`\n\n        let mut word_bytes = [0u8; 2];\n        words.next_n(&mut word_bytes)?;\n        let lower = u16::from_le_bytes(word_bytes);\n\n        let mut lower2 = bitarr![u16, Lsb0; 0u16; 16];\n        lower2[0..16].store(lower);\n\n        let op2 = &instr2[4..11];\n\n        if opword == 0b11101 {\n            // op1 == 0b01\n            // interpret `op1 == 0b01` lines of table `A6-9`\n            if !op2[6] {\n                // `op2` is `0b00.. ` or `0b01..`\n                if !op2[5] {\n                    // `op2` is `00xxxxx`, and is `Load/store`, either `multiple` or `dual`\n                    let rn = instr2[..4].load::<u8>();\n                    // TODO: double check\n                    if op2[2] {\n                        // `Load/store dual, load/store exclusive, table branch` (`A6-236`)\n                        let op1op2 = (instr2[7..9].load::<u8>() << 2) | instr2[4..6].load::<u8>();\n                        let imm8 = lower2[..8].load::<u16>();\n                        let rd = lower2[8..12].load::<u8>();\n                        let rt = lower2[12..16].load::<u8>();\n\n                        // all only-wide, no w suffix\n                        inst.set_w(false);\n\n                        match op1op2 {\n                            0b0000 => {\n                                // `STREX` (`A8-691`)\n                                // v6T2\n                                if rd == 13 || rd == 15 || rt == 13 || rt == 15 || rn == 15 {\n                                    decoder.unpredictable()?;\n                                }\n                                if rd == rn || rd == rt {\n                                    decoder.unpredictable()?;\n                                }\n                                inst.opcode = Opcode::STREX;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Reg(Reg::from_u8(rt)),\n                                    // preindex for `[<Rn>, #<imm>]`, no writeback. imm is zero\n                                    // extended, so not signed; always add.\n                                    Operand::RegDerefPreindexOffset(\n                                        Reg::from_u8(rn),\n                                        imm8 << 2,\n                                        true,\n                                        false,\n                                    ),\n                                    Operand::Nothing,\n                                ];\n                            }\n                            0b0001 => {\n                                // `LDREX` (`A8-433`)\n                                // v6T2\n                                if rt == 13 || rt == 15 || rn == 15 {\n                                    decoder.unpredictable()?;\n                                }\n                                // TODO: should_is_must()\n                                // rd == 0b1111\n                                inst.opcode = Opcode::LDREX;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rt)),\n                                    // preindex for `[<Rn>, #<imm>]`, no writeback. imm is zero\n                                    // extended, so not signed; always add.\n                                    Operand::RegDerefPreindexOffset(\n                                        Reg::from_u8(rn),\n                                        imm8 << 2,\n                                        true,\n                                        false,\n                                    ),\n                                    Operand::Nothing,\n                                    Operand::Nothing,\n                                ];\n                            }\n                            0b0010 |\n                            0b0110 => {\n                                // `STRD (immediate)` (`A8-687`)\n                                // v6T2\n                                // bit 5 (w) == 0\n                                let w = false;\n                                let u = instr2[7];\n                                let p = instr2[8];\n                                // `if P == '0' && W == '0' then SEE \"Related encodings\"` -> this\n                                // would imply tbb/tbh, should be unreachable\n                                if rn == 15 || rt == 13 || rt == 15 || rd == 13 || rd == 15 {\n                                    decoder.unpredictable()?;\n                                }\n                                inst.opcode = Opcode::STRD;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rt)),\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    if p {\n                                        Operand::RegDerefPreindexOffset(Reg::from_u8(rn), imm8 << 2, u, w)\n                                    } else {\n                                        // p == 0 and w == 0 is impossible, would be tbb/tbh\n                                        Operand::RegDerefPostindexOffset(Reg::from_u8(rn), imm8 << 2, u, false)\n                                    },\n                                    Operand::Nothing,\n                                ];\n                            }\n                            0b0011 |\n                            0b0111 => {\n                                // `LDRD (immediate)`/`(literal)` (`A8-687`)\n                                // bit 5 (w) == 0\n                                let w = false;\n                                let u = instr2[7];\n                                let p = instr2[8];\n                                // `if P == '0' && W == '0' then SEE \"Related encodings\"` -> this\n                                // would imply tbb/tbh, should be unreachable\n                                if rt == 13 || rt == 15 || rd == 13 || rd == 15 || rd == rt {\n                                    decoder.unpredictable()?;\n                                }\n                                if w && (rn == rt || rn == rd) {\n                                    decoder.unpredictable()?;\n                                }\n                                if rn != 0b1111 {\n                                    // `LDRD (immediate)` (`A8-427`)\n                                    // v6T2\n                                    inst.opcode = Opcode::LDRD;\n                                    inst.operands = [\n                                        Operand::Reg(Reg::from_u8(rt)),\n                                        Operand::Reg(Reg::from_u8(rd)),\n                                        if p {\n                                            Operand::RegDerefPreindexOffset(Reg::from_u8(rn), imm8 << 2, u, w)\n                                        } else {\n                                            // p == 0 and w == 0 is impossible, would be tbb/tbh\n                                            Operand::RegDerefPostindexOffset(Reg::from_u8(rn), imm8 << 2, u, false)\n                                        },\n                                        Operand::Nothing,\n                                    ];\n                                } else {\n                                    // `LDRD (literal)` (`A8-429`)\n                                    // v6T2\n                                    if w {\n                                        decoder.unpredictable()?;\n                                    }\n                                    // which because !(p == 0 && w == 0), we know p is true\n                                    inst.opcode = Opcode::LDRD;\n                                    inst.operands = [\n                                        Operand::Reg(Reg::from_u8(rt)),\n                                        Operand::Reg(Reg::from_u8(rd)),\n                                        Operand::RegDerefPreindexOffset(Reg::from_u8(rn), imm8 << 2, u, false),\n                                        Operand::Nothing,\n                                    ];\n                                }\n                            }\n                            0b0100 => {\n                                // `STREX_`\n                                // v7\n                                let op3 = lower2[4..8].load::<u8>();\n                                let rt2 = rd;\n                                let rd = (imm8 & 0b1111) as u8;\n                                match op3 {\n                                    0b0100 => {\n                                        // `STREXB` (`A8-693`)\n                                        if rd == 13 || rd == 15 || rt == 13 || rt == 15 || rn == 15 {\n                                            decoder.unpredictable()?;\n                                        }\n                                        if rd == rn || rd == rt {\n                                            decoder.unpredictable()?;\n                                        }\n                                        // TODO: should_is_must()\n                                        // rt2 == 0b1111\n                                        inst.opcode = Opcode::STREXB;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rd)),\n                                            Operand::Reg(Reg::from_u8(rt)),\n                                            Operand::RegDeref(Reg::from_u8(rn)),\n                                            Operand::Nothing,\n                                        ];\n                                    }\n                                    0b0101 => {\n                                        // `STREXH` (`A8-693`)\n                                        if rd == 13 || rd == 15 || rt == 13 || rt == 15 || rn == 15 {\n                                            decoder.unpredictable()?;\n                                        }\n                                        if rd == rn || rd == rt {\n                                            decoder.unpredictable()?;\n                                        }\n                                        // TODO: should_is_must()\n                                        // rt2 == 0b1111\n                                        inst.opcode = Opcode::STREXH;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rd)),\n                                            Operand::Reg(Reg::from_u8(rt)),\n                                            Operand::RegDeref(Reg::from_u8(rn)),\n                                            Operand::Nothing,\n                                        ];\n                                    }\n                                    0b0111 => {\n                                        // `STREXD` (`A8-693`)\n                                        if rd == 13 || rd == 15 || rt == 13 || rt == 15 || rt2 == 13 || rt2 == 15 || rn == 15 {\n                                            decoder.unpredictable()?;\n                                        }\n                                        if rd == rn || rd == rt || rd == rt2 {\n                                            decoder.unpredictable()?;\n                                        }\n                                        inst.opcode = Opcode::STREXD;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rd)),\n                                            Operand::Reg(Reg::from_u8(rt)),\n                                            Operand::Reg(Reg::from_u8(rt2)),\n                                            Operand::RegDeref(Reg::from_u8(rn)),\n                                        ];\n                                    }\n                                    _ => {\n                                        return Err(DecodeError::Undefined);\n                                    }\n                                }\n                            }\n                            0b0101 => {\n                                // `TBB`/`TBH`/`LDREX_`\n                                let op3 = lower2[4..8].load::<u8>();\n                                let rt2 = rd;\n                                let rd = (imm8 & 0b1111) as u8;\n                                match op3 {\n                                    0b0000 => {\n                                        // `TBB`\n                                        // TODO: should_is_must()\n                                        // rt == 0b1111\n                                        // rd == 0b0000\n                                        inst.opcode = Opcode::TBB;\n                                        inst.operands = [\n                                            Operand::RegDerefPreindexReg(\n                                                Reg::from_u8(rn),\n                                                Reg::from_u8(rd),\n                                                true, // add\n                                                false, // no wback\n                                            ),\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    }\n                                    0b0001 => {\n                                        // `TBH`\n                                        // TODO: should_is_must()\n                                        // rt == 0b1111\n                                        // rd == 0b0000\n                                        inst.opcode = Opcode::TBB;\n                                        inst.operands = [\n                                            Operand::RegDerefPreindexRegShift(\n                                                Reg::from_u8(rn),\n                                                // want `<Rm>, LSL #1`, construct a raw shift\n                                                // ourselves\n                                                RegShift::from_raw(\n                                                    0b10000 |        // `RegImm`\n                                                    rd as u16 |            // reg == rd\n                                                    (0b00 << 5) |   // LSL\n                                                    (1 << 7)        // shift == #1\n                                                ),\n                                                true, // add\n                                                false, // no wback\n                                            ),\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    }\n                                    0b0100 => {\n                                        // `LDREXB`\n                                        if rt == 13 || rt == 15 || rn == 15 {\n                                            decoder.unpredictable()?;\n                                        }\n                                        // TODO: should_is_must()\n                                        // rt2 == 0b1111\n                                        // rd == 0b1111\n                                        inst.opcode = Opcode::LDREXB;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rt)),\n                                            Operand::RegDeref(Reg::from_u8(rn)),\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    }\n                                    0b0101 => {\n                                        // `LDREXH`\n                                        if rt == 13 || rt == 15 || rn == 15 {\n                                            decoder.unpredictable()?;\n                                        }\n                                        // TODO: should_is_must()\n                                        // rt2 == 0b1111\n                                        // rd == 0b1111\n                                        inst.opcode = Opcode::LDREXH;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rt)),\n                                            Operand::RegDeref(Reg::from_u8(rn)),\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    }\n                                    0b0110 => {\n                                        // `LDREXD`\n                                        if rt == 13 || rt == 15 || rt2 == 13 || rt2 == 15 || rn == 15 {\n                                            decoder.unpredictable()?;\n                                        }\n                                        // TODO: should_is_must()\n                                        // rd == 0b1111\n                                        inst.opcode = Opcode::LDREXD;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rt)),\n                                            Operand::Reg(Reg::from_u8(rt2)),\n                                            Operand::RegDeref(Reg::from_u8(rn)),\n                                            Operand::Nothing,\n                                        ];\n                                    }\n                                    _ => {\n                                        return Err(DecodeError::Undefined);\n                                    }\n                                }\n                            }\n                            0b1000 |\n                            0b1010 |\n                            0b1100 |\n                            0b1110 => {\n                                // `STRD (immediate)` (`A8-687`)\n                                // v6T2\n                                let w = instr2[5];\n                                let u = instr2[7];\n                                let p = instr2[8];\n                                // `if P == '0' && W == '0' then SEE \"Related encodings\"` -> this\n                                // would imply tbb/tbh, should be unreachable\n                                if rn == 15 || rt == 13 || rt == 15 || rd == 13 || rd == 15 {\n                                    decoder.unpredictable()?;\n                                }\n                                inst.opcode = Opcode::STRD;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rt)),\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    if p {\n                                        Operand::RegDerefPreindexOffset(Reg::from_u8(rn), imm8 << 2, u, w)\n                                    } else {\n                                        // p == 0 and w == 0 is impossible, would be tbb/tbh\n                                        Operand::RegDerefPostindexOffset(Reg::from_u8(rn), imm8 << 2, u, false)\n                                    },\n                                    Operand::Nothing,\n                                ];\n                            }\n                            0b1001 |\n                            0b1011 |\n                            0b1101 |\n                            0b1111 => {\n                                // `LDRD (immediate)` (`A8-687`)\n                                // v6T2\n                                let w = instr2[5];\n                                let u = instr2[7];\n                                let p = instr2[8];\n                                // `if P == '0' && W == '0' then SEE \"Related encodings\"` -> this\n                                // would imply tbb/tbh, should be unreachable\n                                if rt == 13 || rt == 15 || rd == 13 || rd == 15 || rd == rt {\n                                    decoder.unpredictable()?;\n                                }\n                                if w && (rn == rt || rn == rd) {\n                                    decoder.unpredictable()?;\n                                }\n                                if rn != 0b1111 {\n                                    // `LDRD (immediate)` (`A8-427`)\n                                    // v6T2\n                                    inst.opcode = Opcode::LDRD;\n                                    inst.operands = [\n                                        Operand::Reg(Reg::from_u8(rt)),\n                                        Operand::Reg(Reg::from_u8(rd)),\n                                        if p {\n                                            Operand::RegDerefPreindexOffset(Reg::from_u8(rn), imm8 << 2, u, w)\n                                        } else {\n                                            // p == 0 and w == 0 is impossible, would be tbb/tbh\n                                            Operand::RegDerefPostindexOffset(Reg::from_u8(rn), imm8 << 2, u, false)\n                                        },\n                                        Operand::Nothing,\n                                    ];\n                                } else {\n                                    // `LDRD (literal)` (`A8-429`)\n                                    // v6T2\n                                    if w {\n                                        decoder.unpredictable()?;\n                                    }\n                                    // which because !(p == 0 && w == 0), we know p is true\n                                    inst.opcode = Opcode::LDRD;\n                                    inst.operands = [\n                                        Operand::Reg(Reg::from_u8(rt)),\n                                        Operand::Reg(Reg::from_u8(rd)),\n                                        Operand::RegDerefPreindexOffset(Reg::from_u8(rn), imm8 << 2, u, false),\n                                        Operand::Nothing,\n                                    ];\n                                }\n                            }\n                            _ => {\n                                unreachable!(\"impossible bit pattern\");\n                            }\n                        }\n                    } else {\n                        let w = instr2[5];\n                        // `Load/store multiple` (`A6-235`)\n                        if !instr2[4] {\n                            // `L == 0`\n                            match instr2[7..9].load::<u8>() {\n                                0b00 => {\n                                    // `SRS (Thumb)` (`B9-1990`)\n                                    // v6T2\n                                    inst.opcode = Opcode::SRS(false, true); // `srsdb`\n                                    inst.operands = [\n                                        Operand::RegWBack(Reg::from_u8(13), w),\n                                        Operand::Imm12(lower2[0..4].load::<u16>()), // #<mode> ? what's the syntax here? #<the literal>?\n                                        Operand::Nothing,\n                                        Operand::Nothing,\n                                    ];\n                                }\n                                0b01 => {\n                                    // `STM (STMIA, STMEA)` (`A8-665`)\n                                    // v6T2\n                                    if rn == 15 || lower.count_ones() < 2 {\n                                        decoder.unpredictable()?;\n                                    }\n                                    if w && (lower & (1 << rn)) != 0 {\n                                        decoder.unpredictable()?;\n                                    }\n                                    inst.opcode = Opcode::STM(\n                                        true, // add\n                                        false, // preincrement\n                                        w, // wback\n                                        true, // usermode\n                                    );\n                                    inst.operands = [\n                                        Operand::RegWBack(Reg::from_u8(rn), w),\n                                        Operand::RegList(lower),\n                                        Operand::Nothing,\n                                        Operand::Nothing,\n                                    ];\n                                }\n                                0b10 => {\n                                    // `STMDB`/`STMFD` (`A8-669`)\n                                    // or `PUSH` (`A8-539`)\n\n                                    // implied by instruction?\n                                    inst.set_w(false);\n\n                                    if w && rn == 0b1101 {\n                                        // `PUSH`\n                                        // v6T2\n                                        if lower.count_ones() < 2 {\n                                            decoder.unpredictable()?;\n                                        }\n                                        inst.opcode = Opcode::PUSH;\n                                        inst.operands = [\n                                            Operand::RegList(lower),\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    } else {\n                                        // `STMDB`\n                                        // v6T2\n                                        if rn == 15 || lower.count_ones() < 2 {\n                                            decoder.unpredictable()?;\n                                        }\n                                        if w && (lower & (1 << rn)) != 0 {\n                                            decoder.unpredictable()?;\n                                        }\n                                        inst.opcode = Opcode::STM(\n                                            false, // decrement\n                                            true, // preincrement\n                                            w, // wback\n                                            true, // usermode?\n                                        );\n                                        inst.operands = [\n                                            Operand::RegWBack(Reg::from_u8(rn), w),\n                                            Operand::RegList(lower),\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    }\n                                }\n                                0b11 => {\n                                    // `SRS (Thumb)` (`B9-1990`)\n                                    // v6T2\n                                    inst.opcode = Opcode::SRS(false, true); // `srsia`\n                                    inst.operands = [\n                                        Operand::RegWBack(Reg::from_u8(13), w),\n                                        Operand::Imm12(lower & 0b1111), // #<mode> ? what's the syntax here? #<the literal>?\n                                        Operand::Nothing,\n                                        Operand::Nothing,\n                                    ];\n                                }\n                                _ => {\n                                    unreachable!();\n                                }\n                            }\n                        } else {\n                            // `L == 1`\n                            match instr2[7..9].load::<u8>() {\n                                0b00 => {\n                                    // `RFE` (`B9-1986`)\n                                    // v6T2\n                                    if rn == 15 {\n                                        decoder.unpredictable()?;\n                                    }\n                                    inst.opcode = Opcode::RFE(false, true);\n                                    inst.operands = [\n                                        Operand::RegWBack(Reg::from_u8(rn), w),\n                                        Operand::Nothing,\n                                        Operand::Nothing,\n                                        Operand::Nothing,\n                                    ];\n                                }\n                                0b01 => {\n                                    // `LDM/LDMIA/LDMFD (Thumb)` (`A8-397`)\n                                    if w && rn == 0b1101 {\n                                        // `POP` (`A8-535`)\n                                        if lower.count_ones() < 2 || (lower & 0xc000) == 0xc000 {\n                                            decoder.unpredictable()?;\n                                        }\n                                        inst.opcode = Opcode::POP;\n                                        inst.operands = [\n                                            Operand::RegList(lower),\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    } else {\n                                        // `LDM/LDMIA/LDMFD`\n                                        if rn == 15 || lower.count_ones() < 2 {\n                                            decoder.unpredictable()?;\n                                        }\n                                        if w && (lower & (1 << rn)) != 0 {\n                                            decoder.unpredictable()?;\n                                        }\n                                        inst.opcode = Opcode::LDM(true, false, w, true);\n                                        inst.operands = [\n                                            Operand::RegWBack(Reg::from_u8(rn), w),\n                                            Operand::RegList(lower),\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    }\n                                }\n                                0b10 => {\n                                    // `LDMDB/LDMEA` (`A8-403`)\n\n                                    // wide is implied\n                                    inst.set_w(false);\n\n                                    if rn == 15 || lower.count_ones() < 2 {\n                                        decoder.unpredictable()?;\n                                    }\n                                    if w && (lower & (1 << rn)) != 0 {\n                                        decoder.unpredictable()?;\n                                    }\n                                    inst.opcode = Opcode::LDM(false, true, w, true);\n                                    inst.operands = [\n                                        Operand::RegWBack(Reg::from_u8(rn), w),\n                                        Operand::RegList(lower),\n                                        Operand::Nothing,\n                                        Operand::Nothing,\n                                    ];\n                                }\n                                0b11 => {\n                                    // `RFE` (`B9-1986`)\n                                    // v6T2\n                                    if rn == 15 {\n                                        decoder.unpredictable()?;\n                                    }\n                                    inst.opcode = Opcode::RFE(true, false);\n                                    inst.operands = [\n                                        Operand::RegWBack(Reg::from_u8(rn), w),\n                                        Operand::Nothing,\n                                        Operand::Nothing,\n                                        Operand::Nothing,\n                                    ];\n                                }\n                                _ => {\n                                    unreachable!();\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    // op2 is `01xxxxx` and is:\n                    // `Data-processing (shfited register)` (`A6-241`)\n                    // v6T2\n                    let op = op2[1..5].load::<u8>();\n                    let s = instr2[4];\n                    let rn = instr2[0..4].load::<u8>();\n                    let rd = lower2[8..12].load::<u8>();\n\n                    let imm3 = lower2[12..15].load::<u16>();\n                    let imm2 = lower2[6..8].load::<u16>();\n                    let tp = lower2[4..6].load::<u16>();\n                    let rm = lower2[0..4].load::<u16>();\n\n                    let shift = RegShift::from_raw(\n                        0b00000 | // reg-imm shift\n                        rm as u16 |\n                        (imm2 << 7) | (imm3 << 9) |\n                        tp << 5\n                    );\n                    let shift = Operand::RegShift(shift);\n\n                    inst.s = s;\n\n                    match op {\n                        0b0000 => {\n                            if rd == 0b1111 && s {\n                                // `TST` (`A8-747`)\n                                // v6T2\n                                inst.s = false;\n                                inst.opcode = Opcode::TST;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    shift,\n                                    Operand::Nothing,\n                                    Operand::Nothing,\n                                ];\n                            } else {\n                                // `AND` (`A8-324`)\n                                // v6T2\n                                inst.opcode = Opcode::AND;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    shift,\n                                    Operand::Nothing,\n                                ];\n                            }\n                        }\n                        0b0001 => {\n                            // `BIC` (`A8-340`)\n                            // v6T2\n                            inst.opcode = Opcode::BIC;\n                            inst.operands = [\n                                Operand::Reg(Reg::from_u8(rd)),\n                                Operand::Reg(Reg::from_u8(rn)),\n                                shift,\n                                Operand::Nothing,\n                            ];\n                        }\n                        0b0010 => {\n                            if rn == 0b1111 {\n                                // `Move register and immediate shifts`, also `A6-241`\n                                let tp = (lower >> 4) & 0b11;\n                                let imm2 = (lower >> 6) & 0b11;\n                                let imm3 = (lower >> 12) & 0b111;\n                                let imm5 = (imm3 << 2) | imm2;\n                                match tp {\n                                    0b00 => {\n                                        if imm5 == 0 {\n                                            // `MOV (register, Thumb)` (`A8-487`)\n                                            // encoding T3\n                                            inst.set_w(true);\n                                            let rm = lower2[..4].load::<u8>();\n                                            let rd = lower2[8..12].load::<u8>();\n                                            inst.opcode = Opcode::MOV;\n                                            inst.operands = [\n                                                Operand::Reg(Reg::from_u8(rd)),\n                                                Operand::Reg(Reg::from_u8(rm)),\n                                                Operand::Nothing,\n                                                Operand::Nothing,\n                                            ];\n                                        } else {\n                                            // `LSL (immediate)` (`A8-469`)\n                                            // encoding T2\n                                            inst.set_w(true);\n                                            let rm = lower2[..4].load::<u8>();\n                                            let rd = lower2[8..12].load::<u8>();\n                                            inst.opcode = Opcode::LSL;\n                                            inst.operands = [\n                                                Operand::Reg(Reg::from_u8(rd)),\n                                                Operand::Reg(Reg::from_u8(rm)),\n                                                Operand::Imm12(imm5),\n                                                Operand::Nothing,\n                                            ];\n                                        }\n                                    },\n                                    0b01 => {\n                                        // `LSR (immediate)` (`A8-473`)\n                                        // encoding T2\n                                        inst.set_w(true);\n                                        let rm = lower2[..4].load::<u8>();\n                                        let rd = lower2[8..12].load::<u8>();\n                                        inst.opcode = Opcode::LSR;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rd)),\n                                            Operand::Reg(Reg::from_u8(rm)),\n                                            Operand::Imm12(imm5),\n                                            Operand::Nothing,\n                                        ];\n                                    }\n                                    0b10 => {\n                                        // `ASR (immediate)` (`A8-328`)\n                                        // encoding T2\n                                        inst.set_w(true);\n                                        let rm = lower2[..4].load::<u8>();\n                                        let rd = lower2[8..12].load::<u8>();\n                                        inst.opcode = Opcode::ASR;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rd)),\n                                            Operand::Reg(Reg::from_u8(rm)),\n                                            Operand::Imm12(imm5),\n                                            Operand::Nothing,\n                                        ];\n                                    }\n                                    0b11 => {\n                                        if imm5 == 0 {\n                                            // `RRX` (`A8-573`)\n                                            // encoding T1\n                                            inst.set_w(false);\n                                            let rm = lower2[..4].load::<u8>();\n                                            let rd = lower2[8..12].load::<u8>();\n                                            inst.opcode = Opcode::RRX;\n                                            inst.operands = [\n                                                Operand::Reg(Reg::from_u8(rd)),\n                                                Operand::Reg(Reg::from_u8(rm)),\n                                                Operand::Nothing,\n                                                Operand::Nothing,\n                                            ];\n                                        } else {\n                                            // `ROR (immediate)` (`A8-569`)\n                                            // encoding T1\n                                            inst.set_w(false);\n                                            let rm = lower2[..4].load::<u8>();\n                                            let rd = lower2[8..12].load::<u8>();\n                                            inst.opcode = Opcode::ASR;\n                                            inst.operands = [\n                                                Operand::Reg(Reg::from_u8(rd)),\n                                                Operand::Reg(Reg::from_u8(rm)),\n                                                Operand::Imm12(imm5),\n                                                Operand::Nothing,\n                                            ];\n                                        }\n                                    }\n                                    _ => {\n                                        unreachable!(\"impossible bit pattern for `tp`\");\n                                    }\n                                }\n                            } else {\n                                // `ORR` (`A8-519`)\n                                // v6T2\n                                inst.opcode = Opcode::ORR;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    shift,\n                                    Operand::Nothing,\n                                ];\n                            }\n                        }\n                        0b0011 => {\n                            if rn == 0b1111 {\n                                // `MVN` (`A8-507`)\n                                // v6T2\n                                inst.opcode = Opcode::MVN;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    shift,\n                                    Operand::Nothing,\n                                    Operand::Nothing,\n                                ];\n                            } else {\n                                // `ORN` (`A8-515`)\n                                // v6T2\n                                inst.set_w(false);\n                                inst.opcode = Opcode::ORN;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    shift,\n                                    Operand::Nothing,\n                                ];\n                            }\n                        }\n                        0b0100 => {\n                            if rd == 0b1111 && s {\n                                // `TEQ` (`A8-741`)\n                                // v6T2\n                                inst.s = false;\n                                inst.opcode = Opcode::TEQ;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    shift,\n                                    Operand::Nothing,\n                                    Operand::Nothing,\n                                ];\n                            } else {\n                                // `EOR` (`A8-385`)\n                                // v6T2\n                                inst.opcode = Opcode::EOR;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    shift,\n                                    Operand::Nothing,\n                                ];\n                            }\n                        }\n                        0b0110 => {\n                            // `PKH` (`A8-523`)\n                            // v6T2\n                            // TODO: fix shift\n                            // TODO: check opcode\n                            inst.s = false;\n                            inst.opcode = if lower & 0b10000 != 0 {\n                                Opcode::PKHTB\n                            } else {\n                                Opcode::PKHBT\n                            };\n                            inst.operands = [\n                                Operand::Reg(Reg::from_u8(rd)),\n                                Operand::Reg(Reg::from_u8(rn)),\n                                shift,\n                                Operand::Nothing,\n                            ];\n                        }\n                        0b1000 => {\n                            if rd == 0b1111 && s {\n                                // `CMN` (`A8-364`)\n                                // v6T2\n                                inst.s = false;\n                                inst.opcode = Opcode::CMN;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    shift,\n                                    Operand::Nothing,\n                                    Operand::Nothing,\n                                ];\n                            } else {\n                                // `ADD` (`A8-308`)\n                                inst.opcode = Opcode::ADD;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    shift,\n                                    Operand::Nothing,\n                                ];\n                            }\n                        }\n                        0b1010 => {\n                            // `ADC` (`A8-300`)\n                            // v6T2\n                            inst.opcode = Opcode::ADC;\n                            inst.operands = [\n                                Operand::Reg(Reg::from_u8(rd)),\n                                Operand::Reg(Reg::from_u8(rn)),\n                                shift,\n                                Operand::Nothing,\n                            ];\n                        }\n                        0b1011 => {\n                            // `SBC` (`A8-595`)\n                            // v6T2\n                            inst.opcode = Opcode::SBC;\n                            inst.operands = [\n                                Operand::Reg(Reg::from_u8(rd)),\n                                Operand::Reg(Reg::from_u8(rn)),\n                                shift,\n                                Operand::Nothing,\n                            ];\n                        }\n                        0b1101 => {\n                            if rd == 0b1111 && s {\n                                // `CMP` (`A8-370`)\n                                // v6T2\n                                inst.s = false;\n                                inst.opcode = Opcode::CMP;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    shift,\n                                    Operand::Nothing,\n                                    Operand::Nothing,\n                                ];\n                            } else {\n                                // `SUB` (`A8-713`)\n                                // v6T2\n                                inst.opcode = Opcode::SUB;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    shift,\n                                    Operand::Nothing,\n                                ];\n                            }\n                        }\n                        0b1110 => {\n                            // `RSB` (`A8-577`)\n                            inst.set_w(false);\n                            inst.opcode = Opcode::RSB;\n                            inst.operands = [\n                                Operand::Reg(Reg::from_u8(rd)),\n                                Operand::Reg(Reg::from_u8(rn)),\n                                shift,\n                                Operand::Nothing,\n                            ];\n                        }\n                        _ => {\n                            // undefined encoding\n                            return Err(DecodeError::Undefined);\n                        }\n                    }\n                }\n            } else {\n                // `Coprocessor, Advanced SIMD, and Floating-point instructions` (`A6-249`)\n                // v6T2\n                // op1 == 01, op2 == 1xxxxxx\n                // this means `assert!(instr2[10])`\n                return decode_table_a6_30(decoder, inst, instr2, lower2);\n            }\n        } else if opword == 0b11110 {\n            // op1 == 0b10\n            // interpret `op1 == 0b10` lines in table `A6-9` on `A6-228`:\n            if !lower2[15] {\n                // op == 0\n                if !op2[5] {\n                    // `A6.3.1` `Data-processing (modified immediate)` (`A6-229`)\n                    // see `A6.3.2` for `Modified immediate constants in Thumb instructions` on how\n                    // to decode immediates\n                    // v6T2\n                    let op = op2[1..5].load::<u8>();\n                    let i = instr2[10..11].load::<u16>();\n                    let s = instr2[4];\n                    let rn = instr2[0..4].load::<u8>();\n                    let imm3 = lower2[12..15].load::<u16>();\n                    let rd = lower2[8..12].load::<u8>();\n                    let imm8 = lower2[0..8].load::<u16>();\n                    let imm = (i << 11) | (imm3 << 8) | imm8;\n\n                    inst.s = s;\n\n                    let imm = ThumbExpandImm_C(imm)?;\n\n                    match op {\n                        0b0000 => {\n                            if rd == 0b1111 && s {\n                                // `TST` (`A8-745`)\n                                // v6T2\n                                inst.s = false;\n                                inst.opcode = Opcode::TST;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    Operand::Imm32(imm as u32),\n                                    Operand::Nothing,\n                                    Operand::Nothing,\n                                ];\n                            } else {\n                                // `AND` (`A8-322`)\n                                // v6T2\n                                inst.set_w(false);\n                                inst.opcode = Opcode::AND;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    Operand::Imm32(imm as u32),\n                                    Operand::Nothing,\n                                ];\n                            }\n                        }\n                        0b0001 => {\n                            // `BIC` (`A8-338`)\n                            // v6T2\n                            inst.set_w(false);\n                            inst.opcode = Opcode::BIC;\n                            inst.operands = [\n                                Operand::Reg(Reg::from_u8(rd)),\n                                Operand::Reg(Reg::from_u8(rn)),\n                                Operand::Imm32(imm as u32),\n                                Operand::Nothing,\n                            ];\n                        }\n                        0b0010 => {\n                            if rn == 0b1111 {\n                                // `MOV` (`A8-485`)\n                                // v6T2\n                                inst.opcode = Opcode::MOV;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Imm32(imm as u32),\n                                    Operand::Nothing,\n                                    Operand::Nothing,\n                                ];\n                            } else {\n                                // `ORR` (`A8-517`)\n                                // v6T2\n                                inst.set_w(false);\n                                inst.opcode = Opcode::ORR;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    Operand::Imm32(imm as u32),\n                                    Operand::Nothing,\n                                ];\n                            }\n                        }\n                        0b0011 => {\n                            if rn == 0b1111 {\n                                // `MVN` (`A8-505`)\n                                // v6T2\n                                inst.opcode = Opcode::MOV;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Imm32(imm as u32),\n                                    Operand::Nothing,\n                                    Operand::Nothing,\n                                ];\n                            } else {\n                                // `ORN` (`A8-513`)\n                                // v6T2\n                                inst.set_w(false);\n                                inst.opcode = Opcode::ORN;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    Operand::Imm32(imm as u32),\n                                    Operand::Nothing,\n                                ];\n                            }\n                        }\n                        0b0100 => {\n                            if rd == 0b1111 && s {\n                                // `TEQ` (`A8-739`)\n                                // v6T2\n                                inst.s = false;\n                                inst.opcode = Opcode::TEQ;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    Operand::Imm32(imm as u32),\n                                    Operand::Nothing,\n                                    Operand::Nothing,\n                                ];\n                            } else {\n                                // `EOR` (`A8-383`)\n                                // v6T2\n                                inst.set_w(false);\n                                inst.opcode = Opcode::EOR;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    Operand::Imm32(imm as u32),\n                                    Operand::Nothing,\n                                ];\n                            }\n                        }\n                        0b1000 => {\n                            if rd == 0b1111 && s {\n                                // `CMN` (`A8-362`)\n                                // v6T2\n                                inst.s = false;\n                                inst.opcode = Opcode::CMN;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    Operand::Imm32(imm as u32),\n                                    Operand::Nothing,\n                                    Operand::Nothing,\n                                ];\n                            } else {\n                                // `ADD` (`A8-304`)\n                                // v6T2\n                                inst.opcode = Opcode::ADD;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    Operand::Imm32(imm as u32),\n                                    Operand::Nothing,\n                                ];\n                            }\n                        }\n                        0b1010 => {\n                            // `ADC` (`A8-298`)\n                            // v6T2\n                            inst.set_w(false);\n                            inst.opcode = Opcode::ADC;\n                            inst.operands = [\n                                Operand::Reg(Reg::from_u8(rd)),\n                                Operand::Reg(Reg::from_u8(rn)),\n                                Operand::Imm32(imm as u32),\n                                Operand::Nothing,\n                            ];\n                        }\n                        0b1011 => {\n                            // `SBC` (`A8-593`)\n                            // v6T2\n                            inst.set_w(false);\n                            inst.opcode = Opcode::SBC;\n                            inst.operands = [\n                                Operand::Reg(Reg::from_u8(rd)),\n                                Operand::Reg(Reg::from_u8(rn)),\n                                Operand::Imm32(imm as u32),\n                                Operand::Nothing,\n                            ];\n                        }\n                        0b1101 => {\n                            if rd == 0b1111 && s {\n                                // `CMP` (`A8-368`)\n                                // v6T2\n                                inst.s = false;\n                                inst.opcode = Opcode::CMP;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    Operand::Imm32(imm as u32),\n                                    Operand::Nothing,\n                                    Operand::Nothing,\n                                ];\n                            } else {\n                                // `SUB` (`A8-709`)\n                                // v6T2\n                                inst.opcode = Opcode::SUB;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    Operand::Imm32(imm as u32),\n                                    Operand::Nothing,\n                                ];\n                            }\n                        }\n                        0b1110 => {\n                            // `RSB` (`A8-575`)\n                            // v6T2\n                            inst.opcode = Opcode::RSB;\n                            inst.operands = [\n                                Operand::Reg(Reg::from_u8(rd)),\n                                Operand::Reg(Reg::from_u8(rn)),\n                                Operand::Imm32(imm as u32),\n                                Operand::Nothing,\n                            ];\n                        }\n                        _ => {\n                            // undefined encoding\n                            return Err(DecodeError::Undefined);\n                        }\n                    }\n                } else {\n                    // `Data-processing (plain binary immediate)` (`A6-232`)\n                    // v6T2\n                    // aka table `A6-12`\n                    let op = instr2[4..9].load::<u8>();\n                    let i = instr2[10..11].load::<u16>();\n                    inst.s = false;\n                    inst.set_w(false);\n                    let rn = instr2[0..4].load::<u8>();\n                    let imm3 = lower2[12..15].load::<u16>();\n                    let rd = lower2[8..12].load::<u8>();\n                    let imm8 = lower2[0..8].load::<u16>();\n                    let imm = (i << 11) | (imm3 << 8) | imm8;\n\n                    match op {\n                        0b00000 => {\n                            if rn != 0b1111 {\n                                // `ADD` (`A8-304`)\n                                // v6T2\n                                // encoding T4\n                                inst.set_w(true);\n                                inst.opcode = Opcode::ADD;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    Operand::Imm32(imm as u32),\n                                    Operand::Nothing,\n                                ];\n                            } else {\n                                // `ADR` (`A8-320`)\n                                // v6T2\n                                // encoding T3\n                                // handle \"add = TRUE\" and \"add = FALSE\" by calling this add/sub\n                                inst.opcode = Opcode::ADD;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Reg(Reg::from_u8(15)),\n                                    Operand::Imm32(imm as u32),\n                                    Operand::Nothing,\n                                ];\n                            }\n                        }\n                        0b00100 => {\n                            // `MOV` (`A8-485`)\n                            // encoding T3\n                            inst.opcode = Opcode::MOV;\n                            inst.operands = [\n                                Operand::Reg(Reg::from_u8(rd)),\n                                Operand::Imm32(imm as u32 | ((rn as u32) << 16)),\n                                Operand::Nothing,\n                                Operand::Nothing,\n                            ];\n                        }\n                        0b01010 => {\n                            if rn != 0b1111 {\n                                // `SUB` (`A8-709`)\n                                // v6T2\n                                // encoding T4\n                                inst.set_w(true);\n                                inst.opcode = Opcode::SUB;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    Operand::Imm32(imm as u32),\n                                    Operand::Nothing,\n                                ];\n                            } else {\n                                // `ADR` (`A8-320`)\n                                // v6T2\n                                // encoding T2\n                                // handle \"add = TRUE\" and \"add = FALSE\" by calling this add/sub\n                                inst.opcode = Opcode::SUB;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Reg(Reg::from_u8(15)),\n                                    Operand::Imm32(imm as u32),\n                                    Operand::Nothing,\n                                ];\n                            }\n                        }\n                        0b01100 => {\n                            // `MOVT` (`A8-492`)\n                            // v6T2\n                            inst.opcode = Opcode::MOVT;\n                            inst.operands = [\n                                Operand::Reg(Reg::from_u8(rd)),\n                                Operand::Imm32(imm as u32 | ((rn as u32) << 16)),\n                                Operand::Nothing,\n                                Operand::Nothing,\n                            ];\n                        }\n                        0b10000 => {\n                            // `SSAT` (`A8-653`)\n                            // v6T2\n                            let imm3_2 = ((lower >> 10) & 0b11100) | ((lower >> 6) & 0b11);\n                            let sh = 0; // from the opcode\n                            let shift = DecodeImmShift(rn, sh << 1, imm3_2 as u8);\n                            inst.opcode = Opcode::SSAT;\n                            inst.operands = [\n                                Operand::Reg(Reg::from_u8(rd)),\n                                Operand::Imm32((lower & 0b11111) as u32),\n                                Operand::RegShift(shift),\n                                Operand::Nothing,\n                            ];\n                        }\n                        0b10010 => {\n                            let imm3_2 = ((lower >> 10) & 0b11100) | ((lower >> 6) & 0b11);\n                            if imm3_2 != 0 {\n                                let shift = DecodeImmShift(rn, instr2[5..6].load::<u8>() << 1, imm3_2 as u8);\n                                // `SSAT`\n                                // v6T2\n                                inst.opcode = Opcode::SSAT;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Imm32((lower & 0b11111) as u32),\n                                    Operand::RegShift(shift),\n                                    Operand::Nothing,\n                                ];\n                            } else {\n                                // `SSAT16`\n                                // v6T2\n                                inst.opcode = Opcode::SSAT16;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Imm32((lower & 0b11111) as u32),\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    Operand::Nothing,\n                                ];\n                            }\n                        }\n                        0b10100 => {\n                            // `SBFX` (`A8-599`)\n                            // v6T2\n\n                            inst.opcode = Opcode::SBFX;\n                            let imm3_2 = ((lower >> 10) & 0b11100) | ((lower >> 6) & 0b11);\n                            inst.operands = [\n                                Operand::Reg(Reg::from_u8(rd)),\n                                Operand::Reg(Reg::from_u8(rn)),\n                                Operand::Imm12(imm3_2),\n                                Operand::Imm12((lower & 0b11111) + 1),\n                            ];\n                        }\n                        0b10110 => {\n                            if rn != 0b1111 {\n                                // `BFI` (`A8-336`)\n                                // v6T2\n                                inst.opcode = Opcode::BFI;\n                                let imm3_2 = ((lower >> 10) & 0b11100) | ((lower >> 6) & 0b11);\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    Operand::Imm12(imm3_2),\n                                    // TODO: this is `msb` but the operand here should be `width`\n                                    Operand::Imm12(lower & 0b11111),\n                                ];\n                            } else {\n                                // `BFC` (`A8-334`)\n                                // v6T2\n                                inst.opcode = Opcode::BFC;\n                                let imm3_2 = ((lower >> 10) & 0b11100) | ((lower >> 6) & 0b11);\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    Operand::Imm12(imm3_2),\n                                    // TODO: this is `msb` but the operand here should be `width`\n                                    Operand::Imm32((lower & 0b1111) as u32),\n                                ];\n                            }\n                        }\n                        0b11000 => {\n                            // `USAT` (`A8-797`)\n                            // v6T2\n                            let imm3_2 = ((lower >> 10) & 0b11100) | ((lower >> 6) & 0b11);\n                            let sh = 0; // from the opcode\n                            let shift = DecodeImmShift(rn, sh << 1, imm3_2 as u8);\n                            inst.opcode = Opcode::USAT;\n                            inst.operands = [\n                                Operand::Reg(Reg::from_u8(rd)),\n                                Operand::Imm32((lower & 0b11111) as u32),\n                                Operand::RegShift(shift),\n                                Operand::Nothing,\n                            ];\n                        }\n                        0b11010 => {\n                            let imm3_2 = ((lower >> 10) & 0b11100) | ((lower >> 6) & 0b11);\n                            if imm3_2 != 0 {\n                                let sh = 1; // from the opcode\n                                let shift = DecodeImmShift(rn, sh << 1, imm3_2 as u8);\n                                // `USAT`\n                                // v6T2\n                                inst.opcode = Opcode::USAT;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Imm32((lower & 0b11111) as u32),\n                                    Operand::RegShift(shift),\n                                    Operand::Nothing,\n                                ];\n                            } else {\n                                // `USAT16`\n                                // v6T2\n                                inst.opcode = Opcode::USAT16;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Imm32((lower & 0b11111) as u32),\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    Operand::Nothing,\n                                ];\n                            }\n                        }\n                        0b11100 => {\n                            // `UBFX` (`A8-757`)\n                            // v6T2\n\n                            inst.opcode = Opcode::UBFX;\n                            let imm3_2 = ((lower >> 10) & 0b11100) | ((lower >> 6) & 0b11);\n                            inst.operands = [\n                                Operand::Reg(Reg::from_u8(rd)),\n                                Operand::Reg(Reg::from_u8(rn)),\n                                Operand::Imm12(imm3_2),\n                                Operand::Imm12((lower & 0b11111) + 1),\n                            ];\n                        }\n                        _ => {\n                            return Err(DecodeError::Undefined);\n                        }\n                    }\n                }\n            } else {\n                // A6.3 op == 1\n                // `Branches and miscellaneous control` (`A6-233`)\n                let imm8 = lower2[0..8].load::<u16>();\n                let op2 = lower2[8..12].load::<u8>();\n                let op1 = lower2[12..15].load::<u8>();\n                let op = instr2[4..11].load::<u8>();\n                if op1 & 0b101 == 0b000 {\n                    // TODO: This entire section appears wrong? what encoding is the conditional\n                    // branch, none of those line up with the above components, or provided\n                    // operands.\n                    //\n                    // the high bit of op is a sign bit, if a conditional branch. otherwise, it is\n                    // 0 for valid instructiosn other than `udf`, `hvc`, and `smc`. `Branch` is\n                    //   ruled out as `op1` is `0x1`, so see if this is any of the misc\n                    //   instructions:\n                    if op & 0b0111000 != 0b0111000 {\n                        // `Conditional branch` (`A8-332`)\n                        // v6T2\n                        let imm11 = lower2[0..11].load::<u32>();\n                        let imm6 = instr2[0..6].load::<u32>();\n                        let s = instr2[10..11].load::<u32>();\n                        let j1 = lower2[13..14].load::<u32>();\n                        let j2 = lower2[11..12].load::<u32>();\n                        let imm =\n                            (imm11 as i32) |\n                            ((imm6 as i32) << 11) |\n                            ((j1 as i32) << 17) |\n                            ((j2 as i32) << 18) |\n                            ((s as i32) << 19);\n                        let imm = (imm << 12) >> 12;\n                        inst.condition = ConditionCode::build(((instr >> 6) & 0b1111) as u8);\n                        inst.opcode = Opcode::B;\n                        inst.operands = [\n                            Operand::BranchThumbOffset(imm),\n                            Operand::Nothing,\n                            Operand::Nothing,\n                            Operand::Nothing,\n                        ];\n                    } else {\n                        // some misc instruction, rule out `udf`, `hvc`, `smc`:\n                        if op < 0b1000000 {\n                            // misc instruction\n                            if op < 0b0111010 {\n                                // `MSR` in some form, slightly more work to figure this out\n                                let rn = instr2[0..4].load::<u8>();\n                                if imm8 & 0b00100000 != 0 {\n                                    // `MSR` (`B9-1980`)\n                                    // v7VE\n                                    let sysm = (((lower >> 4) & 1) << 4) | ((lower >> 8) & 0b1111);\n                                    let R = instr2[4];\n                                    inst.opcode = Opcode::MSR;\n                                    inst.operands = [\n                                        // TODO: is this the appropriate banked reg?\n                                        if let Some(op) = Reg::from_sysm(R, sysm as u8) {\n                                            // TODO: from_sysm should succeed?\n                                            op\n                                        } else {\n                                            return Err(DecodeError::InvalidOperand);\n                                        },\n                                        Operand::Reg(Reg::from_u8(rn)),\n                                        Operand::Nothing,\n                                        Operand::Nothing,\n                                    ];\n                                } else {\n                                    if op == 0b0111000 {\n                                        if op2 & 0b0011 == 0b00 {\n                                            // `Move to Special register, Application level` (`A8-501`)\n                                            let mask = (lower >> 10) & 0b11;\n                                            let spec_reg = match mask {\n                                                0b00 => {\n                                                    // TODO: generally \"unpredictable\" is\n                                                    // overridden by DecodeMode::Any but there's\n                                                    // nothing to salvage here?\n                                                    return Err(DecodeError::Unpredictable);\n                                                }\n                                                0b01 => {\n                                                    StatusRegMask::APSR_G\n                                                }\n                                                0b10 => {\n                                                    StatusRegMask::APSR_NZCVQ\n                                                }\n                                                0b11 => {\n                                                    StatusRegMask::APSR_NZCVQG\n                                                }\n                                                _ => {\n                                                    unreachable!(\"impossible mask bits\");\n                                                }\n                                            };\n                                            inst.opcode = Opcode::MSR;\n                                            inst.operands = [\n                                                Operand::StatusRegMask(spec_reg),\n                                                Operand::Reg(Reg::from_u8(rn)),\n                                                Operand::Nothing,\n                                                Operand::Nothing,\n                                            ];\n                                        } else {\n                                            // `Move to Special register, System level` (`B9-1984`)\n                                            let mask = lower2[8..12].load::<u8>();\n                                            let R = instr2[4];\n                                            inst.opcode = Opcode::MSR;\n                                            inst.operands = [\n                                                // TODO: is this the appropriate?\n                                                if let Some(op) = Reg::from_sysm(R, mask) {\n                                                    // TODO: from_sysm should succeed?\n                                                    op\n                                                } else {\n                                                    return Err(DecodeError::InvalidOperand);\n                                                },\n                                                Operand::Reg(Reg::from_u8(rn)),\n                                                Operand::Nothing,\n                                                Operand::Nothing,\n                                            ];\n                                        }\n                                    } else {\n                                        // `Move to Special register, System level` (`B9-1984`)\n                                        let mask = lower2[8..12].load::<u8>();\n                                        let R = instr2[4];\n                                        inst.opcode = Opcode::MSR;\n                                        inst.operands = [\n                                            // TODO: is this the appropriate?\n                                            if let Some(op) = Reg::from_sysm(R, mask) {\n                                                // TODO: from_sysm should succeed?\n                                                op\n                                            } else {\n                                                return Err(DecodeError::InvalidOperand);\n                                            },\n                                            Operand::Reg(Reg::from_u8(rn)),\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    }\n                                }\n                            } else if op < 0b0111011 {\n                                // `Change Processor State, and hints` (`A6-234`)\n                                let op1 = lower2[8..11].load::<u8>();\n                                let op2 = lower2[0..8].load::<u8>();\n                                if op1 != 0b000 {\n                                    // `CPS (Thumb)` (`B9-1964`)\n                                    // v6T2\n                                    // encoding T2\n                                    let mode = lower2[0..5].load::<u16>();\n                                    let m = lower2[8];\n                                    let aif = lower2[5..8].load::<u16>();\n                                    let imod = lower2[9..11].load::<u8>();\n\n                                    if !m && imod == 0b00 {\n                                        // unreachable; would be a hint\n                                    }\n                                    if !m && mode != 0 {\n                                        decoder.unpredictable()?;\n                                    }\n                                    if imod < 0b10 {\n                                        if imod == 0b01 {\n                                            decoder.unpredictable()?;\n                                        }\n                                        inst.opcode = Opcode::CPS_modeonly;\n                                        inst.operands = [\n                                            Operand::Imm12(mode),\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    } else {\n                                        inst.opcode = Opcode::CPS(imod == 0b11);\n                                        inst.operands = [\n                                            Operand::Imm12(aif),\n                                            if m {\n                                                Operand::Imm12(mode)\n                                            } else {\n                                                Operand::Nothing\n                                            },\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    }\n                                } else {\n                                    if op2 >= 0b11110000 {\n                                        // `DBG` (`A8-378`)\n                                        let option = lower2[0..4].load::<u16>();\n                                        inst.opcode = Opcode::DBG;\n                                        inst.operands = [\n                                            Operand::Imm12(option),\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    } else {\n                                        match op2 {\n                                            0b00000000 => {\n                                                // `NOP` (`A8-511`)\n                                                // v6T2\n                                                // TODO: should_is_must\n                                                inst.opcode = Opcode::NOP;\n                                                inst.operands = [\n                                                    Operand::Nothing,\n                                                    Operand::Nothing,\n                                                    Operand::Nothing,\n                                                    Operand::Nothing,\n                                                ];\n                                            }\n                                            0b00000001 => {\n                                                // `YIELD` (`A8-1109`)\n                                                // v7\n                                                inst.opcode = Opcode::YIELD;\n                                                inst.operands = [\n                                                    Operand::Nothing,\n                                                    Operand::Nothing,\n                                                    Operand::Nothing,\n                                                    Operand::Nothing,\n                                                ];\n                                            }\n                                            0b00000010 => {\n                                                // `WFE` (`A8-1105`)\n                                                // v7\n                                                inst.opcode = Opcode::WFE;\n                                                inst.operands = [\n                                                    Operand::Nothing,\n                                                    Operand::Nothing,\n                                                    Operand::Nothing,\n                                                    Operand::Nothing,\n                                                ];\n                                            }\n                                            0b00000011 => {\n                                                // `WFI` (`A8-1107`)\n                                                // v7\n                                                inst.opcode = Opcode::WFI;\n                                                inst.operands = [\n                                                    Operand::Nothing,\n                                                    Operand::Nothing,\n                                                    Operand::Nothing,\n                                                    Operand::Nothing,\n                                                ];\n                                            }\n                                            0b00000100 => {\n                                                // `SEV` (`A8-607`)\n                                                // v7\n                                                inst.opcode = Opcode::SEV;\n                                                inst.operands = [\n                                                    Operand::Nothing,\n                                                    Operand::Nothing,\n                                                    Operand::Nothing,\n                                                    Operand::Nothing,\n                                                ];\n                                            }\n                                            0b00010100 => {\n                                                // `CSDB` (`A8-376`)\n                                                // v6T2\n                                                inst.opcode = Opcode::CSDB;\n                                                inst.operands = [\n                                                    Operand::Nothing,\n                                                    Operand::Nothing,\n                                                    Operand::Nothing,\n                                                    Operand::Nothing,\n                                                ];\n                                            }\n                                            _ => {\n                                                return Err(DecodeError::Undefined);\n                                            }\n                                        }\n                                    }\n                                }\n                            } else if op < 0b0111100 {\n                                // `Miscellaneous control instructions` (`A6-235`)\n                                let op = (lower >> 4) & 0b1111;\n                                match op {\n                                    0b0000 => {\n                                        // `ENTERX` (`A9-1116`)\n                                        // ThumbEE\n                                        inst.opcode = Opcode::LEAVEX;\n                                        inst.operands = [\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    },\n                                    0b0001 => {\n                                        // `ENTERX` (`A9-1116`)\n                                        // ThumbEE\n                                        inst.opcode = Opcode::ENTERX;\n                                        inst.operands = [\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    },\n                                    0b0010 => {\n                                        // `CLREX` (`A8-358`)\n                                        // v7\n                                        inst.opcode = Opcode::CLREX;\n                                        inst.operands = [\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    },\n                                    0b0100 => {\n                                        // `DSB` (`A8-381`)\n                                        // v7\n                                        let option = lower & 0b1111;\n                                        inst.opcode = Opcode::DSB;\n                                        inst.operands = [\n                                            Operand::Imm12(option),\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    },\n                                    0b0101 => {\n                                        // `DMB` (`A8-379`)\n                                        // v7\n                                        let option = lower & 0b1111;\n                                        inst.opcode = Opcode::DMB;\n                                        inst.operands = [\n                                            Operand::Imm12(option),\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    },\n                                    0b0110 => {\n                                        // `ISB` (`A8-390`)\n                                        // v7\n                                        let option = lower & 0b1111;\n                                        inst.opcode = Opcode::ISB;\n                                        inst.operands = [\n                                            Operand::Imm12(option),\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    },\n                                    _ => {\n                                        return Err(DecodeError::Undefined);\n                                    }\n                                }\n                            } else if op < 0b0111101 {\n                                // `BXJ` (`A8-352`)\n                                // v6T2\n                                let rm = instr2[0..4].load::<u8>();\n                                inst.opcode = Opcode::BXJ;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rm)),\n                                    Operand::Nothing,\n                                    Operand::Nothing,\n                                    Operand::Nothing,\n                                ];\n                            } else if op < 0b0111110 {\n                                // `ERET` or `SUBS PC, LR`\n                                // v6T2\n                                // `v7VE` defines `ERET` here, identical to `subs pc, lr` with\n                                // `imm8 == 0`. `v7VE` does not change the behavior of this\n                                // instruction at `PL1`.\n                                let imm8 = lower2[0..8].load::<u16>();\n                                if imm8 == 0 {\n                                    // `ERET` (`B9-1968`)\n                                    // v6T2\n                                    // if <v7VE, `subs pc, lr, #0`\n                                    inst.opcode = Opcode::ERET;\n                                    inst.operands = [\n                                        Operand::Nothing,\n                                        Operand::Nothing,\n                                        Operand::Nothing,\n                                        Operand::Nothing,\n                                    ];\n                                } else {\n                                    // `SUBS PC, LR (Thumb)` (`B9-1996`)\n                                    // v6T2\n                                    inst.opcode = Opcode::SUB;\n                                    inst.s = true;\n                                    inst.operands = [\n                                        Operand::Reg(Reg::from_u8(15)), // pc\n                                        Operand::Reg(Reg::from_u8(14)), // lr\n                                        Operand::Imm12(imm8),\n                                        Operand::Nothing,\n                                    ];\n                                }\n                            } else {\n                                // `op` is `0b0111110` or `0b0111111`, both are `MRS` but there's\n                                // some discerning to do still.\n                                let imm8 = lower & 0b11111111;\n                                if imm8 & 0b00100000 != 0 {\n                                    // `MRS (Banked register)` (`B9-1978`)\n                                    // v7VE\n                                    let r = instr & 0b10000;\n                                    let sysm = (lower & 0b10000) | (instr & 0b1111);\n                                    let rd = ((lower >> 8) & 0b1111) as u8;\n                                    inst.opcode = Opcode::MRS;\n                                    inst.operands = [\n                                        Operand::Reg(Reg::from_u8(rd)),\n                                        if let Some(op) = Reg::from_sysm(r != 0, sysm as u8) {\n                                            // TODO: from_sysm should succeed?\n                                            op\n                                        } else {\n                                            return Err(DecodeError::InvalidOperand);\n                                        },\n                                        Operand::Nothing,\n                                        Operand::Nothing,\n                                    ];\n                                } else {\n                                    if op == 0b0111110 {\n                                        // `MRS` (`A8-497`)\n                                        // v6T2\n                                        inst.opcode = Opcode::MRS;\n                                        let rd = ((lower >> 8) & 0b1111) as u8;\n                                        inst.opcode = Opcode::MRS;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rd)),\n                                            // TODO: \"<spec_reg>\"?\n                                            if let Some(op) = Reg::from_sysm(false, 0) {\n                                                // TODO: from_sysm should succeed?\n                                                op\n                                            } else {\n                                                return Err(DecodeError::InvalidOperand);\n                                            },\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    } else {\n                                        // `MRS` (`B9-1976`)\n                                        // v6T2\n                                        inst.opcode = Opcode::MRS;\n                                        let rd = ((lower >> 8) & 0b1111) as u8;\n                                        let r = (instr >> 4) & 1;\n                                        inst.opcode = Opcode::MRS;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rd)),\n                                            // TODO: \"<spec_reg>\"?\n                                            if let Some(op) = Reg::from_sysm(r != 0, 0) {\n                                                // TODO: from_sysm should succeed?\n                                                op\n                                            } else {\n                                                return Err(DecodeError::InvalidOperand);\n                                            },\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    }\n                                }\n                            }\n                        } else {\n                            if op == 0b1111111 {\n                                if op1 == 0b000 {\n                                    // `SMC` (aka `SMI`) (`B9-1988`)\n                                    // \"Security Extensions\"\n                                    let imm = instr & 0b1111;\n                                    inst.opcode = Opcode::SMC;\n                                    inst.operands = [\n                                        Operand::Imm12(imm),\n                                        Operand::Nothing,\n                                        Operand::Nothing,\n                                        Operand::Nothing,\n                                    ];\n                                } else {\n                                    // `UDF` (`A8-759`)\n                                    // All (first defined in issue `C.a`)\n                                    // TODO: should this decode to an intentional `UDF`\n                                    // instruction?\n                                    return Err(DecodeError::Undefined);\n                                }\n                            } else if op == 0b1111110 {\n                                if op1 == 0b000 {\n                                    // `HVC` (`B8-1970`)\n                                    // v7VE\n                                    let imm = lower & 0b1111_1111_1111;\n                                    inst.opcode = Opcode::HVC;\n                                    inst.operands = [\n                                        Operand::Imm12(imm),\n                                        Operand::Nothing,\n                                        Operand::Nothing,\n                                        Operand::Nothing,\n                                    ];\n                                } else {\n                                    // undefined, but by not being mentioned in the manual\n                                    return Err(DecodeError::Undefined);\n                                }\n                            } else {\n                                // undefined, but by not being mentioned in the manual\n                                return Err(DecodeError::Undefined);\n                            }\n                        }\n                    }\n                } else {\n                    let imm11 = lower2[0..11].load::<u32>();\n                    let imm10 = instr2[0..10].load::<u32>();\n                    let j1 = lower2[13..14].load::<u32>();\n                    let j2 = lower2[11..12].load::<u32>();\n                    let s = instr2[10..11].load::<u32>();\n                    let i1 = 0x1 ^ s ^ j1;\n                    let i2 = 0x1 ^ s ^ j2;\n                    let imm =\n                        (imm11 as i32) |\n                        ((imm10 as i32) << 11) |\n                        ((i2 as i32) << 21) |\n                        ((i1 as i32) << 22) |\n                        ((s as i32) << 23);\n                    let imm = (imm << 8) >> 8;\n                    inst.operands = [\n                        Operand::BranchThumbOffset(imm),\n                        Operand::Nothing,\n                        Operand::Nothing,\n                        Operand::Nothing,\n                    ];\n\n                    if op1 & 0b101 == 0b001 {\n                        // `Branch` (`A8-332`)\n                        // T4 encoding\n                        // v6T2\n                        inst.opcode = Opcode::B;\n                    } else if op1 & 0b101 == 0b100 {\n                        // `Branch with Link and Exchange` (`A8-346`)\n                        // `UNDEFINED` in v4T\n                        // v5T\n                        // Undefined if low bit of imm10 is set (\"H\")\n                        if imm11 & 0x1 != 0 {\n                            return Err(DecodeError::Undefined);\n                        }\n                        inst.opcode = Opcode::BLX;\n                    } else if op1 & 0b101 == 0b101 {\n                        // `Brach with Link` (`A8-346`)\n                        // v4T\n                        inst.opcode = Opcode::BL;\n                    } else {\n                        // Permanently undefined by A6-13\n                        return Err(DecodeError::Undefined);\n                    }\n                }\n            }\n        } else {\n            // working through table `A6-9 32-bit Thumb instruction encoding`\n\n            // op1 == 0b11\n            if !op2[6] {\n                // not coprocessor, advanced simd, or floating point instructions\n                if !op2[5] {\n                    // loads, stores\n                    if !op2[0] {\n                        // store single item, or advanced simd load/store\n                        if !op2[4] {\n                            // `Store single data item` (`A6-240`)\n                            let rn = instr2[0..4].load::<u8>();\n                            let op1 = instr2[5..8].load::<u8>();\n                            let size_bits = op1 & 0b011;\n                            let has_imm12 = op1 & 0b100 != 0;\n                            let op2 = (lower >> 6) & 0b111111;\n                            match size_bits {\n                                0b00 => {\n                                    // `STRB_`\n                                    if op2 == 0 {\n                                        // `STRB (register)` (`A8-683`)\n                                        // encoding T2\n                                        // v6T2\n                                        let rm = (lower & 0b1111) as u8;\n                                        let imm2 = (lower >> 4) & 0b11;\n                                        let rt = ((lower >> 12) & 0b1111) as u8;\n                                        inst.opcode = Opcode::STRB;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rt)),\n                                            Operand::RegDerefPreindexRegShift(\n                                                Reg::from_u8(rn),\n                                                RegShift::from_raw(\n                                                    // do things\n                                                    0b00000 |       // imm shift\n                                                    (imm2 << 7) |   // imm\n                                                    rm as u16 |            // shiftee\n                                                    (0b00 << 5) // shift style (lsl)\n                                                ),\n                                                true,   // add\n                                                false,  // wback\n                                            ),\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    } else if (op2 & 0b111100) == 0b111000 {\n                                        // `STRBT` (`A8-685`)\n                                        // v6T2\n                                        let imm8 = lower & 0b1111_1111;\n                                        let rt = ((lower >> 12) & 0b1111) as u8;\n                                        inst.opcode = Opcode::STRBT;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rt)),\n                                            Operand::RegDerefPreindexOffset(\n                                                Reg::from_u8(rn),\n                                                imm8,\n                                                true,   // add\n                                                false,  // wback\n                                            ),\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    } else {\n                                        // `STRB (immediate, Thumb)` (`A8-679`)\n                                        // encoding T2/T3\n                                        // v6T2\n                                        let (imm, p, u, w) = if has_imm12 {\n                                            let imm12 = lower & 0b1111_1111_1111;\n                                            let p = true;\n                                            let u = true;\n                                            let w = false;\n                                            (imm12, p, u, w)\n                                        } else {\n                                            let imm8 = lower & 0b1111_1111;\n                                            let puw = (lower >> 8) & 0b111;\n                                            let p = puw & 0b100 != 0;\n                                            let u = puw & 0b010 != 0;\n                                            let w = puw & 0b001 != 0;\n                                            (imm8, p, u, w)\n                                        };\n                                        // assert!(puw != 0b110) // would be `strbt`\n                                        let rt = ((lower >> 12) & 0b1111) as u8;\n                                        inst.opcode = Opcode::STRB;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rt)),\n                                            // do the puw\n                                            if p {\n                                                Operand::RegDerefPreindexOffset(\n                                                    Reg::from_u8(rn),\n                                                    imm,\n                                                    u, // add\n                                                    w, // wback\n                                                )\n                                            } else {\n                                                Operand::RegDerefPostindexOffset(\n                                                    Reg::from_u8(rn),\n                                                    imm,\n                                                    u, // add\n                                                    w, // wback\n                                                )\n                                            },\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    }\n                                }\n                                0b01 => {\n                                    // `STRH_`\n                                    // v6T2\n                                    if op2 == 0 {\n                                        // `STRH (register)` (`A8-703`)\n                                        let rm = (lower & 0b1111) as u8;\n                                        let imm2 = (lower >> 4) & 0b11;\n                                        let rt = ((lower >> 12) & 0b1111) as u8;\n                                        inst.opcode = Opcode::STRH;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rt)),\n                                            Operand::RegDerefPreindexRegShift(\n                                                Reg::from_u8(rn),\n                                                RegShift::from_raw(\n                                                    // do things\n                                                    0b00000 |       // imm shift\n                                                    (imm2 << 7) |   // imm\n                                                    rm as u16 |            // shiftee\n                                                    (0b00 << 5) // shift style (lsl)\n                                                ),\n                                                true,   // add\n                                                false,  // wback\n                                            ),\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    } else if (op2 & 0b111100) == 0b111000 {\n                                        // `STRHT` (`A8-705`)\n                                        let imm8 = lower & 0b1111_1111;\n                                        let rt = ((lower >> 12) & 0b1111) as u8;\n                                        inst.opcode = Opcode::STRHT;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rt)),\n                                            Operand::RegDerefPreindexOffset(\n                                                Reg::from_u8(rn),\n                                                imm8,\n                                                true,   // add\n                                                false,  // wback\n                                            ),\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    } else {\n                                        // `STRH (immediate, Thumb)` (`A8-699`)\n                                        // encoding T2/T3\n                                        // v6T2\n                                        let (imm, p, u, w) = if has_imm12 {\n                                            let imm12 = lower & 0b1111_1111_1111;\n                                            let p = true;\n                                            let u = true;\n                                            let w = false;\n                                            (imm12, p, u, w)\n                                        } else {\n                                            let imm8 = lower & 0b1111_1111;\n                                            let puw = (lower >> 8) & 0b111;\n                                            let p = puw & 0b100 != 0;\n                                            let u = puw & 0b010 != 0;\n                                            let w = puw & 0b001 != 0;\n                                            (imm8, p, u, w)\n                                        };\n                                        // assert!(puw != 0b110) // would be `strbt`\n                                        let rt = ((lower >> 12) & 0b1111) as u8;\n                                        inst.opcode = Opcode::STRH;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rt)),\n                                            // do the puw\n                                            if p {\n                                                Operand::RegDerefPreindexOffset(\n                                                    Reg::from_u8(rn),\n                                                    imm,\n                                                    u, // add\n                                                    w, // wback\n                                                )\n                                            } else {\n                                                Operand::RegDerefPostindexOffset(\n                                                    Reg::from_u8(rn),\n                                                    imm,\n                                                    u, // add\n                                                    w, // wback\n                                                )\n                                            },\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    }\n                                }\n                                0b10 => {\n                                    // `STR_`\n                                    if op2 == 0 {\n                                        // `STR (register)` (`A8-677`)\n                                        // v6T2\n                                        let rm = (lower & 0b1111) as u8;\n                                        let imm2 = (lower >> 4) & 0b11;\n                                        let rt = ((lower >> 12) & 0b1111) as u8;\n                                        inst.opcode = Opcode::STR;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rt)),\n                                            Operand::RegDerefPreindexRegShift(\n                                                Reg::from_u8(rn),\n                                                RegShift::from_raw(\n                                                    // do things\n                                                    0b00000 |       // imm shift\n                                                    (imm2 << 7) |   // imm\n                                                    rm as u16 |            // shiftee\n                                                    (0b00 << 5) // shift style (lsl)\n                                                ),\n                                                true,   // add\n                                                false,  // wback\n                                            ),\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    } else if (op2 & 0b111100) == 0b111000 {\n                                        // `STRT` (`A8-707`)\n                                        let imm8 = lower & 0b1111_1111;\n                                        let rt = ((lower >> 12) & 0b1111) as u8;\n                                        inst.opcode = Opcode::STRT;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rt)),\n                                            Operand::RegDerefPreindexOffset(\n                                                Reg::from_u8(rn),\n                                                imm8,\n                                                true,   // add\n                                                false,  // wback\n                                            ),\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    } else {\n                                        // `STR (immediate, Thumb)` (`A8-673`)\n                                        // encoding T3/T4\n                                        // v6T2\n                                        let (imm, p, u, w) = if has_imm12 {\n                                            let imm12 = lower & 0b1111_1111_1111;\n                                            let p = true;\n                                            let u = true;\n                                            let w = false;\n                                            (imm12, p, u, w)\n                                        } else {\n                                            let imm8 = lower & 0b1111_1111;\n                                            let puw = (lower >> 8) & 0b111;\n                                            let p = puw & 0b100 != 0;\n                                            let u = puw & 0b010 != 0;\n                                            let w = puw & 0b001 != 0;\n                                            (imm8, p, u, w)\n                                        };\n                                        // assert!(puw != 0b110) // would be `strbt`\n                                        let rt = ((lower >> 12) & 0b1111) as u8;\n                                        inst.opcode = Opcode::STR;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rt)),\n                                            // do the puw\n                                            if p {\n                                                Operand::RegDerefPreindexOffset(\n                                                    Reg::from_u8(rn),\n                                                    imm,\n                                                    u, // add\n                                                    w, // wback\n                                                )\n                                            } else {\n                                                Operand::RegDerefPostindexOffset(\n                                                    Reg::from_u8(rn),\n                                                    imm,\n                                                    u, // add\n                                                    w, // wback\n                                                )\n                                            },\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    }\n                                }\n                                0b11 => {\n                                    return Err(DecodeError::Undefined);\n                                }\n                                _ => {\n                                    unreachable!(\"impossible bit pattern\");\n                                }\n                            }\n                        } else {\n                            // `Advanced SIMD element or structure load/store instructions`\n                            // (`A7-273`)\n                        }\n                    } else {\n                        // this section is a merger of three tables:\n                        // `A6.3.9 Load byte, memory hints`\n                        // `A6.3.8 Load halfword, memory hints`\n                        // `A6.3.7 Load word`\n                        // reached by the `00xx001`, `00xx011`, `00xx101` rows of table `A6-9`.\n\n                        let op2 = lower2[6..12].load::<u16>();\n                        let rt = lower2[12..16].load::<u8>();\n                        let rn = instr2[0..4].load::<u8>();\n                        let op1 = instr2[7..9].load::<u16>();\n\n                        // load {byte, halfword, word} in table `A6-9`\n                        let size = instr2[5..7].load::<usize>();\n                        if size == 0b11 {\n                            // `UNDEFINED`\n                            return Err(DecodeError::Undefined);\n                        }\n\n                        /*\n                         * trying to reorder tables a6-20, a6-19, and a6-18 to factor out operand\n                         * sizes where possible...\n                         *\n                         *  op1 |  op2 |  rn  |  rt  | size| `see`\n                         *   00 |000000|!=1111|!=1111|  00 |`LDRB (register) A8-423`\n                         *   00 |000000|!=1111|==1111|  00 |`PLD, PLDW (register) A8-529`\n                         *   00 |000000|!=1111|!=1111|  01 |`LDRH (register) A8-447`\n                         *   00 |000000|!=1111|==1111|  01 |`PLD, PLDW (register) A8-529`\n                         *   00 |000000|!=1111|------|  10 |`LDR (register, Thumb) A8-413`\n                         *\n                         *   00 |1100xx|!=1111|!=1111|  00 |`LDRB (immediate, Thumb) A8-417`\n                         *   00 |1100xx|!=1111|==1111|  00 |`PLD, PLDW (immediate) A8-525`\n                         *   00 |1100xx|!=1111|!=1111|  01 |`LDRH (immediate, Thumb) A8-441`\n                         *   00 |1100xx|!=1111|==1111|  01 |`PLD, PLDW (immediate) A8-525`\n                         *   00 |1100xx|!=1111|------|  10 |`LDR (immediate, Thumb) A8-407`\n                         *\n                         *   00 |1110xx|!=1111|------|  00 |`LDRBT A8-425`\n                         *   00 |1110xx|!=1111|------|  01 |`LDRHT A8-449`\n                         *   00 |1110xx|!=1111|------|  10 |`LDRT A8-467`\n                         *\n                         *   00 |1xx1xx|!=1111|------|  00 |`LDRB (immediate, Thumb) A8-417`\n                         *   00 |1xx1xx|!=1111|------|  01 |`LDRH (immediate, Thumb) A8-441`\n                         *   00 |1xx1xx|!=1111|------|  10 |`LDR (immediate, Thumb) A8-407`\n                         *\n                         *   01 |------|!=1111|!=1111|  00 |`LDRB (immediate, Thumb) A8-417`\n                         *   01 |------|!=1111|==1111|  00 |`PLD, PLDW (immediate) A8-525`\n                         *   01 |------|!=1111|!=1111|  01 |`LDRH (immediate, Thumb) A8-441`\n                         *   01 |------|!=1111|==1111|  01 |`PLD, PLDW (immediate) A8-525`\n                         *   01 |------|!=1111|------|  10 |`LDR (immediate, Thumb) A8-407`\n                         *\n                         *   0x |------|==1111|!=1111|  00 |`LDRB (literal) A8-421`\n                         *   0x |------|==1111|==1111|  00 |`PLD (literal) A8-527`\n                         *   0x |------|==1111|!=1111|  01 |`LDRH (literal) A8-445`\n                         *   0x |------|==1111|==1111|  01 |`PLD (literal) A8-527`\n                         *   0x |------|==1111|------|  10 |`LDR (literal) A8-411`\n                         *\n                         *   1x |------|------|------|  10 |`UNDEFINED (cite: A6.3.7)`\n                         *\n                         *   10 |000000|!=1111|!=1111|  00 |`LDRSB (register) A8-455`\n                         *   10 |000000|!=1111|!=1111|  01 |`LDRSH (register) A8-463`\n                         *   10 |000000|!=1111|==1111|  00 |`PLI (register) A8-553`\n                         *   10 |000000|!=1111|==1111|  01 |`Unallocated memory hint (treat as NOP)`\n                         *\n                         *   10 |1100xx|!=1111|!=1111|  00 |`LDRSB (immediate) A8-451`\n                         *   10 |1100xx|!=1111|==1111|  00 |`PLI (immediate, literal) A8-531`\n                         *   10 |1100xx|!=1111|!=1111|  01 |`LDRSH (immediate) A8-459`\n                         *   10 |1100xx|!=1111|==1111|  01 |`Unallocated memory hint (treat as NOP)`\n                         *\n                         *   10 |1110xx|!=1111|------|  00 |`LDRSBT A8-457`\n                         *   10 |1110xx|!=1111|------|  01 |`LDRSHT A8-465`\n                         *\n                         *   10 |1xx1xx|!=1111|------|  00 |`LDRSB (immediate) A8-451`\n                         *   10 |1xx1xx|!=1111|------|  01 |`LDRSH (immediate) A8-459`\n                         *\n                         *   11 |------|!=1111|!=1111|  00 |`LDRSB (immediate) A8-451`\n                         *   11 |------|!=1111|==1111|  00 |`PLI (immediate, literal) A8-531`\n                         *   11 |------|!=1111|!=1111|  01 |`LDRSH (immediate) A8-459`\n                         *   11 |------|!=1111|==1111|  01 |`Unallocated memory hint (treat as NOP)`\n                         *   1x |------|==1111|!=1111|  00 |`LDRSB (literal) A8-453`\n                         *   1x |------|==1111|==1111|  00 |`PLI (immediate, literal) A8-531`\n                         *   1x |------|==1111|!=1111|  01 |`LDRSH (literal) A8-461`\n                         *   1x |------|==1111|==1111|  01 |`Unallocated memory hint (treat as NOP)`\n                         */\n                        if op1 == 0b00 {\n                            // op1 == bits 7:8\n                            /*\n                             *  op1 |  op2 |  rn  |  rt  | size| `see`\n                             *   0x |------|==1111|!=1111|  00 |`LDRB (literal) A8-421`\n                             *   0x |------|==1111|==1111|  00 |`PLD (literal) A8-527`\n                             *   0x |------|==1111|!=1111|  01 |`LDRH (literal) A8-445`\n                             *   0x |------|==1111|==1111|  01 |`PLD (literal) A8-527`\n                             *   0x |------|==1111|------|  10 |`LDR (literal) A8-411`\n                             *\n                             *   00 |000000|!=1111|!=1111|  00 |`LDRB (register) A8-423`\n                             *   00 |000000|!=1111|==1111|  00 |`PLD, PLDW (register) A8-529`\n                             *   00 |000000|!=1111|!=1111|  01 |`LDRH (register) A8-447`\n                             *   00 |000000|!=1111|==1111|  01 |`PLD, PLDW (register) A8-529`\n                             *   00 |000000|!=1111|------|  10 |`LDR (register, Thumb) A8-413`\n                             *\n                             *   00 |1100xx|!=1111|!=1111|  00 |`LDRB (immediate, Thumb) A8-417`\n                             *   00 |1100xx|!=1111|==1111|  00 |`PLD, PLDW (immediate) A8-525`\n                             *   00 |1100xx|!=1111|!=1111|  01 |`LDRH (immediate, Thumb) A8-441`\n                             *   00 |1100xx|!=1111|==1111|  01 |`PLD, PLDW (immediate) A8-525`\n                             *   00 |1100xx|!=1111|------|  10 |`LDR (immediate, Thumb) A8-407`\n                             *\n                             *   00 |1110xx|!=1111|------|  00 |`LDRBT A8-425`\n                             *   00 |1110xx|!=1111|------|  01 |`LDRHT A8-449`\n                             *   00 |1110xx|!=1111|------|  10 |`LDRT A8-467`\n                             *\n                             *   00 |1xx1xx|!=1111|------|  00 |`LDRB (immediate, Thumb) A8-417`\n                             *   00 |1xx1xx|!=1111|------|  01 |`LDRH (immediate, Thumb) A8-441`\n                             *   00 |1xx1xx|!=1111|------|  10 |`LDR (immediate, Thumb) A8-407`\n                             */\n                            if rn == 0b1111 {\n                                // `(literal)`\n                                let opcode = if rt == 0b1111 {\n                                    [\n                                        Opcode::PLD,\n                                        Opcode::PLD,\n                                        Opcode::LDR,\n                                    ][size]\n                                } else {\n                                    [\n                                        Opcode::LDRB,\n                                        Opcode::LDRH,\n                                        Opcode::LDR,\n                                    ][size]\n                                };\n                                let u = false; // instr2[7], but known 0 here\n                                let imm12 = lower2[..12].load::<u16>();\n                                inst.opcode = opcode;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rt)),\n                                    Operand::RegDerefPreindexOffset(Reg::from_u8(rn), imm12, u, false), // no add, no wback\n                                    Operand::Nothing,\n                                    Operand::Nothing,\n                                ];\n                            } else {\n                                if op2 == 0b000000 {\n                                    // `(register, Thumb)`\n                                    let opcode = if rt == 0b1111 {\n                                        [\n                                            Opcode::PLD,\n                                            Opcode::PLD,\n                                            Opcode::LDR,\n                                        ][size]\n                                    } else {\n                                        [\n                                            Opcode::LDRB,\n                                            Opcode::LDRH,\n                                            Opcode::LDR,\n                                        ][size]\n                                    };\n                                    let rm = lower2[0..4].load::<u8>();\n                                    let imm2 = lower2[4..6].load::<u8>();\n                                    inst.opcode = opcode;\n                                    inst.operands = [\n                                        Operand::Reg(Reg::from_u8(rt)),\n                                        Operand::RegDerefPreindexRegShift(\n                                            Reg::from_u8(rn),\n                                            RegShift::from_raw(\n                                                0b00000 |    // `RegImm`\n                                                rm as u16 |\n                                                ((0 /* lsl */) << 5)|\n                                                ((imm2 as u16) << 7)\n                                            ),\n                                            true,   // add\n                                            false,  // wback\n                                        ),\n                                        Operand::Nothing,\n                                        Operand::Nothing,\n                                    ];\n                                } else if op2 & 0b111100 == 0b110000 {\n                                    // `(immediate, Thumb)`\n                                    let opcode = if rt == 0b1111 {\n                                        [\n                                            Opcode::PLD,\n                                            Opcode::PLD,\n                                            Opcode::LDR,\n                                        ][size]\n                                    } else {\n                                        [\n                                            Opcode::LDRB,\n                                            Opcode::LDRH,\n                                            Opcode::LDR,\n                                        ][size]\n                                    };\n                                    let w = lower2[8];\n                                    let u = lower2[9];\n                                    let p = lower2[10];\n                                    let imm8 = lower2[..8].load::<u16>();\n                                    inst.opcode = opcode;\n                                    inst.operands = [\n                                        Operand::Reg(Reg::from_u8(rt)),\n                                        if p {\n                                            Operand::RegDerefPreindexOffset(Reg::from_u8(rn), imm8, u, w)\n                                        } else {\n                                            Operand::RegDerefPostindexOffset(Reg::from_u8(rn), imm8, u, false)\n                                        },\n                                        Operand::Nothing,\n                                        Operand::Nothing,\n                                    ];\n\n                                } else if op2 & 0b111100 == 0b111000 {\n                                    // `(immediate, Thumb)`\n                                    let opcode = if rt == 0b1111 {\n                                        [\n                                            Opcode::PLD,\n                                            Opcode::PLD,\n                                            Opcode::LDRT,\n                                        ][size]\n                                    } else {\n                                        [\n                                            Opcode::LDRBT,\n                                            Opcode::LDRHT,\n                                            Opcode::LDRT,\n                                        ][size]\n                                    };\n                                    let w = lower2[8];\n                                    let u = lower2[9];\n                                    let p = lower2[10];\n                                    let imm8 = lower2[..8].load::<u16>();\n                                    inst.opcode = opcode;\n                                    inst.operands = [\n                                        Operand::Reg(Reg::from_u8(rt)),\n                                        if p {\n                                            Operand::RegDerefPreindexOffset(Reg::from_u8(rn), imm8, u, w)\n                                        } else {\n                                            Operand::RegDerefPostindexOffset(Reg::from_u8(rn), imm8, u, false)\n                                        },\n                                        Operand::Nothing,\n                                        Operand::Nothing,\n                                    ];\n                                } else if op2 & 0b100100 == 0b100100 {\n                                    // `(immediate, Thumb)`\n                                    let opcode = if rt == 0b1111 {\n                                        [\n                                            Opcode::PLD,\n                                            Opcode::PLD,\n                                            Opcode::LDR,\n                                        ][size]\n                                    } else {\n                                        [\n                                            Opcode::LDRB,\n                                            Opcode::LDRH,\n                                            Opcode::LDR,\n                                        ][size]\n                                    };\n                                    let w = lower2[8];\n                                    let u = lower2[9];\n                                    let p = lower2[10];\n                                    let imm8 = lower2[..8].load::<u16>();\n                                    inst.opcode = opcode;\n                                    inst.operands = [\n                                        Operand::Reg(Reg::from_u8(rt)),\n                                        if p {\n                                            Operand::RegDerefPreindexOffset(Reg::from_u8(rn), imm8, u, w)\n                                        } else {\n                                            Operand::RegDerefPostindexOffset(Reg::from_u8(rn), imm8, u, false)\n                                        },\n                                        Operand::Nothing,\n                                        Operand::Nothing,\n                                    ];\n                                } else {\n                                    // op2 =~ 0b1010xx or something?\n                                    // nothing to try decoding as for a `decoder.undefined()?`, so\n                                    // just error.\n                                    return Err(DecodeError::Undefined);\n                                }\n                            }\n                        } else if op1 == 0b01 {\n                            // op1 == bits 7:8\n                            /*\n                             *  op1 |  op2 |  rn  |  rt  | size| `see`\n                             *   0x |------|==1111|!=1111|  00 |`LDRB (literal) A8-421`\n                             *   0x |------|==1111|==1111|  00 |`PLD (literal) A8-527`\n                             *   0x |------|==1111|!=1111|  01 |`LDRH (literal) A8-445`\n                             *   0x |------|==1111|==1111|  01 |`PLD (literal) A8-527`\n                             *   0x |------|==1111|------|  10 |`LDR (literal) A8-411`\n                             *\n                             *   01 |------|!=1111|!=1111|  00 |`LDRB (immediate, Thumb) A8-417`\n                             *   01 |------|!=1111|==1111|  00 |`PLD, PLDW (immediate) A8-525`\n                             *   01 |------|!=1111|!=1111|  01 |`LDRH (immediate, Thumb) A8-441`\n                             *   01 |------|!=1111|==1111|  01 |`PLD, PLDW (immediate) A8-525`\n                             *   01 |------|!=1111|------|  10 |`LDR (immediate, Thumb) A8-407`\n                             */\n                            if rn == 0b1111 {\n                                let opcode = if rt == 0b1111 {\n                                    [\n                                        Opcode::PLD,\n                                        Opcode::PLD,\n                                        Opcode::LDR,\n                                    ][size]\n                                } else {\n                                    [\n                                        Opcode::LDRB,\n                                        Opcode::LDRH,\n                                        Opcode::LDR,\n                                    ][size]\n                                };\n                                let u = true; // instr2[7], but known 1 here\n                                let imm12 = lower2[..12].load::<u16>();\n                                inst.opcode = opcode;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rt)),\n                                    Operand::RegDerefPreindexOffset(Reg::from_u8(rn), imm12, u, false), // add, no wback\n                                    Operand::Nothing,\n                                    Operand::Nothing,\n                                ];\n                            } else {\n                                let opcode = if rt == 0b1111 {\n                                    [\n                                        Opcode::PLD,\n                                        Opcode::PLD,\n                                        Opcode::LDR,\n                                    ][size]\n                                } else {\n                                    [\n                                        Opcode::LDRB,   // encoding T2\n                                        Opcode::LDRH,   // encoding T2\n                                        Opcode::LDR,    // encoding T3\n                                    ][size]\n                                };\n                                let imm12 = lower2[..12].load::<u16>();\n                                inst.opcode = opcode;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rt)),\n                                    Operand::RegDerefPreindexOffset(Reg::from_u8(rn), imm12, true, false), // add, no wback\n                                    Operand::Nothing,\n                                    Operand::Nothing,\n                                ];\n                            }\n                        } else if op1 == 0b10 {\n                            // op1 == bits 7:8\n                            if size == 0b10 {\n                                return Err(DecodeError::Undefined);\n                            }\n                            /*\n                             *  op1 |  op2 |  rn  |  rt  | size| `see`\n                             *   1x |------|------|------|  10 |`UNDEFINED (cite: A6.3.7)`\n                             *   1x |------|==1111|!=1111|  00 |`LDRSB (literal) A8-453`\n                             *   1x |------|==1111|==1111|  00 |`PLI (immediate, literal) A8-531`\n                             *   1x |------|==1111|!=1111|  01 |`LDRSH (literal) A8-461`\n                             *   1x |------|==1111|==1111|  01 |`Unallocated memory hint (treat as NOP)`\n                             *\n                             *   10 |000000|!=1111|!=1111|  00 |`LDRSB (register) A8-455`\n                             *   10 |000000|!=1111|!=1111|  01 |`LDRSH (register) A8-463`\n                             *   10 |000000|!=1111|==1111|  00 |`PLI (register) A8-553`\n                             *   10 |000000|!=1111|==1111|  01 |`Unallocated memory hint (treat as NOP)`\n                             *\n                             *   10 |1100xx|!=1111|!=1111|  00 |`LDRSB (immediate) A8-451`\n                             *   10 |1100xx|!=1111|==1111|  00 |`PLI (immediate, literal) A8-531`\n                             *   10 |1100xx|!=1111|!=1111|  01 |`LDRSH (immediate) A8-459`\n                             *   10 |1100xx|!=1111|==1111|  01 |`Unallocated memory hint (treat as NOP)`\n                             *\n                             *   10 |1110xx|!=1111|------|  00 |`LDRSBT A8-457`\n                             *   10 |1110xx|!=1111|------|  01 |`LDRSHT A8-465`\n                             *\n                             *   10 |1xx1xx|!=1111|------|  00 |`LDRSB (immediate) A8-451`\n                             *   10 |1xx1xx|!=1111|------|  01 |`LDRSH (immediate) A8-459`\n                             */\n                            if rn == 0b1111 {\n                                // (literal)\n                                let opcode = if rt == 0b1111 {\n                                    [\n                                        Opcode::PLI,\n                                        Opcode::NOP,\n                                    ][size]\n                                } else {\n                                    [\n                                        Opcode::LDRSB,\n                                        Opcode::LDRSH,\n                                    ][size]\n                                };\n                                let u = false; // instr[7] known false here\n                                let imm12 = lower2[..12].load::<u16>();\n                                inst.opcode = opcode;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rt)),\n                                    Operand::RegDerefPreindexOffset(Reg::from_u8(15), imm12, u, false), // add, no wback\n                                    Operand::Nothing,\n                                    Operand::Nothing,\n                                ];\n                            } else {\n                                if op2 == 0b000000 {\n                                    let opcode = if rt == 0b1111 {\n                                        [\n                                            Opcode::PLI,\n                                            Opcode::NOP,\n                                        ][size]\n                                    } else {\n                                        [\n                                            Opcode::LDRSB,  // encoding T2\n                                            Opcode::LDRSH,  // encoding T2\n                                        ][size]\n                                    };\n                                    let rm = lower2[0..4].load::<u8>();\n                                    let imm2 = lower2[4..6].load::<u8>();\n                                    inst.opcode = opcode;\n                                    inst.operands = [\n                                        Operand::Reg(Reg::from_u8(rt)),\n                                        Operand::RegDerefPreindexRegShift(\n                                            Reg::from_u8(rn),\n                                            RegShift::from_raw(\n                                                0b00000 |    // `RegImm`\n                                                rm as u16 |\n                                                ((0 /* lsl */) << 5)|\n                                                ((imm2 as u16) << 7)\n                                            ),\n                                            true,   // add\n                                            false,  // wback\n                                        ),\n                                        Operand::Nothing,\n                                        Operand::Nothing,\n                                    ];\n                                } else if op2 & 0b111100 == 0b110000 {\n                                    let opcode = if rt == 0b1111 {\n                                        [\n                                            Opcode::PLI,\n                                            Opcode::NOP,\n                                        ][size]\n                                    } else {\n                                        [\n                                            Opcode::LDRSB,  // encoding T2\n                                            Opcode::LDRSH,  // encoding T2\n                                        ][size]\n                                    };\n                                    let w = lower2[8];\n                                    let u = lower2[9];\n                                    let p = lower2[10];\n                                    let imm8 = lower2[..8].load::<u16>();\n                                    inst.opcode = opcode;\n                                    inst.operands = [\n                                        Operand::Reg(Reg::from_u8(rt)),\n                                        if p {\n                                            Operand::RegDerefPreindexOffset(Reg::from_u8(rn), imm8, u, w)\n                                        } else {\n                                            Operand::RegDerefPostindexOffset(Reg::from_u8(rn), imm8, u, false)\n                                        },\n                                        Operand::Nothing,\n                                        Operand::Nothing,\n                                    ];\n                                } else if op2 & 0b111100 == 0b111000 {\n                                    let opcode = [\n                                        Opcode::LDRSBT, // encoding T1\n                                        Opcode::LDRSHT, // encoding T1\n                                    ][size];\n                                    let imm8 = lower2[..8].load::<u16>();\n                                    inst.opcode = opcode;\n                                    inst.operands = [\n                                        Operand::Reg(Reg::from_u8(rt)),\n                                        Operand::RegDerefPreindexOffset(Reg::from_u8(rn), imm8, true, false), // add, no wback\n                                        Operand::Nothing,\n                                        Operand::Nothing,\n                                    ];\n                                } else if op2 & 0b100100 == 0b100100 {\n                                    let opcode = [\n                                        Opcode::LDRSB,  // encoding T2\n                                        Opcode::LDRSH,  // encoding T2\n                                    ][size];\n                                    let w = lower2[8];\n                                    let u = lower2[9];\n                                    let p = lower2[10];\n                                    let imm8 = lower2[..8].load::<u16>();\n                                    inst.opcode = opcode;\n                                    inst.operands = [\n                                        Operand::Reg(Reg::from_u8(rt)),\n                                        if p {\n                                            Operand::RegDerefPreindexOffset(Reg::from_u8(rn), imm8, u, w)\n                                        } else {\n                                            Operand::RegDerefPostindexOffset(Reg::from_u8(rn), imm8, u, false)\n                                        },\n                                        Operand::Nothing,\n                                        Operand::Nothing,\n                                    ];\n                                } else {\n                                    // op2 =~ 0b1010xx or something?\n                                    // nothing to try decoding as for a `decoder.undefined()?`, so\n                                    // just error.\n                                    return Err(DecodeError::Undefined);\n                                }\n                            }\n                        } else {\n                            // op1 == bits 7:8\n                            if size == 0b10 {\n                                return Err(DecodeError::Undefined);\n                            }\n                            // op1 == 0b11\n                            /*\n                             *   1x |------|------|------|  10 |`UNDEFINED (cite: A6.3.7)`\n                             *   1x |------|==1111|!=1111|  00 |`LDRSB (literal) A8-453`\n                             *   1x |------|==1111|==1111|  00 |`PLI (immediate, literal) A8-531`\n                             *   1x |------|==1111|!=1111|  01 |`LDRSH (literal) A8-461`\n                             *   1x |------|==1111|==1111|  01 |`Unallocated memory hint (treat as NOP)`\n                             *\n                             *   11 |------|!=1111|!=1111|  00 |`LDRSB (immediate) A8-451`\n                             *   11 |------|!=1111|==1111|  00 |`PLI (immediate, literal) A8-531`\n                             *   11 |------|!=1111|!=1111|  01 |`LDRSH (immediate) A8-459`\n                             *   11 |------|!=1111|==1111|  01 |`Unallocated memory hint (treat as NOP)`\n                             */\n                            if rn == 0b1111 {\n                                // (literal)\n                                let opcode = if rt == 0b1111 {\n                                    [\n                                        Opcode::PLI,\n                                        Opcode::NOP,\n                                    ][size]\n                                } else {\n                                    [\n                                        Opcode::LDRSB,\n                                        Opcode::LDRSH,\n                                    ][size]\n                                };\n                                let u = true; // instr[7] known true here\n                                let imm12 = lower2[..12].load::<u16>();\n                                inst.opcode = opcode;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rt)),\n                                    Operand::RegDerefPreindexOffset(Reg::from_u8(15), imm12, u, false), // add, no wback\n                                    Operand::Nothing,\n                                    Operand::Nothing,\n                                ];\n                            } else {\n                                // (immediate)\n                                let opcode = if rt == 0b1111 {\n                                    [\n                                        Opcode::PLI,\n                                        Opcode::NOP,\n                                    ][size]\n                                } else {\n                                    [\n                                        Opcode::LDRSB,  // encoding T1\n                                        Opcode::LDRSH,  // encoding T1\n                                    ][size]\n                                };\n                                let imm12 = lower2[..12].load::<u16>();\n                                inst.opcode = opcode;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rt)),\n                                    Operand::RegDerefPreindexOffset(Reg::from_u8(rn), imm12, true, false), // add, no wback\n                                    Operand::Nothing,\n                                    Operand::Nothing,\n                                ];\n                            }\n                        }\n                    }\n                } else {\n                    if !op2[4] {\n                        // `Data-processing (register)` (`A6-243`)\n                        let op1 = &instr2[4..8];\n                        let op2 = &lower2[4..8];\n                        let rn = instr2[0..4].load::<u8>();\n                        if !op1[3] {\n                            // `LSL`, `LSR`, `ASR`, `ROR`, `SXTAH`, .... out of table `A6-24`\n                            if !op2[3] {\n                                // `LSL`, `LSR`, `ASR`, `ROR`\n                                // v6T2\n                                let op = [\n                                    Opcode::LSL,\n                                    Opcode::LSR,\n                                    Opcode::ASR,\n                                    Opcode::ROR,\n                                ][op2[1..3].load::<usize>()];\n                                let rd = lower2[8..12].load::<u8>();\n                                let rm = lower2[0..4].load::<u8>();\n                                inst.opcode = op;\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    Operand::Reg(Reg::from_u8(rm)),\n                                    Operand::Nothing,\n                                ];\n                            } else {\n                                let op1 = op1[0..3].load::<usize>();\n                                // `SXTAH` and friends\n                                if op1 > 0b101 {\n                                    return Err(DecodeError::Undefined);\n                                }\n\n                                if rn == 0b1111 {\n                                    let op = [\n                                        Opcode::SXTH,\n                                        Opcode::UXTH,\n                                        Opcode::SXTB16,\n                                        Opcode::UXTB16,\n                                        Opcode::SXTB,\n                                        Opcode::UXTB,\n                                    ][op1];\n\n                                    let rm = lower2[..4].load::<u8>();\n                                    let rotate = lower2[1..3].load::<u8>() << 2;\n                                    let rd = lower2[8..12].load::<u8>();\n\n                                    inst.opcode = op;\n                                    inst.operands = [\n                                        Operand::Reg(Reg::from_u8(rd)),\n                                        Operand::Reg(Reg::from_u8(rm)),\n                                        Operand::Imm32(rotate as u32),\n                                        Operand::Nothing,\n                                    ];\n                                } else {\n                                    let op = [\n                                        Opcode::SXTAH,\n                                        Opcode::UXTAH,\n                                        Opcode::SXTAB16,\n                                        Opcode::UXTAB16,\n                                        Opcode::SXTAH,\n                                        Opcode::UXTAB,\n                                    ][op1];\n\n                                    let rm = lower2[..4].load::<u8>();\n                                    let rotate = lower2[1..3].load::<u8>() << 2;\n                                    let rd = lower2[8..12].load::<u8>();\n\n                                    inst.opcode = op;\n                                    inst.operands = [\n                                        Operand::Reg(Reg::from_u8(rd)),\n                                        Operand::Reg(Reg::from_u8(rn)),\n                                        Operand::Reg(Reg::from_u8(rm)),\n                                        Operand::Imm32(rotate as u32),\n                                    ];\n                                };\n                            }\n                        } else {\n                            let op2 = op2.load::<u8>();\n                            if op2 < 0b0100 {\n                                // `Parallel addition and subtraction, signed`\n                                let op1 = instr2[4..7].load::<usize>();\n                                let op2 = lower2[4..6].load::<usize>();\n                                if op1 == 0 || op1 > 0b100 || op2 == 0b11 {\n                                    return Err(DecodeError::InvalidOpcode);\n                                }\n\n                                let opcode_idx = (op1 - 1) * 3 + op2;\n\n                                let rn = instr2[0..4].load::<u8>();\n                                let rd = lower2[8..12].load::<u8>();\n                                let rm = lower2[0..4].load::<u8>();\n\n                                inst.opcode = [\n                                    Opcode::SADD16,\n                                    Opcode::QADD16,\n                                    Opcode::SHADD16,\n                                    Opcode::SASX,\n                                    Opcode::QASX,\n                                    Opcode::SHASX,\n                                    Opcode::SSAX,\n                                    Opcode::QSAX,\n                                    Opcode::SHSAX,\n                                    Opcode::SSUB16,\n                                    Opcode::QSUB16,\n                                    Opcode::SHSUB16,\n                                    Opcode::SADD8,\n                                    Opcode::QADD8,\n                                    Opcode::SHADD8,\n                                    Opcode::SSUB8,\n                                    Opcode::QSUB8,\n                                    Opcode::SHSUB8,\n                                ][opcode_idx];\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    Operand::Reg(Reg::from_u8(rm)),\n                                    Operand::Nothing,\n                                ];\n                            } else if op2 < 0b1000 {\n                                // `Parallel addition and subtraction, unsigned` (`A6-244`)\n                                let op1 = instr2[4..7].load::<usize>();\n                                let op2 = lower2[4..6].load::<usize>();\n                                if op1 > 0b100 || op2 == 0b11 {\n                                    return Err(DecodeError::InvalidOpcode);\n                                }\n\n                                if op1 == 0 {\n                                    return Err(DecodeError::InvalidOpcode);\n                                }\n                                let opcode_idx = (op1 - 1) * 3 + op2;\n\n                                let rn = instr2[0..4].load::<u8>();\n                                let rd = lower2[8..12].load::<u8>();\n                                let rm = lower2[0..4].load::<u8>();\n\n                                inst.opcode = [\n                                    Opcode::UADD16,\n                                    Opcode::UQADD16,\n                                    Opcode::UHADD16,\n                                    Opcode::UASX,\n                                    Opcode::UQASX,\n                                    Opcode::UHASX,\n                                    Opcode::USAX,\n                                    Opcode::UQSAX,\n                                    Opcode::UHSAX,\n                                    Opcode::USUB16,\n                                    Opcode::UQSUB16,\n                                    Opcode::UHSUB16,\n                                    Opcode::UADD8,\n                                    Opcode::UQADD8,\n                                    Opcode::UHADD8,\n                                    Opcode::USUB8,\n                                    Opcode::UQSUB8,\n                                    Opcode::UHSUB8,\n                                ][opcode_idx];\n                                inst.operands = [\n                                    Operand::Reg(Reg::from_u8(rd)),\n                                    Operand::Reg(Reg::from_u8(rn)),\n                                    Operand::Reg(Reg::from_u8(rm)),\n                                    Operand::Nothing,\n                                ];\n                            } else if op2 < 0b1100 {\n                                // `Miscellaneous operations` (`A6-246`)\n                                let rn = instr2[0..4].load::<u8>();\n                                let rd = lower2[8..12].load::<u8>();\n                                let rm = lower2[0..4].load::<u8>();\n                                let op1 = instr2[4..6].load::<u8>();\n                                let op2 = lower2[4..6].load::<usize>();\n                                match op1 {\n                                    0b00 => {\n                                        inst.opcode = [\n                                            Opcode::QADD,\n                                            Opcode::QDADD,\n                                            Opcode::QSUB,\n                                            Opcode::QDSUB,\n                                        ][op2];\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rd)),\n                                            Operand::Reg(Reg::from_u8(rm)),\n                                            Operand::Reg(Reg::from_u8(rn)),\n                                            Operand::Nothing,\n                                        ];\n                                    }\n                                    0b01 => {\n                                        if rn != rm {\n                                            decoder.unpredictable()?;\n                                        }\n                                        inst.opcode = [\n                                            Opcode::REV,\n                                            Opcode::REV16,\n                                            Opcode::RBIT,\n                                            Opcode::REVSH,\n                                        ][op2];\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rd)),\n                                            Operand::Reg(Reg::from_u8(rm)),\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    }\n                                    0b10 => {\n                                        if op2 != 0 {\n                                            return Err(DecodeError::InvalidOpcode);\n                                        }\n                                        inst.opcode = Opcode::SEL;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rd)),\n                                            Operand::Reg(Reg::from_u8(rn)),\n                                            Operand::Reg(Reg::from_u8(rm)),\n                                            Operand::Nothing,\n                                        ];\n                                    }\n                                    0b11 => {\n                                        if op2 != 0 {\n                                            return Err(DecodeError::InvalidOpcode);\n                                        }\n                                        inst.opcode = Opcode::CLZ;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rd)),\n                                            Operand::Reg(Reg::from_u8(rm)),\n                                            Operand::Nothing,\n                                            Operand::Nothing,\n                                        ];\n                                    }\n                                    _ => {\n                                        unreachable!(\"impossible bit pattern for op1\");\n                                    }\n                                }\n                            } else {\n                                return Err(DecodeError::Undefined);\n                            }\n                        }\n                    } else {\n                        if op2[3] {\n                            // `Long multiply, long multiply accumulate, and divide` (`A6-248`)\n                            let op1 = instr2[4..7].load::<usize>();\n                            let op2 = lower2[4..8].load::<usize>();\n\n                            let rn = instr2[0..4].load::<u8>();\n                            let rdlo = lower2[12..16].load::<u8>();\n                            let rd = lower2[8..12].load::<u8>();\n                            let rm = lower2[0..4].load::<u8>();\n\n                            match op1 {\n                                0b000 => {\n                                    if op2 == 0b0000 {\n                                        inst.opcode = Opcode::SMULL;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rdlo)),\n                                            Operand::Reg(Reg::from_u8(rd)),\n                                            Operand::Reg(Reg::from_u8(rn)),\n                                            Operand::Reg(Reg::from_u8(rm)),\n                                        ];\n                                    } else {\n                                        return Err(DecodeError::InvalidOpcode);\n                                    }\n                                }\n                                0b001 => {\n                                    if op2 == 0b1111 {\n                                        inst.opcode = Opcode::SDIV;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rd)),\n                                            Operand::Reg(Reg::from_u8(rn)),\n                                            Operand::Reg(Reg::from_u8(rm)),\n                                            Operand::Nothing,\n                                        ];\n                                    } else {\n                                        return Err(DecodeError::InvalidOpcode);\n                                    }\n                                }\n                                0b010 => {\n                                    if op2 == 0b0000 {\n                                        inst.opcode = Opcode::UMULL;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rdlo)),\n                                            Operand::Reg(Reg::from_u8(rd)),\n                                            Operand::Reg(Reg::from_u8(rn)),\n                                            Operand::Reg(Reg::from_u8(rm)),\n                                        ];\n                                    } else {\n                                        return Err(DecodeError::InvalidOpcode);\n                                    }\n                                }\n                                0b011 => {\n                                    if op2 == 0b1111 {\n                                        inst.opcode = Opcode::UDIV;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rd)),\n                                            Operand::Reg(Reg::from_u8(rn)),\n                                            Operand::Reg(Reg::from_u8(rm)),\n                                            Operand::Nothing,\n                                        ];\n                                    } else {\n                                        return Err(DecodeError::InvalidOpcode);\n                                    }\n                                }\n                                0b100 => {\n                                    if op2 == 0b0000 {\n                                        inst.opcode = Opcode::SMLAL;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rdlo)),\n                                            Operand::Reg(Reg::from_u8(rd)),\n                                            Operand::Reg(Reg::from_u8(rn)),\n                                            Operand::Reg(Reg::from_u8(rm)),\n                                        ];\n                                    } else if op2 & 0b1100 == 0b1000 {\n                                        inst.opcode = Opcode::SMLAL_halfword(lower2[5], lower2[4]);\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rdlo)),\n                                            Operand::Reg(Reg::from_u8(rd)),\n                                            Operand::Reg(Reg::from_u8(rn)),\n                                            Operand::Reg(Reg::from_u8(rm)),\n                                        ];\n                                    } else if op2 & 0b1110 == 0b1100 {\n                                        inst.opcode = Opcode::SMLALD(lower2[4]);\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rdlo)),\n                                            Operand::Reg(Reg::from_u8(rd)),\n                                            Operand::Reg(Reg::from_u8(rn)),\n                                            Operand::Reg(Reg::from_u8(rm)),\n                                        ];\n                                    } else {\n                                        return Err(DecodeError::InvalidOpcode);\n                                    }\n                                }\n                                0b101 => {\n                                    if op2 == 0b1100 || op2 == 0b1101 {\n                                        inst.opcode = Opcode::SMLSLD(lower2[4]);\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rdlo)),\n                                            Operand::Reg(Reg::from_u8(rd)),\n                                            Operand::Reg(Reg::from_u8(rn)),\n                                            Operand::Reg(Reg::from_u8(rm)),\n                                        ];\n                                    } else {\n                                        return Err(DecodeError::InvalidOpcode);\n                                    }\n                                }\n                                0b110 => {\n                                    if op2 == 0b0000 {\n                                        inst.opcode = Opcode::UMLAL;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rdlo)),\n                                            Operand::Reg(Reg::from_u8(rd)),\n                                            Operand::Reg(Reg::from_u8(rn)),\n                                            Operand::Reg(Reg::from_u8(rm)),\n                                        ];\n                                    } else if op2 == 0b0110 {\n                                        inst.opcode = Opcode::UMAAL;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rdlo)),\n                                            Operand::Reg(Reg::from_u8(rd)),\n                                            Operand::Reg(Reg::from_u8(rn)),\n                                            Operand::Reg(Reg::from_u8(rm)),\n                                        ];\n                                    } else {\n                                        return Err(DecodeError::InvalidOpcode);\n                                    }\n                                }\n                                _ => {\n                                    return Err(DecodeError::InvalidOpcode);\n                                }\n                            }\n                        } else {\n                            // `Multiply, multiply accumulate, and absolute difference` (`A6-247`)\n                            let op1 = instr2[4..7].load::<usize>();\n                            let op2 = lower2[4..6].load::<usize>();\n                            let rm = lower2[0..4].load::<u8>();\n                            let rd = lower2[8..12].load::<u8>();\n                            let ra = lower2[12..16].load::<u8>();\n                            let rn = instr2[0..4].load::<u8>();\n\n                            if ra == 0b1111 {\n                                if op1 == 0b000 {\n                                    if op2 == 0b00 {\n                                        inst.opcode = Opcode::MUL;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rd)),\n                                            Operand::Reg(Reg::from_u8(rn)),\n                                            Operand::Reg(Reg::from_u8(rm)),\n                                            Operand::Nothing,\n                                        ];\n                                    } else if op2 == 0b01{\n                                        inst.opcode = Opcode::MLS;\n                                        // a == 15, unpredictable\n                                        decoder.unpredictable()?;\n                                        inst.operands = [\n                                            Operand::Reg(Reg::from_u8(rd)),\n                                            Operand::Reg(Reg::from_u8(rn)),\n                                            Operand::Reg(Reg::from_u8(rm)),\n                                            Operand::Reg(Reg::from_u8(ra)),\n                                        ];\n                                    } else {\n                                        return Err(DecodeError::InvalidOpcode);\n                                    }\n\n                                } else if op1 == 0b001 {\n                                    // `SMULBB, SMULBT, SMULTB, SMULTT on page A8-645`\n                                    inst.opcode = Opcode::SMUL(lower2[5], lower2[4]);\n                                    inst.operands = [\n                                        Operand::Reg(Reg::from_u8(rd)),\n                                        Operand::Reg(Reg::from_u8(rn)),\n                                        Operand::Reg(Reg::from_u8(rm)),\n                                        Operand::Nothing,\n                                    ];\n                                } else if op1 == 0b011 {\n                                    if op2 >= 0b10 {\n                                        return Err(DecodeError::InvalidOpcode);\n                                    }\n                                    inst.opcode = Opcode::SMULW(lower2[4]);\n                                    inst.operands = [\n                                        Operand::Reg(Reg::from_u8(rd)),\n                                        Operand::Reg(Reg::from_u8(rn)),\n                                        Operand::Reg(Reg::from_u8(rm)),\n                                        Operand::Nothing,\n                                    ];\n                                } else {\n                                    if op2 >= 0b10 {\n                                        return Err(DecodeError::InvalidOpcode);\n                                    }\n                                    if op1 == 0b111 && op2 == 0b00 {\n                                        return Err(DecodeError::InvalidOpcode);\n                                    }\n                                    if op1 == 0b110 {\n                                        decoder.unpredictable()?;\n                                    }\n                                    inst.opcode = [\n                                        Opcode::MUL, // already handled\n                                        Opcode::UDF, // already handled\n                                        Opcode::SMUAD,\n                                        Opcode::UDF, // already handled\n                                        Opcode::SMUSD,\n                                        Opcode::SMMUL,\n                                        Opcode::SMMLS,\n                                        Opcode::USAD8,\n                                    ][op1];\n                                    inst.operands = [\n                                        Operand::Reg(Reg::from_u8(rd)),\n                                        Operand::Reg(Reg::from_u8(rn)),\n                                        Operand::Reg(Reg::from_u8(rm)),\n                                        Operand::Nothing,\n                                    ];\n                                }\n                            } else {\n                                if op1 == 0b000 {\n                                    if op2 == 0b00 {\n                                        inst.opcode = Opcode::MLA;\n                                    } else if op2 == 0b01{\n                                        inst.opcode = Opcode::MLS;\n                                    } else {\n                                        return Err(DecodeError::InvalidOpcode);\n                                    }\n\n                                    inst.operands = [\n                                        Operand::Reg(Reg::from_u8(rd)),\n                                        Operand::Reg(Reg::from_u8(rn)),\n                                        Operand::Reg(Reg::from_u8(rm)),\n                                        Operand::Reg(Reg::from_u8(ra)),\n                                    ];\n                                } else if op1 == 0b001 {\n                                    // `SMULBB, SMULBT, SMULTB, SMULTT on page A8-645`\n                                    inst.opcode = Opcode::SMLA(lower2[5], lower2[4]);\n                                    inst.operands = [\n                                        Operand::Reg(Reg::from_u8(rd)),\n                                        Operand::Reg(Reg::from_u8(rn)),\n                                        Operand::Reg(Reg::from_u8(rm)),\n                                        Operand::Reg(Reg::from_u8(ra)),\n                                    ];\n                                } else if op1 == 0b011 {\n                                    if op2 >= 0b10 {\n                                        return Err(DecodeError::InvalidOpcode);\n                                    }\n                                    inst.opcode = Opcode::SMLAW(lower2[4]);\n                                    inst.operands = [\n                                        Operand::Reg(Reg::from_u8(rd)),\n                                        Operand::Reg(Reg::from_u8(rn)),\n                                        Operand::Reg(Reg::from_u8(rm)),\n                                        Operand::Reg(Reg::from_u8(ra)),\n                                    ];\n                                } else {\n                                    if op2 >= 0b10 {\n                                        return Err(DecodeError::InvalidOpcode);\n                                    }\n                                    if op1 == 0b111 && op2 == 0b00 {\n                                        return Err(DecodeError::InvalidOpcode);\n                                    }\n                                    if op1 == 0b110 {\n                                        decoder.unpredictable()?;\n                                    }\n                                    inst.opcode = [\n                                        Opcode::MUL, // already handled\n                                        Opcode::UDF, // already handled\n                                        Opcode::SMLAD,\n                                        Opcode::UDF, // already handled\n                                        Opcode::SMLSD,\n                                        Opcode::SMMLA,\n                                        Opcode::SMMLS,\n                                        Opcode::USADA8,\n                                    ][op1];\n                                    inst.operands = [\n                                        Operand::Reg(Reg::from_u8(rd)),\n                                        Operand::Reg(Reg::from_u8(rn)),\n                                        Operand::Reg(Reg::from_u8(rm)),\n                                        Operand::Reg(Reg::from_u8(ra)),\n                                    ];\n                                }\n\n                            }\n                        }\n                    }\n                }\n            } else {\n                // `Coprocessor, Advanced SIMD, and Floating-point instructions` (`A6-249`)\n                // v6T2\n                // op1 == 11, op2 == 1xxxxxx\n                // this means `assert!(instr2[10])`\n                return decode_table_a6_30(decoder, inst, instr2, lower2);\n            }\n        }\n    } else {\n        // 16b instruction - `A6-221, 16-bit Thumb instruction encoding`\n        // `Table A6-1`\n        if opword < 0b01000 {\n            // `Shift (immediate), add, subtract, move, and compare` page `A6-222`\n            // v4T\n            let opcode = opword & 0b111;\n            // TODO: `S` iff outside `IT` block\n            inst.s = true;\n\n            match opcode {\n                0b000 => {\n                    // LSL (immediate)\n                    // footnote: when opcode is 0, bits 8:6 are 0, encoding is `MOV`. see `A8-487`.\n                    let rd = instr2[0..3].load::<u8>();\n                    let rm = instr2[3..6].load::<u8>();\n                    let imm5 = instr2[6..11].load::<u16>();\n                    inst.opcode = Opcode::LSL;\n                    inst.operands = [\n                        Operand::Reg(Reg::from_u8(rd)),\n                        Operand::Reg(Reg::from_u8(rm)),\n                        Operand::Imm12(imm5),\n                        Operand::Nothing,\n                    ];\n                }\n                0b001 => {\n                    /* LSR on page A8-473 */\n                    let rd = instr2[0..3].load::<u8>();\n                    let rm = instr2[3..6].load::<u8>();\n                    let imm5 = instr2[6..11].load::<u16>();\n                    let imm = if imm5 == 0 {\n                        0x20\n                    } else {\n                        imm5\n                    };\n                    inst.opcode = Opcode::LSR;\n                    inst.operands = [\n                        Operand::Reg(Reg::from_u8(rd)),\n                        Operand::Reg(Reg::from_u8(rm)),\n                        Operand::Imm12(imm),\n                        Operand::Nothing,\n                    ];\n                }\n                0b010 => {\n                    /* ASR on page A8-328 */\n                    let rd = instr2[0..3].load::<u8>();\n                    let rm = instr2[3..6].load::<u8>();\n                    let imm5 = instr2[6..11].load::<u16>();\n                    let imm = if imm5 == 0 {\n                        0x20\n                    } else {\n                        imm5\n                    };\n                    inst.opcode = Opcode::ASR;\n                    inst.operands = [\n                        Operand::Reg(Reg::from_u8(rd)),\n                        Operand::Reg(Reg::from_u8(rm)),\n                        Operand::Imm12(imm),\n                        Operand::Nothing,\n                    ];\n                }\n                0b011 => {\n                    /* ADD, SUB (register/immediate) */\n                    let oplower = instr2[9..11].load::<u32>();\n                    let rm = instr2[6..9].load::<u8>();\n                    let rd = instr2[0..3].load::<u8>();\n                    let rn = instr2[3..6].load::<u8>();\n\n                    match oplower {\n                        0b00 => {\n                            inst.opcode = Opcode::ADD;\n                            inst.operands = [\n                                Operand::Reg(Reg::from_u8(rd)),\n                                Operand::Reg(Reg::from_u8(rn)),\n                                Operand::Reg(Reg::from_u8(rm)),\n                                Operand::Nothing,\n                            ];\n                        }\n                        0b01 => {\n                            inst.opcode = Opcode::SUB;\n                            inst.operands = [\n                                Operand::Reg(Reg::from_u8(rd)),\n                                Operand::Reg(Reg::from_u8(rn)),\n                                Operand::Reg(Reg::from_u8(rm)),\n                                Operand::Nothing,\n                            ];\n                        }\n                        0b10 => {\n                            inst.opcode = Opcode::ADD;\n                            inst.operands = [\n                                Operand::Reg(Reg::from_u8(rd)),\n                                Operand::Reg(Reg::from_u8(rn)),\n                                Operand::Imm32(rm as u32),\n                                Operand::Nothing,\n                            ];\n                        }\n                        0b11 => {\n                            inst.opcode = Opcode::SUB;\n                            inst.operands = [\n                                Operand::Reg(Reg::from_u8(rd)),\n                                Operand::Reg(Reg::from_u8(rn)),\n                                Operand::Imm32(rm as u32),\n                                Operand::Nothing,\n                            ];\n                        }\n                        _ => {\n                            unreachable!(\"impossible bit pattern\");\n                        }\n                    }\n                }\n                0b100 => {\n                    /* MOV on page A8-485 */\n                    let imm8 = instr2[0..8].load::<u32>();\n                    let rd = instr2[8..11].load::<u8>();\n                    inst.opcode = Opcode::MOV;\n                    inst.operands = [\n                        Operand::Reg(Reg::from_u8(rd)),\n                        Operand::Imm32(imm8 as u32),\n                        Operand::Nothing,\n                        Operand::Nothing,\n                    ];\n                }\n                0b101 => {\n                    /* CMP on page A8-368 */\n                    inst.s = false;\n                    let imm8 = instr2[0..8].load::<u32>();\n                    let rd = instr2[8..11].load::<u8>();\n                    inst.opcode = Opcode::CMP;\n                    inst.operands = [\n                        Operand::Reg(Reg::from_u8(rd)),\n                        Operand::Imm32(imm8 as u32),\n                        Operand::Nothing,\n                        Operand::Nothing,\n                    ];\n                }\n                0b110 => {\n                    /* ADD (immediate, Thumb) on page A8-304 */\n                    let imm8 = instr2[0..8].load::<u32>();\n                    let rdn = instr2[8..11].load::<u8>();\n                    inst.opcode = Opcode::ADD;\n                    inst.operands = [\n                        Operand::Reg(Reg::from_u8(rdn)),\n                        Operand::Imm32(imm8 as u32),\n                        Operand::Nothing,\n                        Operand::Nothing,\n                    ];\n                }\n                0b111 => {\n                    /* SUB (immediate, Thumb) on page A8-709 */\n                    let imm8 = instr2[0..8].load::<u32>();\n                    let rdn = instr2[8..11].load::<u8>();\n                    inst.opcode = Opcode::SUB;\n                    inst.operands = [\n                        Operand::Reg(Reg::from_u8(rdn)),\n                        Operand::Imm32(imm8 as u32),\n                        Operand::Nothing,\n                        Operand::Nothing,\n                    ];\n                }\n                _ => {\n                    unreachable!(\"impossible bit pattern\");\n                }\n            }\n        } else if opword < 0b01001 {\n            let opcode_bits = instr2[6..10].load::<u8>();\n            // `Data-processing` on page `A6-223` or `Special data instructions and branch and\n            // exchange` on page `A6-224`\n            if (instr >> 10) < 0b010001 {\n                // `Data-processing` on page `A6-223`\n                // v4T\n                // TODO: condition inside IT block, no S\n                inst.s = true;\n                let rdn = instr2[0..3].load::<u8>();\n                let rm = instr2[3..6].load::<u8>();\n                if opcode_bits == 0b1101 {\n                    inst.opcode = Opcode::MUL;\n                    inst.operands = [\n                        Operand::Reg(Reg::from_u8(rdn)),\n                        Operand::Reg(Reg::from_u8(rm)),\n                        Operand::Reg(Reg::from_u8(rdn)),\n                        Operand::Nothing,\n                    ];\n                } else if opcode_bits == 0b1001 {\n                    inst.opcode = Opcode::RSB;\n                    inst.operands = [\n                        Operand::Reg(Reg::from_u8(rdn)),\n                        Operand::Reg(Reg::from_u8(rm)),\n                        Operand::Imm12(0),\n                        Operand::Nothing,\n                    ];\n                } else {\n                    let opcode = [\n                        Opcode::AND,\n                        Opcode::EOR,\n                        Opcode::LSL,\n                        Opcode::LSR,\n                        Opcode::ASR,\n                        Opcode::ADC,\n                        Opcode::SBC,\n                        Opcode::ROR,\n                        Opcode::TST,\n                        Opcode::RSB,\n                        Opcode::CMP,\n                        Opcode::CMN,\n                        Opcode::ORR,\n                        Opcode::MUL,\n                        Opcode::BIC,\n                        Opcode::MVN,\n                    ][opcode_bits as usize];\n                    inst.opcode = opcode;\n                    if opcode_bits == 8 || opcode_bits == 10 || opcode_bits == 11 {\n                        inst.s = false;\n                    }\n                    inst.operands = [\n                        Operand::Reg(Reg::from_u8(rdn)),\n                        Operand::Reg(Reg::from_u8(rm)),\n                        Operand::Nothing,\n                        Operand::Nothing,\n                    ];\n                }\n            } else {\n                // `Special data instructions and branch and exchange` on page `A6-224`\n                match opcode_bits {\n                    0b0000 => {\n                        // `Add Low Registers` (`A8-308`)\n                        // v6T2, `UNPREDICTABLE` in earlier versions\n                        let rdn = instr2[0..3].load::<u8>() | (instr2[7..8].load::<u8>() << 3);\n                        let rm = instr2[3..7].load::<u8>();\n                        inst.opcode = Opcode::ADD;\n                        inst.operands = [\n                            Operand::Reg(Reg::from_u8(rdn)),\n                            Operand::Reg(Reg::from_u8(rm)),\n                            Operand::Nothing,\n                            Operand::Nothing,\n                        ];\n                    },\n                    0b0001 |\n                    0b0010 |\n                    0b0011 => {\n                        // `Add High Registers` (`A8-308`)\n                        // v4T\n                        let rdn = instr2[0..3].load::<u8>() | (instr2[7..8].load::<u8>() << 3);\n                        let rm = instr2[3..7].load::<u8>();\n                        inst.opcode = Opcode::ADD;\n                        inst.operands = [\n                            Operand::Reg(Reg::from_u8(rdn)),\n                            Operand::Reg(Reg::from_u8(rm)),\n                            Operand::Nothing,\n                            Operand::Nothing,\n                        ];\n                    },\n                    0b0100 |\n                    0b0101 |\n                    0b0110 |\n                    0b0111 => {\n                        // `Compare High Registers` (`A8-307`)\n                        // v4T\n                        let rn = instr2[0..3].load::<u8>() | (instr2[7..8].load::<u8>() << 3);\n                        let rm = instr2[3..7].load::<u8>();\n                        inst.opcode = Opcode::CMP;\n                        inst.operands = [\n                            Operand::Reg(Reg::from_u8(rn)),\n                            Operand::Reg(Reg::from_u8(rm)),\n                            Operand::Nothing,\n                            Operand::Nothing,\n                        ];\n                    }\n                    0b1000 => {\n                        // `Move Low Registers` (`A8-487`)\n                        // v6, `UNPREDICTABLE` in earlier versions\n                        // (encoding T1)\n                        let rd = instr2[0..3].load::<u8>() | (instr2[7..8].load::<u8>() << 3);\n                        let rm = instr2[3..7].load::<u8>();\n                        inst.opcode = Opcode::MOV;\n                        inst.operands = [\n                            Operand::Reg(Reg::from_u8(rd)),\n                            Operand::Reg(Reg::from_u8(rm)),\n                            Operand::Nothing,\n                            Operand::Nothing,\n                        ];\n                    }\n                    0b1001 |\n                    0b1010 |\n                    0b1011 => {\n                        // `Move High Registers` (`A8-487`)\n                        // v4T\n                        let rd = instr2[0..3].load::<u8>() | (instr2[7..8].load::<u8>() << 3);\n                        let rm = instr2[3..7].load::<u8>();\n                        inst.opcode = Opcode::MOV;\n                        inst.operands = [\n                            Operand::Reg(Reg::from_u8(rd)),\n                            Operand::Reg(Reg::from_u8(rm)),\n                            Operand::Nothing,\n                            Operand::Nothing,\n                        ];\n                    },\n                    0b1100 |\n                    0b1101 => {\n                        // `Branch and Exchange` (`A8-350`)\n                        // v4T\n                        let rm = instr2[3..7].load::<u8>();\n                        inst.opcode = Opcode::BX;\n                        inst.operands = [\n                            Operand::Reg(Reg::from_u8(rm)),\n                            Operand::Nothing,\n                            Operand::Nothing,\n                            Operand::Nothing,\n                        ];\n                    }\n                    0b1110 |\n                    0b1111 => {\n                        // `Branch and Link with Exchange` (`A8-348`)\n                        // v5T, `UNPREDICTABLE` in earlier versions\n                        let rm = instr2[3..7].load::<u8>();\n                        inst.opcode = Opcode::BLX;\n                        inst.operands = [\n                            Operand::Reg(Reg::from_u8(rm)),\n                            Operand::Nothing,\n                            Operand::Nothing,\n                            Operand::Nothing,\n                        ];\n                    }\n                    _ => {\n                        unreachable!(\"bad bit pattern\");\n                    }\n                }\n            }\n        } else if opword < 0b01010 {\n            // `LDR (literal)` on page `A8-411` -- v4T\n            let imm8 = instr2[0..8].load::<u16>();\n            let rt = instr2[8..11].load::<u8>();\n            inst.opcode = Opcode::LDR;\n            inst.operands = [\n                Operand::Reg(Reg::from_u8(rt)),\n                Operand::RegDerefPreindexOffset(\n                    Reg::from_u8(0b1111),\n                    imm8 << 2,\n                    true,  // add\n                    false, // no wback\n                ),\n                Operand::Nothing,\n                Operand::Nothing,\n            ];\n        } else if opword < 0b10100 {\n            let op_b = instr2[9..12].load::<usize>();\n            let op_a = instr2[12..].load::<usize>();\n            // `Load/store single data item` on page `A6-225`\n            // v4T\n            let rt = instr2[0..3].load::<u8>();\n            let rn = instr2[3..6].load::<u8>();\n            let rm = instr2[6..9].load::<u8>();\n            let imm5 = instr2[6..11].load::<u16>();\n            if op_a == 0b0101 {\n                let op = [\n                    Opcode::STR,\n                    Opcode::STRH,\n                    Opcode::STRB,\n                    Opcode::LDRSB,\n                    Opcode::LDR,\n                    Opcode::LDRH,\n                    Opcode::LDRB,\n                    Opcode::LDRSH,\n                ][op_b];\n                inst.opcode = op;\n                inst.operands = [\n                    Operand::Reg(Reg::from_u8(rt)),\n                    Operand::RegDerefPreindexReg(\n                        Reg::from_u8(rn),\n                        Reg::from_u8(rm),\n                        true,   // add\n                        false,  // wback\n                    ),\n                    Operand::Nothing,\n                    Operand::Nothing,\n                ];\n            } else {\n                // opword is 0b0110, 0b0111, 0b1000, or 0b1001. opb bit 2 can be used to form a\n                // three-bit index and select an opcode. operands are shared. except the last two.\n                // those are sp-relative.\n                let upper = op_a - 0b0110;\n                let idx = (upper << 1) | (op_b >> 2);\n                let op = [\n                    Opcode::STR,\n                    Opcode::LDR,\n                    Opcode::STRB,\n                    Opcode::LDRB,\n                    Opcode::STRH,\n                    Opcode::LDRH,\n                    Opcode::STR,\n                    Opcode::LDR,\n                ][idx];\n                inst.opcode = op;\n                if idx < 6 {\n                    let shift = match idx >> 1 {\n                        0b00 => 2,\n                        0b01 => 0,\n                        0b10 => 1,\n                        _ => { unreachable!(\"impossible bit pattern\"); }\n                    };\n                    inst.operands = [\n                        Operand::Reg(Reg::from_u8(rt)),\n                        Operand::RegDerefPreindexOffset(\n                            Reg::from_u8(rn),\n                            imm5 << shift,\n                            true,   // add\n                            false,  // wback\n                        ),\n                        Operand::Nothing,\n                        Operand::Nothing,\n                    ];\n                } else {\n                    let rt = instr2[8..11].load::<u8>();\n                    let imm8 = instr2[..8].load::<u16>();\n                    inst.operands = [\n                        Operand::Reg(Reg::from_u8(rt)),\n                        Operand::RegDerefPreindexOffset(\n                            Reg::from_u8(13), // sp\n                            imm8 << 2,\n                            true,   // add\n                            false,  // wback\n                        ),\n                        Operand::Nothing,\n                        Operand::Nothing,\n                    ];\n                }\n            }\n        } else if opword < 0b10101 {\n            // `ADR` on page `A8-320` -- v4T\n            let rd = instr2[8..11].load::<u8>();\n            let imm8 = instr2[..8].load::<u16>();\n            inst.opcode = Opcode::ADR;\n            inst.operands = [\n                Operand::Reg(Reg::from_u8(rd)),\n                Operand::Imm32(imm8 as u32 * 4),\n                Operand::Nothing,\n                Operand::Nothing,\n            ];\n        } else if opword < 0b10110 {\n            // `ADD (SP plus immediate)` on `A8-314` -- v4T\n            let rd = instr2[8..11].load::<u8>();\n            let imm8 = instr2[..8].load::<u16>();\n            inst.opcode = Opcode::ADD;\n            inst.operands = [\n                Operand::Reg(Reg::from_u8(rd)),\n                Operand::Reg(Reg::from_u8(13)), // sp\n                Operand::Imm32(imm8 as u32 * 4),\n                Operand::Nothing,\n            ];\n        } else if opword < 0b11000 {\n            // `Miscellaneous 16-bit instructions` on page `A6-226`\n            let opcode_bits = instr2[5..12].load::<u16>();\n            if opcode_bits < 0b0000100 {\n                // `Add Immediate to SP` (`A8-314`)\n                // v4T\n                // encoding T2\n                let imm7 = instr2[..7].load::<u32>();\n                inst.s = false;\n                inst.opcode = Opcode::ADD;\n                inst.operands = [\n                    Operand::Reg(Reg::from_u8(13)),\n                    Operand::Reg(Reg::from_u8(13)),\n                    Operand::Imm32(imm7 << 2),\n                    Operand::Nothing,\n                ];\n            } else if opcode_bits < 0b0001000 {\n                // `Subtract Immediate to SP` (`A8-717`)\n                // v4T\n                let imm7 = instr2[..7].load::<u32>();\n                inst.s = false;\n                inst.opcode = Opcode::SUB;\n                inst.operands = [\n                    Operand::Reg(Reg::from_u8(13)),\n                    Operand::Reg(Reg::from_u8(13)),\n                    Operand::Imm32(imm7 << 2),\n                    Operand::Nothing,\n                ];\n            } else if opcode_bits < 0b0010000 {\n                // `Compare and Branch on Zero` (`A8-354`)\n                // v6T2\n                let op = instr2[11];\n                let rn = instr2[..3].load::<u8>();\n                let imm5 = instr2[3..8].load::<u16>();\n                let imm = (((instr >> 9) & 1) << 5) | imm5;\n                inst.opcode = if op {\n                    Opcode::CBNZ\n                } else {\n                    Opcode::CBZ\n                };\n                inst.operands = [\n                    Operand::Reg(Reg::from_u8(rn)),\n                    Operand::BranchThumbOffset(imm as i32 + 1),\n                    Operand::Nothing,\n                    Operand::Nothing,\n                ];\n            } else if opcode_bits < 0b0010010 {\n                // `Signed Extend Halfword` (`A8-735`)\n                // v6\n                let rd = instr2[..3].load::<u8>();\n                let rm = instr2[3..6].load::<u8>();\n                inst.opcode = Opcode::SXTH;\n                inst.operands = [\n                    Operand::Reg(Reg::from_u8(rd)),\n                    Operand::Reg(Reg::from_u8(rm)),\n                    Operand::Nothing,\n                    Operand::Nothing,\n                ];\n            } else if opcode_bits < 0b0010100 {\n                // `Signed Extend Byte` (`A8-731`)\n                // v6\n                let rd = instr2[..3].load::<u8>();\n                let rm = instr2[3..6].load::<u8>();\n                inst.opcode = Opcode::SXTB;\n                inst.operands = [\n                    Operand::Reg(Reg::from_u8(rd)),\n                    Operand::Reg(Reg::from_u8(rm)),\n                    Operand::Nothing,\n                    Operand::Nothing,\n                ];\n            } else if opcode_bits < 0b0010110 {\n                // `Unsigned Extend Halfword` (`A8-817`)\n                // v6\n                let rd = instr2[..3].load::<u8>();\n                let rm = instr2[3..6].load::<u8>();\n                inst.opcode = Opcode::UXTH;\n                inst.operands = [\n                    Operand::Reg(Reg::from_u8(rd)),\n                    Operand::Reg(Reg::from_u8(rm)),\n                    Operand::Nothing,\n                    Operand::Nothing,\n                ];\n            } else if opcode_bits < 0b0011000 {\n                // `Unsigned Extend Byte` (`A8-813`)\n                // v6\n                let rd = instr2[..3].load::<u8>();\n                let rm = instr2[3..6].load::<u8>();\n                inst.opcode = Opcode::UXTB;\n                inst.operands = [\n                    Operand::Reg(Reg::from_u8(rd)),\n                    Operand::Reg(Reg::from_u8(rm)),\n                    Operand::Nothing,\n                    Operand::Nothing,\n                ];\n            } else if opcode_bits < 0b0100000 {\n                // `Compare and Branch on Zero` (`A8-354`)\n                // v6T2\n                let op = instr2[11];\n                let rn = instr2[..3].load::<u8>();\n                let imm5 = instr2[3..8].load::<u16>();\n                let imm = (((instr >> 9) & 1) << 5) | imm5;\n                inst.opcode = if op {\n                    Opcode::CBNZ\n                } else {\n                    Opcode::CBZ\n                };\n                inst.operands = [\n                    Operand::Reg(Reg::from_u8(rn)),\n                    Operand::BranchThumbOffset(imm as i32 + 1),\n                    Operand::Nothing,\n                    Operand::Nothing,\n                ];\n            } else if opcode_bits < 0b0110000 {\n                // `Push multiple registers` (`A8-539`)\n                // v4T\n                let m = instr2[8..9].load::<u16>();\n                let reglist = instr2[0..8].load::<u16>() | (m << (6 + 8));\n                inst.opcode = Opcode::PUSH;\n                inst.operands = [\n                    Operand::RegList(reglist),\n                    Operand::Nothing,\n                    Operand::Nothing,\n                    Operand::Nothing,\n                ];\n            } else if opcode_bits < 0b0110010 {\n                // undefined encoding between `PUSH` and `SETEND`\n                return Err(DecodeError::Undefined);\n            } else if opcode_bits < 0b0110011 {\n                // opword == 0b0110010\n                // `Set Endianness` (`A8-605`)\n                // v6\n                let e = instr2[3..4].load::<u16>();\n                inst.opcode = Opcode::SETEND;\n                inst.operands = [\n                    Operand::Imm12(e),\n                    Operand::Nothing,\n                    Operand::Nothing,\n                    Operand::Nothing,\n                ];\n            } else if opcode_bits < 0b0110100 {\n                // opword == 0b0110011\n                // `Change Processor State` (`B9-1964`)\n                // v6\n                let aif = instr2[0..3].load::<u16>();\n                let im = instr2[4];\n                inst.opcode = Opcode::CPS(im);\n                inst.operands = [\n                    Operand::Imm12(aif),\n                    Operand::Nothing,\n                    Operand::Nothing,\n                    Operand::Nothing,\n                ];\n            } else if opcode_bits < 0b1001000 {\n                // undefined encoding between `CPS` and `CBNZ/CBZ`\n                return Err(DecodeError::Undefined);\n            } else if opcode_bits < 0b1010000 {\n                // `Compare and Branch on Nonzero` (`A8-354`)\n                // v6T2\n                let op = instr2[11];\n                let rn = instr2[0..3].load::<u8>();\n                let imm5 = instr2[3..8].load::<u16>();\n                let imm = (((instr >> 9) & 1) << 5) | imm5;\n                inst.opcode = if op {\n                    Opcode::CBNZ\n                } else {\n                    Opcode::CBZ\n                };\n                inst.operands = [\n                    Operand::Reg(Reg::from_u8(rn)),\n                    Operand::BranchThumbOffset(imm as i32 + 1),\n                    Operand::Nothing,\n                    Operand::Nothing,\n                ];\n            } else if opcode_bits < 0b1010010 {\n                // `Byte-Reverse Word` (`A8-563`)\n                // v6\n                let rd = instr2[0..3].load::<u8>();\n                let rm = instr2[3..6].load::<u8>();\n                inst.opcode = Opcode::REV;\n                inst.operands = [\n                    Operand::Reg(Reg::from_u8(rd)),\n                    Operand::Reg(Reg::from_u8(rm)),\n                    Operand::Nothing,\n                    Operand::Nothing,\n                ];\n            } else if opcode_bits < 0b1010100 {\n                // `Byte-Reverse Packed Halfword` (`A8-565`)\n                // v6\n                let rd = instr2[0..3].load::<u8>();\n                let rm = instr2[3..6].load::<u8>();\n                inst.opcode = Opcode::REV16;\n                inst.operands = [\n                    Operand::Reg(Reg::from_u8(rd)),\n                    Operand::Reg(Reg::from_u8(rm)),\n                    Operand::Nothing,\n                    Operand::Nothing,\n                ];\n            } else if opcode_bits < 0b1010110 {\n                // undefined encoding where `Byte-Reverse Signed Word` might go\n                return Err(DecodeError::Undefined);\n            } else if opcode_bits < 0b1011000 {\n                // `Byte-Reverse Signed Halfword` (`A8-567`)\n                // v6\n                let rd = instr2[0..3].load::<u8>();\n                let rm = instr2[3..6].load::<u8>();\n                inst.opcode = Opcode::REVSH;\n                inst.operands = [\n                    Operand::Reg(Reg::from_u8(rd)),\n                    Operand::Reg(Reg::from_u8(rm)),\n                    Operand::Nothing,\n                    Operand::Nothing,\n                ];\n            } else if opcode_bits < 0b1100000 {\n                // `Compare and Branch on Nonzero` (`A8-354`)\n                // v6T2\n                let op = instr2[11];\n                let rn = instr2[0..3].load::<u8>();\n                let imm5 = instr2[3..8].load::<u16>();\n                let imm = (((instr >> 9) & 1) << 5) | imm5;\n                inst.opcode = if op {\n                    Opcode::CBNZ\n                } else {\n                    Opcode::CBZ\n                };\n                inst.operands = [\n                    Operand::Reg(Reg::from_u8(rn)),\n                    Operand::BranchThumbOffset(imm as i32 + 1),\n                    Operand::Nothing,\n                    Operand::Nothing,\n                ];\n            } else if opcode_bits < 0b1110000 {\n                // `Pop Multiple Registers` (`A8-535`)\n                // v4T\n                let p = instr2[8..9].load::<u16>();\n                let reglist = instr2[0..8].load::<u16>() | (p << (7 + 8));\n                inst.opcode = Opcode::POP;\n                inst.operands = [\n                    Operand::RegList(reglist),\n                    Operand::Nothing,\n                    Operand::Nothing,\n                    Operand::Nothing,\n                ];\n            } else if opcode_bits < 0b1111000 {\n                // `Breakpoint` (`A8-344`)\n                // v5\n                let imm8 = instr2[0..8].load::<u32>();\n                inst.opcode = Opcode::BKPT;\n                inst.operands = [\n                    Operand::Imm32(imm8),\n                    Operand::Nothing,\n                    Operand::Nothing,\n                    Operand::Nothing,\n                ];\n            } else {\n                // `If-Then, and hints` (`A6-227`)\n                let opb = instr2[0..4].load::<u32>();\n                let opa = instr2[4..8].load::<u32>();\n\n                if opb != 0 {\n                    // `IT` (`A8-391`)\n                    // v6T2\n                    let firstcond = opa;\n                    let mask = opb;\n                    inst.opcode = Opcode::IT;\n                    if firstcond == 0b1111 {\n                        return Err(DecodeError::InvalidOperand);\n                    }\n                    inst.operands = [\n                        Operand::Imm32(firstcond),\n                        Operand::Imm32(mask),\n                        Operand::Nothing,\n                        Operand::Nothing,\n                    ];\n                } else {\n                    match opa {\n                        0b0000 => {\n                            // `NOP` (`A8-511`)\n                            // v6T2\n                            inst.opcode = Opcode::NOP;\n                            inst.operands = [\n                                Operand::Nothing,\n                                Operand::Nothing,\n                                Operand::Nothing,\n                                Operand::Nothing,\n                            ];\n                        }\n                        0b0001 => {\n                            // `YIELD` (`A8-1109`)\n                            // v7\n                            inst.opcode = Opcode::YIELD;\n                            inst.operands = [\n                                Operand::Nothing,\n                                Operand::Nothing,\n                                Operand::Nothing,\n                                Operand::Nothing,\n                            ];\n                        }\n                        0b0010 => {\n                            // `WFE` (`A8-1105`)\n                            // v7\n                            inst.opcode = Opcode::WFE;\n                            inst.operands = [\n                                Operand::Nothing,\n                                Operand::Nothing,\n                                Operand::Nothing,\n                                Operand::Nothing,\n                            ];\n                        }\n                        0b0011 => {\n                            // `WFI` (`A8-1107`)\n                            // v7\n                            inst.opcode = Opcode::WFI;\n                            inst.operands = [\n                                Operand::Nothing,\n                                Operand::Nothing,\n                                Operand::Nothing,\n                                Operand::Nothing,\n                            ];\n                        }\n                        0b0100 => {\n                            // `SEV` (`A8-607`)\n                            // v7\n                            inst.opcode = Opcode::SEV;\n                            inst.operands = [\n                                Operand::Nothing,\n                                Operand::Nothing,\n                                Operand::Nothing,\n                                Operand::Nothing,\n                            ];\n                        }\n                        hint => {\n                            // `Other encodings in this space are unallocated hints. They execute\n                            // as NOPs, but software must not use them.`\n                            inst.opcode = Opcode::HINT;\n                            inst.operands = [\n                                Operand::Imm32(hint),\n                                Operand::Nothing,\n                                Operand::Nothing,\n                                Operand::Nothing,\n                            ];\n                        }\n                    }\n                }\n            }\n        } else if opword < 0b11001 {\n            // `STM (STMIA, STMEA)` on page `A8-665` -- v4T\n            let rn = instr2[8..11].load::<u8>();\n            let reglist = instr2[0..8].load::<u16>();\n            inst.opcode = Opcode::STM(true, true, false, true); // stmia, no wback, yes usermode\n            inst.operands = [\n                Operand::RegWBack(Reg::from_u8(rn), true), // always wback\n                Operand::RegList(reglist as u16),\n                Operand::Nothing,\n                Operand::Nothing,\n            ];\n        } else if opword < 0b11010 {\n            // `LDM/LDMIA/LDMFD (Thumb)` on page `A8-397` -- v4T\n            let rn = instr2[8..11].load::<u8>();\n            let reglist = instr2[0..8].load::<u16>();\n            let w = (reglist & (1 << rn)) == 0;\n            inst.opcode = Opcode::LDM(true, false, false, true); // ldmia, no wback, yes usermode\n            inst.operands = [\n                Operand::RegWBack(Reg::from_u8(rn), w),\n                Operand::RegList(reglist as u16),\n                Operand::Nothing,\n                Operand::Nothing,\n            ];\n        } else if opword < 0b11100 {\n            // `Conditional branch, and Supervisor Call` on page `A6-227`\n            let opcode = instr2[8..12].load::<u8>();\n            if opcode < 0b1110 {\n                // `B` (`A8-332`)\n                // v4T\n                inst.opcode = Opcode::B;\n                let imm = instr2[0..8].load::<u8>() as i8 as i32;\n                inst.condition = ConditionCode::build(opcode);\n                inst.operands = [\n                    Operand::BranchThumbOffset(imm + 1),\n                    Operand::Nothing,\n                    Operand::Nothing,\n                    Operand::Nothing,\n                ];\n            } else if opcode < 0b1111 {\n                // `UDF` (`A8-759`)\n                // v4T\n                // first described in revision `C.a`\n                inst.opcode = Opcode::UDF;\n                inst.operands = [\n                    Operand::Imm32(instr2[..8].load::<u32>()),\n                    Operand::Nothing,\n                    Operand::Nothing,\n                    Operand::Nothing,\n                ];\n            } else {\n                // `SVC` (`A8-721`)\n                // v4T\n                inst.opcode = Opcode::SVC;\n                inst.operands = [\n                    Operand::Imm32(instr2[..8].load::<u32>()),\n                    Operand::Nothing,\n                    Operand::Nothing,\n                    Operand::Nothing,\n                ];\n            }\n        } else {\n            // `B` on page `A8-332` -- v4T\n            // encoding T2\n            // v4T\n            inst.opcode = Opcode::B;\n            let imm = instr2[0..11].load::<u32>();\n            let imm = ((imm as i32) << 21) >> 21;\n            inst.operands = [\n                Operand::BranchThumbOffset(imm),\n                Operand::Nothing,\n                Operand::Nothing,\n                Operand::Nothing,\n            ];\n        }\n    }\n    Ok(())\n}"
}