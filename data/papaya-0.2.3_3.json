{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `raw::HashMap::<K, V, S>::compute_with`",
    "file": "papaya-0.2.3/src/raw/mod.rs",
    "start_line": 1547,
    "start_col": 5,
    "end_line": 1844,
    "end_col": 6,
    "code_snippet": "unsafe fn compute_with<'g, F, T>(\n        &self,\n        new_entry: &mut LazyEntry<K, V>,\n        mut state: ComputeState<F, K, V, T>,\n        guard: &'g impl VerifiedGuard,\n    ) -> Compute<'g, K, V, T>\n    where\n        F: FnMut(Option<(&'g K, &'g V)>) -> Operation<V, T>,\n    {\n        // Load the root table.\n        let mut table = self.root(guard);\n\n        // The table has not yet been allocated.\n        if table.raw.is_null() {\n            // Compute the value to insert.\n            //\n            // Safety: Insert transitions are always sound.\n            match unsafe { state.next(None) } {\n                op @ Operation::Insert(_) => state.restore(None, op),\n                Operation::Remove => panic!(\"Cannot remove `None` entry.\"),\n                Operation::Abort(value) => return Compute::Aborted(value),\n            }\n\n            // Initialize the table.\n            table = self.init(None);\n        }\n\n        let (h1, h2) = self.hash(new_entry.key());\n        let mut help_copy = false;\n\n        loop {\n            // Initialize the probe state.\n            let mut probe = Probe::start(h1, table.mask);\n\n            // Probe until we reach the limit.\n            let copying = 'probe: loop {\n                if probe.len > table.limit {\n                    break 'probe None;\n                }\n\n                // Load the entry metadata first for cheap searches.\n                //\n                // Safety: `probe.i` is always in-bounds for the table length.\n                let meta = unsafe { table.meta(probe.i) }.load(Ordering::Acquire);\n\n                // The entry is empty.\n                let mut entry = if meta == meta::EMPTY {\n                    // Compute the value to insert.\n                    //\n                    // Safety: Insert transitions are always sound.\n                    let value = match unsafe { state.next(None) } {\n                        Operation::Insert(value) => value,\n                        Operation::Remove => panic!(\"Cannot remove `None` entry.\"),\n                        Operation::Abort(value) => return Compute::Aborted(value),\n                    };\n\n                    let new_entry = new_entry.init();\n                    // Safety: `new_entry` was just allocated above and is valid for writes.\n                    unsafe { (*new_entry).value = MaybeUninit::new(value) }\n\n                    // Attempt to insert.\n                    //\n                    // Safety: `probe.i` is always in-bounds for the table length.Additionally,\n                    // `new_entry` was allocated above and never shared.\n                    match unsafe { self.insert_at(probe.i, h2, new_entry.cast(), table, guard) } {\n                        // Successfully inserted.\n                        InsertStatus::Inserted => {\n                            // Increment the table length.\n                            self.count.get(guard).fetch_add(1, Ordering::Relaxed);\n\n                            // Safety: `new_entry` was initialized above.\n                            let new_ref = unsafe { &*new_entry.cast::<Entry<K, V>>() };\n                            return Compute::Inserted(&new_ref.key, &new_ref.value);\n                        }\n\n                        // Lost to a concurrent insert.\n                        //\n                        // If the key matches, we might be able to update the value.\n                        InsertStatus::Found(EntryStatus::Value(found))\n                        | InsertStatus::Found(EntryStatus::Copied(found)) => {\n                            // Cache the previous value\n                            //\n                            // Safety: `new_entry` was initialized above and was not inserted\n                            // into the map.\n                            let value = unsafe { (*new_entry).value.assume_init_read() };\n                            state.restore(None, Operation::Insert(value));\n\n                            found\n                        }\n\n                        // The entry was removed or invalidated.\n                        InsertStatus::Found(EntryStatus::Null) => {\n                            // Cache the previous value.\n                            //\n                            // Safety: `new_entry` was initialized above and was not inserted\n                            // into the map.\n                            let value = unsafe { (*new_entry).value.assume_init_read() };\n                            state.restore(None, Operation::Insert(value));\n\n                            // Continue probing.\n                            probe.next(table.mask);\n                            continue 'probe;\n                        }\n                    }\n                }\n                // Found a potential match.\n                else if meta == h2 {\n                    // Load the full entry.\n                    //\n                    // Safety: `probe.i` is always in-bounds for the table length.\n                    let found = guard\n                        .protect(unsafe { table.entry(probe.i) }, Ordering::Acquire)\n                        .unpack();\n\n                    // The entry was deleted, keep probing.\n                    if found.ptr.is_null() {\n                        probe.next(table.mask);\n                        continue 'probe;\n                    }\n\n                    // If the key matches, we might be able to update the value.\n                    found\n                }\n                // Otherwise, continue probing.\n                else {\n                    probe.next(table.mask);\n                    continue 'probe;\n                };\n\n                // Check for a full match.\n                //\n                // Safety: We performed a protected load of the pointer using a verified guard with\n                // `Acquire` and ensured that it is non-null, meaning it is valid for reads as long\n                // as we hold the guard.\n                if unsafe { (*entry.ptr).key != *new_entry.key() } {\n                    probe.next(table.mask);\n                    continue 'probe;\n                }\n\n                // The entry is being copied to the new table.\n                if entry.tag() & Entry::COPYING != 0 {\n                    break 'probe Some(probe.i);\n                }\n\n                loop {\n                    // Compute the value to insert.\n                    //\n                    // Safety: `entry` is valid for reads.\n                    let failure = match unsafe { state.next(Some(entry.ptr)) } {\n                        // The operation was aborted.\n                        Operation::Abort(value) => return Compute::Aborted(value),\n\n                        // Update the value.\n                        Operation::Insert(value) => {\n                            let new_entry = new_entry.init();\n\n                            // Safety: `new_entry` was just allocated above and is valid for writes.\n                            unsafe { (*new_entry).value = MaybeUninit::new(value) }\n\n                            // Try to perform the update.\n                            //\n                            // Safety:\n                            // - `probe.i` is always in-bounds for the table length\n                            // - `entry` is a valid non-null entry that we found in the map.\n                            // - `new_entry` was initialized above and never shared.\n                            let status = unsafe {\n                                self.update_at(probe.i, entry, new_entry.cast(), table, guard)\n                            };\n\n                            match status {\n                                // Successfully updated.\n                                UpdateStatus::Replaced(entry) => {\n                                    // Safety: `entry` is a valid non-null entry that we found in the map\n                                    // before replacing it.\n                                    let entry_ref = unsafe { &(*entry.ptr) };\n\n                                    // Safety: `new_entry` was initialized above.\n                                    let new_ref = unsafe { &*new_entry.cast::<Entry<K, V>>() };\n\n                                    return Compute::Updated {\n                                        old: (&entry_ref.key, &entry_ref.value),\n                                        new: (&new_ref.key, &new_ref.value),\n                                    };\n                                }\n\n                                // The update failed.\n                                failure => {\n                                    // Save the previous value.\n                                    //\n                                    // Safety: `new_entry` was initialized above and was not inserted\n                                    // into the map.\n                                    let value = unsafe { (*new_entry).value.assume_init_read() };\n                                    state.restore(Some(entry.ptr), Operation::Insert(value));\n\n                                    failure\n                                }\n                            }\n                        }\n\n                        // Remove the key from the map.\n                        Operation::Remove => {\n                            // Try to perform the removal.\n                            //\n                            // Safety:\n                            // - `probe.i` is always in-bounds for the table length\n                            // - `entry` is a valid non-null entry that we found in the map.\n                            let status = unsafe {\n                                self.update_at(probe.i, entry, Entry::TOMBSTONE, table, guard)\n                            };\n\n                            match status {\n                                // Successfully removed the entry.\n                                UpdateStatus::Replaced(entry) => {\n                                    // Mark the entry as a tombstone.\n                                    //\n                                    // Note that this might end up being overwritten by the metadata hash\n                                    // if the initial insertion is lagging behind, but we avoid the RMW\n                                    // and sacrifice reads in the extremely rare case.\n                                    unsafe {\n                                        table\n                                            .meta(probe.i)\n                                            .store(meta::TOMBSTONE, Ordering::Release)\n                                    };\n\n                                    // Decrement the table length.\n                                    self.count.get(guard).fetch_sub(1, Ordering::Relaxed);\n\n                                    // Safety: `entry` is a valid non-null entry that we found in the map\n                                    // before replacing it.\n                                    let entry_ref = unsafe { &(*entry.ptr) };\n                                    return Compute::Removed(&entry_ref.key, &entry_ref.value);\n                                }\n\n                                // The remove failed.\n                                failure => {\n                                    // Save the removal operation.\n                                    state.restore(Some(entry.ptr), Operation::Remove);\n\n                                    failure\n                                }\n                            }\n                        }\n                    };\n\n                    match failure {\n                        // The entry is being copied to the new table.\n                        UpdateStatus::Found(EntryStatus::Copied(_)) => break 'probe Some(probe.i),\n\n                        // The entry was deleted before we could update it.\n                        //\n                        // We know that at some point during our execution the key was not in the map.\n                        UpdateStatus::Found(EntryStatus::Null) => {\n                            // Compute the next operation.\n                            //\n                            // Safety: Insert transitions are always sound.\n                            match unsafe { state.next(None) } {\n                                Operation::Insert(value) => {\n                                    // Save the computed value.\n                                    state.restore(None, Operation::Insert(value));\n\n                                    // Continue probing to find an empty slot.\n                                    probe.next(table.mask);\n                                    continue 'probe;\n                                }\n                                Operation::Remove => panic!(\"Cannot remove `None` entry.\"),\n                                Operation::Abort(value) => return Compute::Aborted(value),\n                            }\n                        }\n\n                        // Someone else beat us to the update, retry.\n                        UpdateStatus::Found(EntryStatus::Value(found)) => entry = found,\n\n                        _ => unreachable!(),\n                    }\n                }\n            };\n\n            // Prepare to retry in the next table.\n            if let Some(next_table) = self.prepare_retry(copying, &mut help_copy, table, guard) {\n                table = next_table;\n                continue;\n            }\n\n            // Otherwise, the key is not in the map.\n            //\n            // Safety: Insert transitions are always sound.\n            match unsafe { state.next(None) } {\n                // Need to insert into the new table.\n                op @ Operation::Insert(_) => {\n                    table = self.prepare_retry_insert(None, &mut help_copy, table, guard);\n                    state.restore(None, op);\n                }\n                // The operation was aborted.\n                Operation::Abort(value) => return Compute::Aborted(value),\n                Operation::Remove => panic!(\"Cannot remove `None` entry.\"),\n            }\n        }\n    }"
}