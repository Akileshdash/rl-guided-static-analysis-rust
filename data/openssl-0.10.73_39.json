{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `ssl::callbacks::raw_server_psk`",
    "file": "openssl-0.10.73/src/ssl/callbacks.rs",
    "start_line": 102,
    "start_col": 1,
    "end_line": 138,
    "end_col": 2,
    "code_snippet": "pub extern \"C\" fn raw_server_psk<F>(\n    ssl: *mut ffi::SSL,\n    identity: *const c_char,\n    psk: *mut c_uchar,\n    max_psk_len: c_uint,\n) -> c_uint\nwhere\n    F: Fn(&mut SslRef, Option<&[u8]>, &mut [u8]) -> Result<usize, ErrorStack>\n        + 'static\n        + Sync\n        + Send,\n{\n    unsafe {\n        let ssl = SslRef::from_ptr_mut(ssl);\n        let callback_idx = SslContext::cached_ex_index::<F>();\n\n        let callback = ssl\n            .ssl_context()\n            .ex_data(callback_idx)\n            .expect(\"BUG: psk callback missing\") as *const F;\n        let identity = if identity.is_null() {\n            None\n        } else {\n            Some(CStr::from_ptr(identity).to_bytes())\n        };\n        // Give the callback mutable slices into which it can write the psk.\n        #[allow(clippy::unnecessary_cast)]\n        let psk_sl = util::from_raw_parts_mut(psk as *mut u8, max_psk_len as usize);\n        match (*callback)(ssl, identity, psk_sl) {\n            Ok(psk_len) => psk_len as u32,\n            Err(e) => {\n                e.put();\n                0\n            }\n        }\n    }\n}"
}