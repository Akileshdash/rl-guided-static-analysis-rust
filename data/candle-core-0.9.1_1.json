{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `cpu_backend::utils::binary_map_vec`",
    "file": "candle-core-0.9.1/src/cpu_backend/utils.rs",
    "start_line": 188,
    "start_col": 1,
    "end_line": 297,
    "end_col": 2,
    "code_snippet": "pub fn binary_map_vec<T: Copy, F: FnMut(T, T) -> T, FV: FnMut(&[T], &[T], &mut [T])>(\n    lhs_l: &Layout,\n    rhs_l: &Layout,\n    lhs: &[T],\n    rhs: &[T],\n    mut f: F,\n    mut f_vec: FV,\n) -> Vec<T> {\n    let el_count = lhs_l.shape().elem_count();\n    match (lhs_l.contiguous_offsets(), rhs_l.contiguous_offsets()) {\n        (Some((o_l1, o_l2)), Some((o_r1, o_r2))) => {\n            let mut ys: Vec<T> = Vec::with_capacity(el_count);\n            let ys_to_set = ys.spare_capacity_mut();\n            let ys_to_set = unsafe {\n                std::mem::transmute::<&mut [std::mem::MaybeUninit<T>], &mut [T]>(ys_to_set)\n            };\n            f_vec(&lhs[o_l1..o_l2], &rhs[o_r1..o_r2], ys_to_set);\n            // SAFETY: values are all set by f_vec.\n            unsafe { ys.set_len(el_count) };\n            ys\n        }\n        (Some((o_l1, o_l2)), None) => match rhs_l.offsets_b() {\n            Some(ob) if ob.right_broadcast == 1 => {\n                let rhs = &rhs[ob.start..ob.start + ob.len];\n                let mut ys: Vec<T> = Vec::with_capacity(el_count);\n                let ys_to_set = ys.spare_capacity_mut();\n                let ys_to_set = unsafe {\n                    std::mem::transmute::<&mut [std::mem::MaybeUninit<T>], &mut [T]>(ys_to_set)\n                };\n                let mut dst_i = 0;\n                for src_i in (o_l1..o_l2).step_by(ob.len) {\n                    f_vec(\n                        &lhs[src_i..src_i + ob.len],\n                        rhs,\n                        &mut ys_to_set[dst_i..dst_i + ob.len],\n                    );\n                    dst_i += ob.len;\n                }\n                // SAFETY: values are all set by f_vec.\n                unsafe { ys.set_len(el_count) };\n                ys\n            }\n            Some(ob) => {\n                let rhs = &rhs[ob.start..ob.start + ob.len];\n                let mut ys = lhs[o_l1..o_l2].to_vec();\n                for idx_l in 0..ob.left_broadcast {\n                    let start = idx_l * ob.len * ob.right_broadcast;\n                    for (i, &r) in rhs.iter().enumerate() {\n                        let start = start + i * ob.right_broadcast;\n                        for v in ys[start..start + ob.right_broadcast].iter_mut() {\n                            *v = f(*v, r)\n                        }\n                    }\n                }\n                ys\n            }\n            None => lhs_l\n                .strided_index()\n                .zip(rhs_l.strided_index())\n                .map(|(lhs_i, rhs_i)| f(lhs[lhs_i], rhs[rhs_i]))\n                .collect(),\n        },\n        (None, Some((o_r1, o_r2))) => match lhs_l.offsets_b() {\n            Some(ob) if ob.right_broadcast == 1 => {\n                let lhs = &lhs[ob.start..ob.start + ob.len];\n                let mut ys: Vec<T> = Vec::with_capacity(el_count);\n                let ys_to_set = ys.spare_capacity_mut();\n                let ys_to_set = unsafe {\n                    std::mem::transmute::<&mut [std::mem::MaybeUninit<T>], &mut [T]>(ys_to_set)\n                };\n                let mut dst_i = 0;\n                for src_i in (o_r1..o_r2).step_by(ob.len) {\n                    f_vec(\n                        lhs,\n                        &rhs[src_i..src_i + ob.len],\n                        &mut ys_to_set[dst_i..dst_i + ob.len],\n                    );\n                    dst_i += ob.len;\n                }\n                // SAFETY: values are all set by f_vec.\n                unsafe { ys.set_len(el_count) };\n                ys\n            }\n            Some(ob) => {\n                let lhs = &lhs[ob.start..ob.start + ob.len];\n                let mut ys = rhs[o_r1..o_r2].to_vec();\n                for idx_l in 0..ob.left_broadcast {\n                    let start = idx_l * ob.len * ob.right_broadcast;\n                    for (i, &l) in lhs.iter().enumerate() {\n                        let start = start + i * ob.right_broadcast;\n                        for v in ys[start..start + ob.right_broadcast].iter_mut() {\n                            *v = f(l, *v)\n                        }\n                    }\n                }\n                ys\n            }\n            None => lhs_l\n                .strided_index()\n                .zip(rhs_l.strided_index())\n                .map(|(lhs_i, rhs_i)| f(lhs[lhs_i], rhs[rhs_i]))\n                .collect(),\n        },\n        _ => lhs_l\n            .strided_index()\n            .zip(rhs_l.strided_index())\n            .map(|(lhs_i, rhs_i)| f(lhs[lhs_i], rhs[rhs_i]))\n            .collect(),\n    }\n}"
}