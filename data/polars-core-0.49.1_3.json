{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `frame::column::Column::agg_with_unit_scalar`",
    "file": "polars-core-0.49.1/src/frame/column/mod.rs",
    "start_line": 656,
    "start_col": 5,
    "end_line": 725,
    "end_col": 6,
    "code_snippet": "fn agg_with_unit_scalar(\n        &self,\n        groups: &GroupsType,\n        series_agg: impl Fn(&Series, &GroupsType) -> Series,\n    ) -> Column {\n        match self {\n            Column::Series(s) => series_agg(s, groups).into_column(),\n            // @partition-opt\n            Column::Partitioned(s) => series_agg(s.as_materialized_series(), groups).into_column(),\n            Column::Scalar(s) => {\n                if s.is_empty() {\n                    return series_agg(s.as_materialized_series(), groups).into_column();\n                }\n\n                // We utilize the aggregation on Series to see:\n                // 1. the output datatype of the aggregation\n                // 2. whether this aggregation is even defined\n                let series_aggregation = series_agg(\n                    &s.as_single_value_series(),\n                    &GroupsType::Slice {\n                        // @NOTE: this group is always valid since s is non-empty.\n                        groups: vec![[0, 1]],\n                        rolling: false,\n                    },\n                );\n\n                // If the aggregation is not defined, just return all nulls.\n                if series_aggregation.has_nulls() {\n                    return Self::new_scalar(\n                        series_aggregation.name().clone(),\n                        Scalar::new(series_aggregation.dtype().clone(), AnyValue::Null),\n                        groups.len(),\n                    );\n                }\n\n                let mut scalar_col = s.resize(groups.len());\n                // The aggregation might change the type (e.g. mean changes int -> float), so we do\n                // a cast here to the output type.\n                if series_aggregation.dtype() != s.dtype() {\n                    scalar_col = scalar_col.cast(series_aggregation.dtype()).unwrap();\n                }\n\n                let Some(first_empty_idx) = groups.iter().position(|g| g.is_empty()) else {\n                    // Fast path: no empty groups. keep the scalar intact.\n                    return scalar_col.into_column();\n                };\n\n                // All empty groups produce a *missing* or `null` value.\n                let mut validity = BitmapBuilder::with_capacity(groups.len());\n                validity.extend_constant(first_empty_idx, true);\n                // SAFETY: We trust the length of this iterator.\n                let iter = unsafe {\n                    TrustMyLength::new(\n                        groups.iter().skip(first_empty_idx).map(|g| !g.is_empty()),\n                        groups.len() - first_empty_idx,\n                    )\n                };\n                validity.extend_trusted_len_iter(iter);\n\n                let mut s = scalar_col.take_materialized_series().rechunk();\n                // SAFETY: We perform a compute_len afterwards.\n                let chunks = unsafe { s.chunks_mut() };\n                let arr = &mut chunks[0];\n                *arr = arr.with_validity(validity.into_opt_validity());\n                s.compute_len();\n\n                s.into_column()\n            },\n        }\n    }"
}