{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `Inner::<K, V, FANOUT, LOCAL_GC_BUFFER_SIZE>::leaf_for_key`",
    "file": "concurrent-map-5.0.37/src/lib.rs",
    "start_line": 2092,
    "start_col": 5,
    "end_line": 2295,
    "end_col": 6,
    "code_snippet": "fn leaf_for_key<'a, Q>(\n        &'a self,\n        search: LeafSearch<&Q>,\n        guard: &mut Guard<'a, Deferred<K, V, FANOUT>, LOCAL_GC_BUFFER_SIZE>,\n    ) -> NodeView<K, V, FANOUT>\n    where\n        K: Borrow<Q>,\n        Q: Ord + ?Sized,\n    {\n        let mut parent_cursor_opt: Option<NodeView<K, V, FANOUT>> = None;\n        let mut cursor = self.root(guard);\n        let mut root_cursor = NodeView {\n            ptr: cursor.ptr,\n            id: cursor.id,\n        };\n\n        macro_rules! reset {\n            ($reason:expr) => {\n                // println!(\"resetting because of {:?}\", $reason);\n                parent_cursor_opt = None;\n                cursor = self.root(guard);\n                root_cursor = NodeView {\n                    ptr: cursor.ptr,\n                    id: cursor.id,\n                };\n                continue;\n            };\n        }\n\n        #[cfg(feature = \"timing\")]\n        let before = Instant::now();\n\n        loop {\n            if let Some(merging_child_ptr) = cursor.merging_child {\n                let mut child = if let Some(view) = merging_child_ptr.node_view(guard) {\n                    view\n                } else {\n                    reset!(\"merging child of marked parent already freed\");\n                };\n                self.merge_child(&mut cursor, &mut child, guard);\n                reset!(\"cooperatively performed merge_child after detecting parent\");\n            }\n\n            if cursor.is_merging {\n                reset!(\"resetting after detected child merging without corresponding parent child_merge\");\n            }\n\n            if cursor.should_merge() {\n                if let Some(ref mut parent_cursor) = parent_cursor_opt {\n                    let is_leftmost_child =\n                        parent_cursor.index().get_index(0).unwrap().0 == cursor.lo;\n\n                    if !is_leftmost_child {\n                        if let Ok(new_parent) =\n                            self.install_parent_merge(parent_cursor, &cursor, guard)\n                        {\n                            *parent_cursor = new_parent;\n                        } else {\n                            reset!(\"failed to install parent merge\");\n                        }\n\n                        self.merge_child(parent_cursor, &mut cursor, guard);\n                        reset!(\"completed merge_child\");\n                    }\n                } else {\n                    assert!(!cursor.is_leaf());\n                }\n            }\n\n            match search {\n                LeafSearch::Eq(k) | LeafSearch::Lt(k) => assert!(k >= cursor.lo.borrow()),\n                LeafSearch::Max => {}\n            }\n\n            if let Some(hi) = &cursor.hi {\n                let go_right = match search {\n                    LeafSearch::Eq(k) => k >= hi.borrow(),\n                    // Lt looks for a node with lo < K, hi >= K\n                    LeafSearch::Lt(k) => k > hi.borrow(),\n                    LeafSearch::Max => true,\n                };\n                if go_right {\n                    // go right to the tree sibling\n                    let next = cursor.next.unwrap();\n                    let rhs = if let Some(view) = next.node_view(guard) {\n                        view\n                    } else {\n                        reset!(\"right child already freed\");\n                    };\n\n                    if let Some(ref mut parent_cursor) = parent_cursor_opt {\n                        if parent_cursor.is_viable_parent_for(&rhs) {\n                            let mut parent_clone: Box<Node<K, V, FANOUT>> =\n                                Box::new((*parent_cursor).clone());\n                            assert!(!parent_clone.is_leaf());\n                            parent_clone.index_mut().insert(rhs.lo.clone(), next);\n\n                            let rhs_ptr_opt = if parent_clone.should_split() {\n                                Some(parent_clone.split())\n                            } else {\n                                None\n                            };\n\n                            if let Ok(new_parent_view) = parent_cursor.cas(parent_clone, guard) {\n                                parent_cursor_opt = Some(new_parent_view);\n                            } else if let Some(rhs_ptr) = rhs_ptr_opt {\n                                let reclaimed_ptr: Box<AtomicPtr<Node<K, V, FANOUT>>> =\n                                    unsafe { Box::from_raw(rhs_ptr.0 as *mut _) };\n\n                                let _dropping_reclaimed_rhs: Box<Node<K, V, FANOUT>> =\n                                    unsafe { Box::from_raw(reclaimed_ptr.load(Ordering::Acquire)) };\n                            }\n                        }\n                    } else {\n                        // root hoist\n                        let current_root_ptr: AtomicPtr<_> = root_cursor.ptr.as_ptr().into();\n                        let new_index_ptr =\n                            BoxedAtomicPtr(Box::into_raw(Box::new(current_root_ptr)));\n\n                        let mut new_root_node = Node::<K, V, FANOUT>::new_root();\n                        new_root_node\n                            .index_mut()\n                            .insert(cursor.lo.clone(), new_index_ptr);\n                        new_root_node.index_mut().insert(rhs.lo.clone(), next);\n                        let new_root_ptr = Box::into_raw(new_root_node);\n\n                        let worked = !debug_delay()\n                            && self\n                                .root\n                                .compare_exchange(\n                                    root_cursor.ptr.as_ptr(),\n                                    new_root_ptr,\n                                    Ordering::AcqRel,\n                                    Ordering::Acquire,\n                                )\n                                .is_ok();\n\n                        if worked {\n                            let parent_view = NodeView {\n                                id: self.root,\n                                ptr: NonNull::new(new_root_ptr).unwrap(),\n                            };\n                            parent_cursor_opt = Some(parent_view);\n                        } else {\n                            let dangling_root = unsafe { Box::from_raw(new_root_ptr) };\n                            drop(dangling_root);\n\n                            let reclaimed_ptr: Box<AtomicPtr<Node<K, V, FANOUT>>> =\n                                unsafe { Box::from_raw(new_index_ptr.0 as *mut _) };\n                            drop(reclaimed_ptr);\n                        }\n                    }\n\n                    cursor = rhs;\n                    continue;\n                }\n            }\n\n            if cursor.is_leaf() {\n                assert!(!cursor.is_merging);\n                assert!(cursor.merging_child.is_none());\n                if let Some(ref hi) = cursor.hi {\n                    match search {\n                        LeafSearch::Eq(k) => assert!(k < hi.borrow()),\n                        LeafSearch::Lt(k) => assert!(k <= hi.borrow()),\n                        LeafSearch::Max => {\n                            unreachable!(\"leaf should have no hi key if we're searching for Max\")\n                        }\n                    }\n                }\n                break;\n            }\n\n            // go down the tree\n            let index = cursor.index();\n            let child_ptr = match search {\n                LeafSearch::Eq(k) => index.get_less_than_or_equal(k).unwrap().1,\n                LeafSearch::Lt(k) => {\n                    // Lt looks for a node with lo < K and hi >= K\n                    // so we find the first child with a lo key > K and\n                    // return its left sibling\n                    index.get_less_than(k).unwrap().1\n                }\n                LeafSearch::Max => {\n                    index\n                        .get_index(index.len().checked_sub(1).unwrap())\n                        .unwrap()\n                        .1\n                }\n            };\n\n            parent_cursor_opt = Some(cursor);\n            cursor = if let Some(view) = child_ptr.node_view(guard) {\n                view\n            } else {\n                reset!(\"attempt to traverse to child failed because the child has been freed\");\n            };\n        }\n\n        #[cfg(feature = \"timing\")]\n        self.record_timing(before.elapsed());\n\n        cursor\n    }"
}