{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `internals::bptree::node::Branch::<K, V>::req_clone`",
    "file": "concread-0.5.7/src/internals/bptree/node.rs",
    "start_line": 989,
    "start_col": 5,
    "end_line": 1027,
    "end_col": 6,
    "code_snippet": "pub(crate) fn req_clone(&self, txid: u64) -> Option<*mut Node<K, V>> {\n        debug_assert_branch!(self);\n        if self.get_txid() == txid {\n            // Same txn, no action needed.\n            None\n        } else {\n            // println!(\"Req clone branch\");\n            // Diff txn, must clone.\n            // # https://github.com/kanidm/concread/issues/55\n            // We flag the node as unable to drop it's internals.\n            let new_txid =\n                (self.meta.0 & (FLAG_MASK | COUNT_MASK)) | (txid << TXID_SHF) | FLAG_INVALID;\n            let mut x: Box<CachePadded<Branch<K, V>>> = Box::new(CachePadded::new(Branch {\n                // Need to preserve count.\n                meta: Meta(new_txid),\n                key: unsafe { MaybeUninit::uninit().assume_init() },\n                // We can simply clone the pointers.\n                nodes: self.nodes,\n                #[cfg(all(test, not(miri)))]\n                nid: alloc_nid(),\n            }));\n\n            debug_assert!((x.meta.0 & FLAG_INVALID) != 0);\n\n            // Copy in the keys to the correct location.\n            for idx in 0..self.count() {\n                unsafe {\n                    let lkey = (*self.key[idx].as_ptr()).clone();\n                    x.key[idx].as_mut_ptr().write(lkey);\n                }\n            }\n            // Finally undo the invalid flag to allow drop to proceed.\n            x.meta.0 &= !FLAG_INVALID;\n\n            debug_assert!((x.meta.0 & FLAG_INVALID) == 0);\n\n            Some(Box::into_raw(x) as *mut Node<K, V>)\n        }\n    }"
}