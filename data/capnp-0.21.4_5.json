{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<serialize_packed::PackedWrite<W> as io::Write>::write_all`",
    "file": "capnp-0.21.4/src/serialize_packed.rs",
    "start_line": 304,
    "start_col": 5,
    "end_line": 438,
    "end_col": 6,
    "code_snippet": "fn write_all(&mut self, in_buf: &[u8]) -> Result<()> {\n        unsafe {\n            let mut buf_idx: usize = 0;\n            let mut buf: [u8; 64] = [0; 64];\n\n            let mut in_ptr: *const u8 = in_buf.as_ptr();\n            let in_end: *const u8 = in_buf.as_ptr().wrapping_add(in_buf.len());\n\n            while in_ptr < in_end {\n                if buf_idx + 10 > buf.len() {\n                    //# Oops, we're out of space. We need at least 10\n                    //# bytes for the fast path, since we don't\n                    //# bounds-check on every byte.\n                    self.inner.write_all(&buf[..buf_idx])?;\n                    buf_idx = 0;\n                }\n\n                let tag_pos = buf_idx;\n                buf_idx += 1;\n\n                let bit0 = u8::from(*in_ptr != 0);\n                *buf.get_unchecked_mut(buf_idx) = *in_ptr;\n                buf_idx += bit0 as usize;\n                in_ptr = in_ptr.offset(1);\n\n                let bit1 = u8::from(*in_ptr != 0);\n                *buf.get_unchecked_mut(buf_idx) = *in_ptr;\n                buf_idx += bit1 as usize;\n                in_ptr = in_ptr.offset(1);\n\n                let bit2 = u8::from(*in_ptr != 0);\n                *buf.get_unchecked_mut(buf_idx) = *in_ptr;\n                buf_idx += bit2 as usize;\n                in_ptr = in_ptr.offset(1);\n\n                let bit3 = u8::from(*in_ptr != 0);\n                *buf.get_unchecked_mut(buf_idx) = *in_ptr;\n                buf_idx += bit3 as usize;\n                in_ptr = in_ptr.offset(1);\n\n                let bit4 = u8::from(*in_ptr != 0);\n                *buf.get_unchecked_mut(buf_idx) = *in_ptr;\n                buf_idx += bit4 as usize;\n                in_ptr = in_ptr.offset(1);\n\n                let bit5 = u8::from(*in_ptr != 0);\n                *buf.get_unchecked_mut(buf_idx) = *in_ptr;\n                buf_idx += bit5 as usize;\n                in_ptr = in_ptr.offset(1);\n\n                let bit6 = u8::from(*in_ptr != 0);\n                *buf.get_unchecked_mut(buf_idx) = *in_ptr;\n                buf_idx += bit6 as usize;\n                in_ptr = in_ptr.offset(1);\n\n                let bit7 = u8::from(*in_ptr != 0);\n                *buf.get_unchecked_mut(buf_idx) = *in_ptr;\n                buf_idx += bit7 as usize;\n                in_ptr = in_ptr.offset(1);\n\n                let tag: u8 = bit0\n                    | (bit1 << 1)\n                    | (bit2 << 2)\n                    | (bit3 << 3)\n                    | (bit4 << 4)\n                    | (bit5 << 5)\n                    | (bit6 << 6)\n                    | (bit7 << 7);\n\n                *buf.get_unchecked_mut(tag_pos) = tag;\n\n                if tag == 0 {\n                    //# An all-zero word is followed by a count of\n                    //# consecutive zero words (not including the first\n                    //# one).\n\n                    let mut in_word: *const [u8; 8] = in_ptr as *const [u8; 8];\n                    let mut limit: *const [u8; 8] = in_end as *const [u8; 8];\n                    if ptr_sub(limit, in_word) > 255 {\n                        limit = in_word.offset(255);\n                    }\n                    while in_word < limit && *in_word == [0; 8] {\n                        in_word = in_word.offset(1);\n                    }\n\n                    *buf.get_unchecked_mut(buf_idx) =\n                        ptr_sub(in_word, in_ptr as *const [u8; 8]) as u8;\n                    buf_idx += 1;\n                    in_ptr = in_word as *const u8;\n                } else if tag == 0xff {\n                    //# An all-nonzero word is followed by a count of\n                    //# consecutive uncompressed words, followed by the\n                    //# uncompressed words themselves.\n\n                    //# Count the number of consecutive words in the input\n                    //# which have no more than a single zero-byte. We look\n                    //# for at least two zeros because that's the point\n                    //# where our compression scheme becomes a net win.\n                    let run_start = in_ptr;\n                    let mut limit = in_end;\n                    if ptr_sub(limit, in_ptr) > 255 * 8 {\n                        limit = in_ptr.offset(255 * 8);\n                    }\n\n                    while in_ptr < limit {\n                        let mut c = 0;\n\n                        for _ in 0..8 {\n                            c += u8::from(*in_ptr == 0);\n                            in_ptr = in_ptr.offset(1);\n                        }\n\n                        if c >= 2 {\n                            //# Un-read the word with multiple zeros, since\n                            //# we'll want to compress that one.\n                            in_ptr = in_ptr.offset(-8);\n                            break;\n                        }\n                    }\n\n                    let count: usize = ptr_sub(in_ptr, run_start);\n                    *buf.get_unchecked_mut(buf_idx) = (count / 8) as u8;\n                    buf_idx += 1;\n\n                    self.inner.write_all(&buf[..buf_idx])?;\n                    buf_idx = 0;\n                    self.inner\n                        .write_all(slice::from_raw_parts::<u8>(run_start, count))?;\n                }\n            }\n\n            self.inner.write_all(&buf[..buf_idx])?;\n            Ok(())\n        }\n    }"
}