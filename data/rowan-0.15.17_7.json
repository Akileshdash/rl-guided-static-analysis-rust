{
    "level": "Warning",
    "analyzer": "UnsafeDataflow",
    "op_type": "WriteFlow",
    "description": "Potential unsafe dataflow issue in `arc::ThinArc::<H, T>::from_header_and_iter`",
    "file": "rowan-0.15.17/src/arc.rs",
    "start_line": 328,
    "start_col": 5,
    "end_line": 397,
    "end_col": 6,
    "code_snippet": "pub(crate) fn from_header_and_iter<I>(header: H, mut items: I) -> Self\n    where\n        I: Iterator<Item = T> + ExactSizeIterator,\n    {\n        assert_ne!(mem::size_of::<T>(), 0, \"Need to think about ZST\");\n\n        let num_items = items.len();\n\n        // Offset of the start of the slice in the allocation.\n        let inner_to_data_offset = offset_of!(ArcInner<HeaderSlice<H, [T; 0]>>, data);\n        let data_to_slice_offset = offset_of!(HeaderSlice<H, [T; 0]>, slice);\n        let slice_offset = inner_to_data_offset + data_to_slice_offset;\n\n        // Compute the size of the real payload.\n        let slice_size = mem::size_of::<T>().checked_mul(num_items).expect(\"size overflows\");\n        let usable_size = slice_offset.checked_add(slice_size).expect(\"size overflows\");\n\n        // Round up size to alignment.\n        let align = mem::align_of::<ArcInner<HeaderSlice<H, [T; 0]>>>();\n        let size = usable_size.wrapping_add(align - 1) & !(align - 1);\n        assert!(size >= usable_size, \"size overflows\");\n        let layout = Layout::from_size_align(size, align).expect(\"invalid layout\");\n\n        let ptr: *mut ArcInner<HeaderSlice<H, [T; 0]>>;\n        unsafe {\n            let buffer = alloc::alloc(layout);\n\n            if buffer.is_null() {\n                alloc::handle_alloc_error(layout);\n            }\n\n            // // Synthesize the fat pointer. We do this by claiming we have a direct\n            // // pointer to a [T], and then changing the type of the borrow. The key\n            // // point here is that the length portion of the fat pointer applies\n            // // only to the number of elements in the dynamically-sized portion of\n            // // the type, so the value will be the same whether it points to a [T]\n            // // or something else with a [T] as its last member.\n            // let fake_slice: &mut [T] = slice::from_raw_parts_mut(buffer as *mut T, num_items);\n            // ptr = fake_slice as *mut [T] as *mut ArcInner<HeaderSlice<H, [T]>>;\n            ptr = buffer as *mut _;\n\n            let count = atomic::AtomicUsize::new(1);\n\n            // Write the data.\n            //\n            // Note that any panics here (i.e. from the iterator) are safe, since\n            // we'll just leak the uninitialized memory.\n            ptr::write(ptr::addr_of_mut!((*ptr).count), count);\n            ptr::write(ptr::addr_of_mut!((*ptr).data.header), header);\n            ptr::write(ptr::addr_of_mut!((*ptr).data.length), num_items);\n            if num_items != 0 {\n                let mut current = ptr::addr_of_mut!((*ptr).data.slice) as *mut T;\n                debug_assert_eq!(current as usize - buffer as usize, slice_offset);\n                for _ in 0..num_items {\n                    ptr::write(\n                        current,\n                        items.next().expect(\"ExactSizeIterator over-reported length\"),\n                    );\n                    current = current.offset(1);\n                }\n                assert!(items.next().is_none(), \"ExactSizeIterator under-reported length\");\n\n                // We should have consumed the buffer exactly.\n                debug_assert_eq!(current as *mut u8, buffer.add(usable_size));\n            }\n            assert!(items.next().is_none(), \"ExactSizeIterator under-reported length\");\n        }\n\n        ThinArc { ptr: unsafe { ptr::NonNull::new_unchecked(ptr) }, phantom: PhantomData }\n    }"
}