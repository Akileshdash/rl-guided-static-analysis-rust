{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<keyexpr_tree::iters::intersection::IntersectionMut<'a, Children, Node, Weight> as std::iter::Iterator>::next`",
    "file": "zenoh-keyexpr-1.5.0/src/keyexpr_tree/iters/intersection.rs",
    "start_line": 277,
    "start_col": 5,
    "end_line": 416,
    "end_col": 6,
    "code_snippet": "fn next(&mut self) -> Option<Self::Item> {\n        loop {\n            let StackFrameMut {\n                iterator,\n                start,\n                end,\n                _marker,\n            } = self.iterators.last_mut()?;\n            match iterator.next() {\n                Some(node) => {\n                    let mut node_matches = false;\n                    let new_start = *end;\n                    let mut new_end = *end;\n                    macro_rules! push {\n                        ($index: expr) => {\n                            let index = $index;\n                            if new_end == new_start || self.ke_indices[new_end - 1] < index {\n                                self.ke_indices.push(index);\n                                new_end += 1;\n                            }\n                        };\n                    }\n                    let chunk = node.chunk();\n                    let chunk_is_verbatim = chunk.first_byte() == b'@';\n                    if unlikely(chunk.as_bytes() == b\"**\") {\n                        // If the current node is `**`, it is guaranteed to match...\n                        node_matches = true;\n                        // and may consume any number of chunks from the KE\n                        push!(self.ke_indices[*start]);\n                        if self.key.len() != self.ke_indices[*start] {\n                            if self.key.as_bytes()[self.ke_indices[*start]] != b'@' {\n                                for i in self.ke_indices[*start]..self.key.len() {\n                                    if self.key.as_bytes()[i] == b'/' {\n                                        push!(i + 1);\n                                        if self.key.as_bytes()[i + 1] == b'@' {\n                                            node_matches = false; // ...unless the KE contains a verbatim chunk.\n                                            break;\n                                        }\n                                    }\n                                }\n                            } else {\n                                node_matches = false;\n                            }\n                        }\n                    } else {\n                        // The current node is not `**`\n                        // For all candidate chunks of the KE\n                        for i in *start..*end {\n                            // construct that chunk, while checking whether or not it's the last one\n                            let kec_start = self.ke_indices[i];\n                            if unlikely(kec_start == self.key.len()) {\n                                break;\n                            }\n                            let key = &self.key.as_bytes()[kec_start..];\n                            match key.iter().position(|&c| c == b'/') {\n                                Some(kec_end) => {\n                                    // If we aren't in the last chunk\n                                    let subkey =\n                                        unsafe { keyexpr::from_slice_unchecked(&key[..kec_end]) };\n                                    if unlikely(subkey.as_bytes() == b\"**\") {\n                                        if !chunk_is_verbatim {\n                                            // If the query chunk is `**`:\n                                            // children will have to process it again\n                                            push!(kec_start);\n                                        }\n                                        // and we need to process this chunk as if the `**` wasn't there,\n                                        // but with the knowledge that the next chunk won't be `**`.\n                                        let post_key = &key[kec_end + 1..];\n                                        match post_key.iter().position(|&c| c == b'/') {\n                                            Some(sec_end) => {\n                                                let post_key = unsafe {\n                                                    keyexpr::from_slice_unchecked(\n                                                        &post_key[..sec_end],\n                                                    )\n                                                };\n                                                if post_key.intersects(chunk) {\n                                                    push!(kec_start + kec_end + sec_end + 2);\n                                                }\n                                            }\n                                            None => {\n                                                if unsafe {\n                                                    keyexpr::from_slice_unchecked(post_key)\n                                                }\n                                                .intersects(chunk)\n                                                {\n                                                    push!(self.key.len());\n                                                    node_matches = true;\n                                                }\n                                            }\n                                        }\n                                    } else if chunk.intersects(subkey) {\n                                        push!(kec_start + kec_end + 1);\n                                    }\n                                }\n                                None => {\n                                    // If it's the last chunk of the query, check whether it's `**`\n                                    let key = unsafe { keyexpr::from_slice_unchecked(key) };\n                                    if unlikely(key.as_bytes() == b\"**\") && !chunk_is_verbatim {\n                                        // If yes, it automatically matches, and must be reused from now on for iteration.\n                                        push!(kec_start);\n                                        node_matches = true;\n                                    } else if chunk.intersects(key) {\n                                        // else, if it intersects with the chunk, make sure the children of the node\n                                        // are searched for `**`\n                                        push!(self.key.len());\n                                        node_matches = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if new_end != new_start {\n                        for &i in &self.ke_indices[new_start..new_end] {\n                            if &self.key.as_bytes()[i..] == b\"**\" {\n                                node_matches = true;\n                                break;\n                            }\n                        }\n                        let iterator = unsafe { &mut *(node.as_node_mut() as *mut Node) }\n                            .children_mut()\n                            .children_mut();\n                        self.iterators.push(StackFrameMut {\n                            iterator,\n                            start: new_start,\n                            end: new_end,\n                            _marker: Default::default(),\n                        })\n                    }\n                    if node_matches {\n                        return Some(node);\n                    }\n                }\n                None => {\n                    if let Some(StackFrameMut { start, .. }) = self.iterators.pop() {\n                        self.ke_indices.truncate(start);\n                    }\n                }\n            }\n        }\n    }"
}