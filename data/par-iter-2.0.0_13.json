{
    "level": "Warning",
    "analyzer": "UnsafeDataflow",
    "op_type": "ReadFlow",
    "description": "Potential unsafe dataflow issue in `slice::sort::partition_equal`",
    "file": "par-iter-2.0.0/src/slice/sort.rs",
    "start_line": 686,
    "start_col": 1,
    "end_line": 754,
    "end_col": 2,
    "code_snippet": "fn partition_equal<T, F>(v: &mut [T], pivot: usize, is_less: &F) -> usize\nwhere\n    F: Fn(&T, &T) -> bool,\n{\n    // Place the pivot at the beginning of slice.\n    v.swap(0, pivot);\n    let (pivot, v) = v.split_at_mut(1);\n    let pivot = &mut pivot[0];\n\n    // Read the pivot into a stack-allocated variable for efficiency. If a following\n    // comparison operation panics, the pivot will be automatically written back\n    // into the slice. SAFETY: The pointer here is valid because it is obtained\n    // from a reference to a slice.\n    let tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n    let _pivot_guard = InsertionHole {\n        src: &*tmp,\n        dest: pivot,\n    };\n    let pivot = &*tmp;\n\n    let len = v.len();\n    if len == 0 {\n        return 0;\n    }\n\n    // Now partition the slice.\n    let mut l = 0;\n    let mut r = len;\n    loop {\n        // SAFETY: The unsafety below involves indexing an array.\n        // For the first one: We already do the bounds checking here with `l < r`.\n        // For the second one: We initially have `l == 0` and `r == v.len()` and we\n        // checked that `l < r` at every indexing operation.\n        // From here we know that `r` must be at least `r == l` which was shown to be\n        // valid from the first one.\n        unsafe {\n            // Find the first element greater than the pivot.\n            while l < r && !is_less(pivot, v.get_unchecked(l)) {\n                l += 1;\n            }\n\n            // Find the last element equal to the pivot.\n            loop {\n                r -= 1;\n                if l >= r || !is_less(pivot, v.get_unchecked(r)) {\n                    break;\n                }\n            }\n\n            // Are we done?\n            if l >= r {\n                break;\n            }\n\n            // Swap the found pair of out-of-order elements.\n            let ptr = v.as_mut_ptr();\n            ptr::swap(ptr.add(l), ptr.add(r));\n            l += 1;\n        }\n    }\n\n    // We found `l` elements equal to the pivot. Add 1 to account for the pivot\n    // itself.\n    l + 1\n\n    // `_pivot_guard` goes out of scope and writes the pivot (which is a\n    // stack-allocated variable) back into the slice where it originally\n    // was. This step is critical in ensuring safety!\n}"
}