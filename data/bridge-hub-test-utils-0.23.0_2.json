{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `test_cases::helpers::for_pallet_xcm_bridge_hub::close_bridge`",
    "file": "bridge-hub-test-utils-0.23.0/src/test_cases/helpers.rs",
    "start_line": 521,
    "start_col": 2,
    "end_line": 594,
    "end_col": 3,
    "code_snippet": "pub fn close_bridge<Runtime, XcmOverBridgePalletInstance, LocationToAccountId, TokenLocation>(\n\t\texpected_source: Location,\n\t\tbridge_destination_universal_location: InteriorLocation,\n\t\t(origin, origin_kind): (Location, OriginKind),\n\t\tis_paid_xcm_execution: bool\n\t) where\n\t\tRuntime: BasicParachainRuntime + BridgeXcmOverBridgeConfig<XcmOverBridgePalletInstance>,\n\t\tXcmOverBridgePalletInstance: 'static,\n\t\t<Runtime as frame_system::Config>::RuntimeCall: GetDispatchInfo + From<BridgeXcmOverBridgeCall<Runtime, XcmOverBridgePalletInstance>>,\n\t\t<Runtime as pallet_balances::Config>::Balance: From<<<Runtime as pallet_bridge_messages::Config<<Runtime as pallet_xcm_bridge_hub::Config<XcmOverBridgePalletInstance>>::BridgeMessagesPalletInstance>>::ThisChain as bp_runtime::Chain>::Balance>,\n\t\t<Runtime as pallet_balances::Config>::Balance: From<u128>,\n\t\tLocationToAccountId: ConvertLocation<AccountIdOf<Runtime>>,\n\t\tTokenLocation: Get<Location>\n\t{\n\t\t// construct expected bridge configuration\n\t\tlet locations =\n\t\t\tpallet_xcm_bridge_hub::Pallet::<Runtime, XcmOverBridgePalletInstance>::bridge_locations(\n\t\t\t\texpected_source.clone().into(),\n\t\t\t\tbridge_destination_universal_location.clone().into(),\n\t\t\t)\n\t\t\t\t.expect(\"valid bridge locations\");\n\t\tassert!(pallet_xcm_bridge_hub::Bridges::<Runtime, XcmOverBridgePalletInstance>::get(\n\t\t\tlocations.bridge_id()\n\t\t)\n\t\t.is_some());\n\n\t\t// required balance: ED + fee + BridgeDeposit\n\t\tlet maybe_paid_execution = if is_paid_xcm_execution {\n\t\t\t// random high enough value for `BuyExecution` fees\n\t\t\tlet buy_execution_fee_amount = 2_500_000_000_000_u128;\n\t\t\tlet buy_execution_fee = (TokenLocation::get(), buy_execution_fee_amount).into();\n\n\t\t\tlet balance_needed = <Runtime as pallet_balances::Config>::ExistentialDeposit::get() +\n\t\t\t\tbuy_execution_fee_amount.into();\n\t\t\tlet source_account_id =\n\t\t\t\tLocationToAccountId::convert_location(&expected_source).expect(\"valid location\");\n\t\t\tlet _ =\n\t\t\t\t<pallet_balances::Pallet<Runtime>>::mint_into(&source_account_id, balance_needed)\n\t\t\t\t\t.expect(\"mint_into passes\");\n\t\t\tSome(buy_execution_fee)\n\t\t} else {\n\t\t\tNone\n\t\t};\n\n\t\t// close bridge with `Transact` call\n\t\tlet close_bridge_call = RuntimeCallOf::<Runtime>::from(BridgeXcmOverBridgeCall::<\n\t\t\tRuntime,\n\t\t\tXcmOverBridgePalletInstance,\n\t\t>::close_bridge {\n\t\t\tbridge_destination_universal_location: Box::new(\n\t\t\t\tbridge_destination_universal_location.into(),\n\t\t\t),\n\t\t\tmay_prune_messages: 16,\n\t\t});\n\n\t\t// execute XCM as source origin would do with `Transact -> Origin::Xcm`\n\t\tassert_ok!(RuntimeHelper::<Runtime>::execute_as_origin(\n\t\t\t(origin, origin_kind),\n\t\t\tclose_bridge_call,\n\t\t\tmaybe_paid_execution\n\t\t)\n\t\t.ensure_complete());\n\n\t\t// bridge is closed\n\t\tassert!(pallet_xcm_bridge_hub::Bridges::<Runtime, XcmOverBridgePalletInstance>::get(\n\t\t\tlocations.bridge_id()\n\t\t)\n\t\t.is_none());\n\n\t\t// check state\n\t\tassert_ok!(\n\t\t\tpallet_xcm_bridge_hub::Pallet::<Runtime, XcmOverBridgePalletInstance>::do_try_state()\n\t\t);\n\t}"
}