{
    "level": "Warning",
    "analyzer": "UnsafeDestructor",
    "op_type": null,
    "description": "unsafe block detected in drop",
    "file": "circular-buffer-1.1.0/src/drain.rs",
    "start_line": 210,
    "start_col": 1,
    "end_line": 210,
    "end_col": 49,
    "code_snippet": "impl<const N: usize, T> Drop for Drain<'_, N, T> {\n    fn drop(&mut self) {\n        // Drop the items that were not consumed\n        struct Dropper<'a, T>(&'a mut [T]);\n\n        impl<T> Drop for Dropper<'_, T> {\n            fn drop(&mut self) {\n                // SAFETY: the slice is guaranteed to be valid for read and writes as the `Drain`\n                // holds a mutable reference to the `CircularBuffer` that contains the data\n                // referenced by the slices.\n                unsafe {\n                    ptr::drop_in_place(self.0);\n                }\n            }\n        }\n\n        let (right, left) = self.as_mut_slices();\n\n        let right = Dropper(right);\n        let left = Dropper(left);\n\n        drop(right);\n        drop(left);\n\n        // The drain has left a \"hole\" of items in the `CircularBuffer` that either got moved out\n        // during iteration, or got dropped earlier. There are 3 possible scenarios for the state\n        // of the `CircularBuffer` at this point:\n        //\n        // 1. The \"hole\" is at the front of the buffer:\n        //    | hole | remaining items |\n        //\n        // 2. The \"hole\" is at the back of the buffer:\n        //    | remaining items | hole |\n        //\n        // 3. The \"hole\" is in the middle of the buffer:\n        //    | remaining items | hole | remaining items |\n        //\n        // Scenario #1 and #2 can be handled by adjusting the start offset and length of the\n        // buffer. Scenario #3 requires moving the remaining items into the \"hole\" to fill the gap.\n        //\n        // Filling the hole for scenario #3 requires at most a 3-steps. The worst case looks like\n        // this:\n        //\n        //     | back items [part 2/2] | front items | hole | back items [part 1/2] |\n        //                             ^\n        //                             ` start\n        //\n        // The first step to do is to move `back items [part 1/2]` into `hole`, so that the\n        // `CircularBuffer` looks like this:\n        //\n        //     | back items [part 2/2] | front items | back items [part 1/2] | hole |\n        //                             ^\n        //                             ` start\n        //\n        // Then a portion of `back items [part 2/2]` can be copied into the new `hole`. Note that\n        // `back items [part 2/2]` may not fit into `hole`, and so it may be necessary to split it\n        // in two chunks:\n        //\n        //     | hole | back items [part 3/3] | front items | back items [part 1/3] | back items [part 2/3] |\n        //                                    ^\n        //                                    ` start\n        //\n        // Finally the last chunk `back items [part 3/3]` can be moved into that `hole`:\n        //\n        //     | back items [part 3/3] | hole | front items | back items [part 1/3] | back items [part 2/3] |\n        //                                    ^\n        //                                    ` start\n        //\n        // A similar strategy could be applied to move the front items into the hole instead of the\n        // back items. Ideally the implementation should decide whether to move the front items or\n        // the back items depending on which one results in fewer data to be moved; however for now\n        // only the implementation always moves the back items.\n\n        // TODO: optimize for the case where the hole is in the front or the back\n        // TODO: optimize for the case where there are fewer items to move from the front\n\n        // SAFETY: `buf` is a valid pointer because `Drain` holds a mutable reference to it.\n        let buf = unsafe { self.buf.as_mut() };\n        let mut remaining = self.buf_size - self.range.end;\n\n        let items = CircularSlicePtr::new(&mut buf.items).add(buf.start);\n        let mut hole = items.add(self.range.start);\n        let mut backfill = items.add(self.range.end);\n\n        // This loop should run at most 3 times as explained above\n        while remaining > 0 {\n            let copy_len = hole\n                .available_len()\n                .min(backfill.available_len())\n                .min(remaining);\n            // SAFETY: both pointers are properly aligned, and are valid for read and writes.\n            unsafe { ptr::copy(backfill.as_ptr(), hole.as_mut_ptr(), copy_len) };\n\n            hole = hole.add(copy_len);\n            backfill = backfill.add(copy_len);\n            remaining -= copy_len;\n        }\n\n        // Now that the buffer memory contains valid items, the size can be restored\n        buf.size = self.buf_size - self.range.len();\n    }\n}"
}