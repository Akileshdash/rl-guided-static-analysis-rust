{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "SliceFromRaw",
    "description": "Potential unsafe dataflow issue in `base::edition::<impl base::matrix::Matrix<T, R, C, S>>::remove_columns_generic`",
    "file": "nalgebra-0.34.0/src/base/edition.rs",
    "start_line": 490,
    "start_col": 5,
    "end_line": 542,
    "end_col": 6,
    "code_snippet": "pub fn remove_columns_generic<D>(self, i: usize, nremove: D) -> OMatrix<T, R, DimDiff<C, D>>\n    where\n        D: Dim,\n        C: DimSub<D>,\n        DefaultAllocator: Reallocator<T, R, C, R, DimDiff<C, D>>,\n    {\n        let mut m = self.into_owned();\n        let (nrows, ncols) = m.shape_generic();\n        assert!(\n            i + nremove.value() <= ncols.value(),\n            \"Column index out of range.\"\n        );\n\n        let need_column_shifts = nremove.value() != 0 && i + nremove.value() < ncols.value();\n        if need_column_shifts {\n            // The first `deleted_i * nrows` are left untouched.\n            let copied_value_start = i + nremove.value();\n\n            unsafe {\n                let ptr_in = m.data.ptr().add(copied_value_start * nrows.value());\n                let ptr_out = m.data.ptr_mut().add(i * nrows.value());\n\n                // Drop all the elements of the columns we are about to overwrite.\n                // We use the a similar technique as in `Vec::truncate`.\n                let s = ptr::slice_from_raw_parts_mut(ptr_out, nremove.value() * nrows.value());\n                // Safety: we drop the column in-place, which is OK because we will overwrite these\n                //         entries with `ptr::copy` afterward.\n                ptr::drop_in_place(s);\n\n                ptr::copy(\n                    ptr_in,\n                    ptr_out,\n                    (ncols.value() - copied_value_start) * nrows.value(),\n                );\n            }\n        } else {\n            // All the columns to remove are at the end of the buffer. Drop them.\n            unsafe {\n                let ptr = m.data.ptr_mut().add(i * nrows.value());\n                let s = ptr::slice_from_raw_parts_mut(ptr, nremove.value() * nrows.value());\n                ptr::drop_in_place(s)\n            };\n        }\n\n        // Safety: The new size is smaller than the old size, so\n        //         DefaultAllocator::reallocate_copy will initialize\n        //         every element of the new matrix which can then\n        //         be assumed to be initialized.\n        unsafe {\n            let new_data = DefaultAllocator::reallocate_copy(nrows, ncols.sub(nremove), m.data);\n            Matrix::from_data(new_data).assume_init()\n        }\n    }"
}