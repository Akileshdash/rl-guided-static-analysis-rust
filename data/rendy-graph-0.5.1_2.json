{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<node::render::pass::RenderPassNodeBuilder<B, T> as node::NodeBuilder<B, T>>::build`",
    "file": "rendy-graph-0.5.1/src/node/render/pass.rs",
    "start_line": 391,
    "start_col": 5,
    "end_line": 942,
    "end_col": 6,
    "code_snippet": "fn build<'a>(\n        self: Box<Self>,\n        ctx: &GraphContext<B>,\n        factory: &mut Factory<B>,\n        family: &mut Family<B>,\n        queue: usize,\n        aux: &T,\n        buffers: Vec<NodeBuffer>,\n        images: Vec<NodeImage>,\n    ) -> Result<Box<dyn DynNode<B, T>>, NodeBuildError> {\n        use rendy_core::hal::window::PresentMode;\n\n        let mut surface_color_usage = false;\n        let mut surface_depth_usage = false;\n\n        let (mut surface, suggested_extent, surface_clear) = self\n            .surface\n            .map_or((None, None, None), |(s, e, c)| (Some(s), Some(e), c));\n        log::debug!(\n            \"Build render pass node {} surface\",\n            surface.as_ref().map_or(\"without\", |_| \"with\")\n        );\n\n        let mut attachments: Vec<Attachment> = self\n            .subpasses\n            .iter()\n            .flat_map(|subpass| {\n                subpass\n                    .inputs\n                    .iter()\n                    .chain(subpass.colors.iter().inspect(|a| {\n                        surface_color_usage = surface_color_usage || a.is_right();\n                    }))\n                    .chain(subpass.depth_stencil.as_ref().into_iter().inspect(|a| {\n                        surface_depth_usage = surface_depth_usage || a.is_right();\n                    }))\n                    .cloned()\n                    .collect::<Vec<_>>()\n            })\n            .collect();\n\n        let mut surface_usage = rendy_core::hal::image::Usage::empty();\n        if surface_color_usage {\n            surface_usage |= rendy_core::hal::image::Usage::COLOR_ATTACHMENT;\n        }\n        if surface_depth_usage {\n            surface_usage |= rendy_core::hal::image::Usage::DEPTH_STENCIL_ATTACHMENT;\n        }\n\n        if surface.is_some() {\n            log::debug!(\"Surface usage {:#?}\", surface_usage);\n        } else {\n            debug_assert_eq!(surface_usage, rendy_core::hal::image::Usage::empty());\n        }\n\n        attachments.sort();\n        attachments.dedup();\n\n        let find_attachment_node_image = |id: ImageId| -> &NodeImage {\n            images\n                .iter()\n                .find(|a| a.id == id)\n                .expect(\"Attachment image wasn't provided\")\n        };\n\n        let mut framebuffer_width = u32::max_value();\n        let mut framebuffer_height = u32::max_value();\n        let mut framebuffer_layers = u16::max_value();\n\n        let mut node_target = None;\n\n        log::trace!(\"Configure attachments\");\n\n        let views: Vec<_> = attachments\n            .iter()\n            .map(|&attachment| -> Result<Vec<_>, NodeBuildError> {\n                match attachment {\n                    Either::Left(image_id) => {\n                        log::debug!(\"Image {:?} attachment\", image_id);\n\n                        let node_image = find_attachment_node_image(image_id);\n                        let image = ctx.get_image(image_id).expect(\"Image does not exist\");\n                        let extent = image.kind().extent();\n                        framebuffer_width = min(framebuffer_width, extent.width);\n                        framebuffer_height = min(framebuffer_height, extent.height);\n                        framebuffer_layers = min(\n                            framebuffer_layers,\n                            node_image.range.layers.end - node_image.range.layers.start,\n                        );\n                        Ok(vec![unsafe {\n                            factory\n                                .device()\n                                .create_image_view(\n                                    image.raw(),\n                                    rendy_core::hal::image::ViewKind::D2,\n                                    image.format(),\n                                    rendy_core::hal::format::Swizzle::NO,\n                                    rendy_core::hal::image::SubresourceRange {\n                                        // NOTE: Framebuffer must always be created with only one mip level. If image contains multiple levels,\n                                        // only the first one is bound as an attachment.\n                                        // TODO: Allow customizing this behaviour to choose which level to bind.\n                                        levels: 0 .. 1,\n                                        ..node_image.range.clone()\n                                    }\n                                )\n                                .map_err(NodeBuildError::View)?\n                            }])\n                    },\n                    Either::Right(RenderPassSurface) => {\n                        log::trace!(\"Surface attachment\");\n\n                        let surface = surface.take().expect(\"Render pass should be configured with Surface instance if at least one subpass uses surface attachment\");\n                        let surface_extent = unsafe {\n                            surface.extent(factory.physical()).unwrap_or(suggested_extent.expect(\"Must be set with surface\"))\n                        };\n\n                        log::debug!(\"Surface extent {:#?}\", surface_extent);\n\n                        if !factory.surface_support(family.id(), &surface) {\n                            log::warn!(\"Surface {:?} presentation is unsupported by family {:?} bound to the node\", surface, family);\n                            return Err(NodeBuildError::QueueFamily(family.id()));\n                        }\n\n                        let caps = factory.get_surface_capabilities(&surface);\n\n                        let present_mode = match () {\n                            _ if caps.present_modes.contains(PresentMode::FIFO) => PresentMode::FIFO,\n                            _ if caps.present_modes.contains(PresentMode::MAILBOX) => PresentMode::MAILBOX,\n                            _ if caps.present_modes.contains(PresentMode::RELAXED) => PresentMode::RELAXED,\n                            _ if caps.present_modes.contains(PresentMode::IMMEDIATE) => PresentMode::IMMEDIATE,\n                            _ => panic!(\"No known present modes found\"),\n                        };\n\n                        let img_count_caps = caps.image_count;\n                        let image_count = 3.min(*img_count_caps.end()).max(*img_count_caps.start());\n\n                        let target = factory\n                            .create_target(\n                                surface,\n                                surface_extent,\n                                image_count,\n                                present_mode,\n                                surface_usage,\n                            )\n                            .map_err(NodeBuildError::Swapchain)?;\n\n                        framebuffer_width = min(framebuffer_width, target.extent().width);\n                        framebuffer_height = min(framebuffer_height, target.extent().height);\n                        framebuffer_layers = min(\n                            framebuffer_layers,\n                            target.backbuffer()[0].layers(),\n                        );\n\n                        let views = target.backbuffer().iter().map(|image| unsafe {\n                            factory\n                                .device()\n                                .create_image_view(\n                                    image.raw(),\n                                    rendy_core::hal::image::ViewKind::D2,\n                                    image.format(),\n                                    rendy_core::hal::format::Swizzle::NO,\n                                    rendy_core::hal::image::SubresourceRange {\n                                        aspects: image.format().surface_desc().aspects,\n                                        levels: 0 .. 1,\n                                        layers: 0 .. 1,\n                                    },\n                                )\n                                .map_err(NodeBuildError::View)\n                        }).collect::<Result<Vec<_>, NodeBuildError>>()?;\n\n                        node_target = Some(target);\n                        Ok(views)\n                    }\n                }\n            }).collect::<Result<Vec<_>, _>>()?\n            .into_iter().flatten().collect();\n\n        log::trace!(\"Configure render pass instance\");\n\n        let render_pass: B::RenderPass = {\n            let pass_attachments: Vec<_> = attachments\n                .iter()\n                .map(|&attachment| {\n                    let (format, clear, layout, samples) = match attachment {\n                        Either::Left(image_id) => {\n                            let node_image = find_attachment_node_image(image_id);\n                            let image = ctx.get_image(image_id).expect(\"Image does not exist\");\n                            (\n                                image.format(),\n                                node_image.clear,\n                                node_image.layout,\n                                image.kind().num_samples(),\n                            )\n                        }\n                        Either::Right(RenderPassSurface) => (\n                            node_target\n                                .as_ref()\n                                .expect(\"Expect target created\")\n                                .backbuffer()[0]\n                                .format(),\n                            surface_clear,\n                            rendy_core::hal::image::Layout::Present,\n                            1,\n                        ),\n                    };\n\n                    rendy_core::hal::pass::Attachment {\n                        format: Some(format),\n                        ops: rendy_core::hal::pass::AttachmentOps {\n                            load: if clear.is_some() {\n                                rendy_core::hal::pass::AttachmentLoadOp::Clear\n                            } else {\n                                rendy_core::hal::pass::AttachmentLoadOp::Load\n                            },\n                            store: rendy_core::hal::pass::AttachmentStoreOp::Store,\n                        },\n                        stencil_ops: rendy_core::hal::pass::AttachmentOps::DONT_CARE,\n                        layouts: if clear.is_some() {\n                            rendy_core::hal::image::Layout::Undefined..layout\n                        } else {\n                            layout..layout\n                        },\n                        samples,\n                    }\n                })\n                .collect();\n\n            log::debug!(\"Attachments {:#?}\", pass_attachments);\n\n            #[derive(Debug)]\n            struct OwningSubpassDesc {\n                inputs: Vec<(usize, Layout)>,\n                colors: Vec<(usize, Layout)>,\n                depth_stencil: Option<(usize, Layout)>,\n            }\n\n            let subpasses: Vec<_> = self\n                .subpasses\n                .iter()\n                .map(|subpass| OwningSubpassDesc {\n                    inputs: subpass\n                        .inputs\n                        .iter()\n                        .map(|&i| {\n                            (\n                                attachments.iter().position(|&a| a == i).unwrap(),\n                                match i {\n                                    Either::Left(image_id) => {\n                                        find_attachment_node_image(image_id).layout\n                                    }\n                                    Either::Right(RenderPassSurface) => {\n                                        rendy_core::hal::image::Layout::ShaderReadOnlyOptimal\n                                    }\n                                },\n                            )\n                        })\n                        .collect(),\n                    colors: subpass\n                        .colors\n                        .iter()\n                        .map(|&c| {\n                            (\n                                attachments.iter().position(|&a| a == c).unwrap(),\n                                match c {\n                                    Either::Left(image_id) => {\n                                        find_attachment_node_image(image_id).layout\n                                    }\n                                    Either::Right(RenderPassSurface) => {\n                                        rendy_core::hal::image::Layout::ColorAttachmentOptimal\n                                    }\n                                },\n                            )\n                        })\n                        .collect(),\n                    depth_stencil: subpass.depth_stencil.map(|ds| {\n                        (\n                            attachments.iter().position(|&a| a == ds).unwrap(),\n                            match ds {\n                                Either::Left(image_id) => {\n                                    find_attachment_node_image(image_id).layout\n                                }\n                                Either::Right(RenderPassSurface) => {\n                                    rendy_core::hal::image::Layout::DepthStencilAttachmentOptimal\n                                }\n                            },\n                        )\n                    }),\n                })\n                .collect();\n\n            log::debug!(\"Subpasses {:#?}\", subpasses);\n\n            let subpasses: Vec<_> = subpasses\n                .iter()\n                .map(|subpass| rendy_core::hal::pass::SubpassDesc {\n                    inputs: &subpass.inputs[..],\n                    colors: &subpass.colors[..],\n                    depth_stencil: subpass.depth_stencil.as_ref(),\n                    resolves: &[],\n                    preserves: &[],\n                })\n                .collect();\n\n            let result = unsafe {\n                factory\n                    .device()\n                    .create_render_pass(pass_attachments, subpasses, {\n                        assert_eq!(\n                            self.subpasses.len(),\n                            1,\n                            \"TODO: Implement subpass dependencies to allow more than one subpass\"\n                        );\n                        std::iter::empty::<rendy_core::hal::pass::SubpassDependency>()\n                    })\n            }\n            .unwrap();\n\n            log::trace!(\"RenderPass instance created\");\n            result\n        };\n\n        log::trace!(\n            \"Create {} framebuffers\",\n            views.len() - attachments.len() + 1\n        );\n\n        // Swapchain image views, if any, are last ones.\n        let mut framebuffers = (attachments.len() - 1..views.len())\n            .map(|i| unsafe {\n                log::trace!(\n                    \"Create framebuffer for views {}..{} and {}\",\n                    0,\n                    attachments.len() - 1,\n                    i,\n                );\n                factory\n                    .device()\n                    .create_framebuffer(\n                        &render_pass,\n                        views[..attachments.len() - 1].iter().chain(Some(&views[i])),\n                        rendy_core::hal::image::Extent {\n                            width: framebuffer_width,\n                            height: framebuffer_height,\n                            depth: framebuffer_layers as u32, // This is gfx-hal BUG as this parameter actually means framebuffer layers number,\n                        },\n                    )\n                    .map_err(NodeBuildError::OutOfMemory)\n            })\n            .collect::<Result<Vec<_>, _>>()?;\n\n        log::trace!(\"Collect clears for render pass\");\n\n        let clears: Vec<_> = attachments\n            .iter()\n            .filter_map(|&a| match a {\n                Either::Left(image_id) => find_attachment_node_image(image_id).clear,\n                Either::Right(RenderPassSurface) => surface_clear,\n            })\n            .map(Into::into)\n            .collect();\n\n        let mut command_pool = factory\n            .create_command_pool(family)\n            .map_err(NodeBuildError::OutOfMemory)?\n            .with_capability()\n            .expect(\"Graph must specify family that supports `Graphics`\");\n\n        let command_cirque = CommandCirque::new();\n\n        let acquire = if uses_pipeline_barriers::<B>(factory.device()) {\n            let (stages, barriers) = gfx_acquire_barriers(ctx, &buffers, &images);\n\n            if !barriers.is_empty() {\n                let initial = command_pool.allocate_buffers(1).pop().unwrap();\n                let mut recording = initial.begin(MultiShot(SimultaneousUse), ());\n                log::debug!(\"Acquire {:?} : {:#?}\", stages, barriers);\n                unsafe {\n                    recording.encoder().pipeline_barrier(\n                        stages,\n                        rendy_core::hal::memory::Dependencies::empty(),\n                        barriers,\n                    );\n                }\n                let (acquire_submit, acquire_buffer) = recording.finish().submit();\n                Some(BarriersCommands {\n                    buffer: acquire_buffer,\n                    submit: acquire_submit,\n                })\n            } else {\n                None\n            }\n        } else {\n            None\n        };\n\n        let release = if uses_pipeline_barriers::<B>(factory.device()) {\n            let (stages, barriers) = gfx_release_barriers(ctx, &buffers, &images);\n\n            if !barriers.is_empty() {\n                let initial = command_pool.allocate_buffers(1).pop().unwrap();\n                let mut recording = initial.begin(MultiShot(SimultaneousUse), ());\n                log::debug!(\"Release {:?} : {:#?}\", stages, barriers);\n                unsafe {\n                    recording.encoder().pipeline_barrier(\n                        stages,\n                        rendy_core::hal::memory::Dependencies::empty(),\n                        barriers,\n                    );\n                }\n                let (release_submit, release_buffer) = recording.finish().submit();\n                Some(BarriersCommands {\n                    buffer: release_buffer,\n                    submit: release_submit,\n                })\n            } else {\n                None\n            }\n        } else {\n            None\n        };\n\n        let subpasses = self\n            .subpasses\n            .into_iter()\n            .enumerate()\n            .map(|(index, subpass)| {\n                let subpass_colors = subpass.colors.len();\n                let subpass_depth = subpass.depth_stencil.is_some();\n\n                subpass\n                    .groups\n                    .into_iter()\n                    .map(|group| {\n                        assert_eq!(group.colors(), subpass_colors);\n                        assert_eq!(group.depth(), subpass_depth);\n\n                        let buffers: Vec<_> = group\n                            .buffers()\n                            .into_iter()\n                            .map(|(id, _)| {\n                                buffers\n                                    .iter()\n                                    .find(|b| b.id == id)\n                                    .expect(\"Transient buffer wasn't provided\")\n                                    .clone()\n                            })\n                            .collect();\n                        let images: Vec<_> = group\n                            .images()\n                            .into_iter()\n                            .map(|(id, _)| {\n                                images\n                                    .iter()\n                                    .find(|i| i.id == id)\n                                    .expect(\"Transient image wasn't provided\")\n                                    .clone()\n                            })\n                            .collect();\n\n                        group.build(\n                            ctx,\n                            factory,\n                            QueueId {\n                                family: family.id(),\n                                index: queue,\n                            },\n                            aux,\n                            framebuffer_width,\n                            framebuffer_height,\n                            rendy_core::hal::pass::Subpass {\n                                index,\n                                main_pass: &render_pass,\n                            },\n                            buffers,\n                            images,\n                        )\n                    })\n                    .collect::<Result<Vec<_>, _>>()\n                    .map(|groups| SubpassNode { groups })\n            })\n            .collect::<Result<Vec<_>, _>>()\n            .map_err(NodeBuildError::Pipeline)?;\n\n        let node: Box<dyn DynNode<B, T>> = match node_target {\n            Some(target) => {\n                log::debug!(\"Construct RenderPassNodeWithSurface\");\n                Box::new(RenderPassNodeWithSurface {\n                    common: RenderPassNodeCommon {\n                        subpasses,\n\n                        framebuffer_width,\n                        framebuffer_height,\n                        _framebuffer_layers: framebuffer_layers,\n\n                        render_pass,\n                        views,\n                        clears,\n\n                        command_pool,\n                        command_cirque,\n\n                        acquire,\n                        release,\n\n                        relevant: relevant::Relevant,\n                    },\n\n                    per_image: framebuffers\n                        .into_iter()\n                        .map(|fb| PerImage {\n                            framebuffer: fb,\n                            acquire: factory.create_semaphore().unwrap(),\n                            release: factory.create_semaphore().unwrap(),\n                            index: 0,\n                        })\n                        .collect(),\n                    free_acquire: factory.create_semaphore().unwrap(),\n                    target,\n                })\n            }\n            None => {\n                log::debug!(\"Construct RenderPassNodeWithoutSurface\");\n                Box::new(RenderPassNodeWithoutSurface {\n                    common: RenderPassNodeCommon {\n                        subpasses,\n\n                        framebuffer_width,\n                        framebuffer_height,\n                        _framebuffer_layers: framebuffer_layers,\n\n                        render_pass,\n                        views,\n                        clears,\n\n                        command_pool,\n                        command_cirque,\n\n                        acquire,\n                        release,\n\n                        relevant: relevant::Relevant,\n                    },\n                    framebuffer: {\n                        assert_eq!(framebuffers.len(), 1);\n                        framebuffers.remove(0)\n                    },\n                })\n            }\n        };\n\n        Ok(node)\n    }"
}