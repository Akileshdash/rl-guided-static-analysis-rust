{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `debt::helping::Slots::help`",
    "file": "arc-swap-1.7.1/src/debt/helping.rs",
    "start_line": 215,
    "start_col": 5,
    "end_line": 302,
    "end_col": 6,
    "code_snippet": "pub(super) fn help<R, T>(&self, who: &Self, storage_addr: usize, replacement: &R)\n    where\n        T: RefCnt,\n        R: Fn() -> T,\n    {\n        debug_assert_eq!(IDLE, self.control.load(Relaxed));\n        // Also acquires the auxiliary data in other variables.\n        let mut control = who.control.load(SeqCst);\n        loop {\n            match control & TAG_MASK {\n                // Nothing to help with\n                IDLE if control == IDLE => break,\n                // Someone has already helped out with that, so we have nothing to do here\n                REPLACEMENT_TAG => break,\n                // Something is going on, let's have a better look.\n                GEN_TAG => {\n                    debug_assert!(\n                        !ptr::eq(self, who),\n                        \"Refusing to help myself, makes no sense\"\n                    );\n                    // Get the address that other thread is trying to load from. By that acquire,\n                    // we also sync the control into our thread once more and reconfirm that the\n                    // value of the active_addr is in between two same instances, therefore up to\n                    // date to it.\n                    let active_addr = who.active_addr.load(SeqCst);\n                    if active_addr != storage_addr {\n                        // Acquire for the same reason as on the top.\n                        let new_control = who.control.load(SeqCst);\n                        if new_control == control {\n                            // The other thread is doing something, but to some other ArcSwap, so\n                            // we don't care. Cool, done.\n                            break;\n                        } else {\n                            // The control just changed under our hands, we don't know what to\n                            // trust, so retry.\n                            control = new_control;\n                            continue;\n                        }\n                    }\n\n                    // Now we know this work is for us. Try to create a replacement and offer it.\n                    // This actually does a full-featured load under the hood, but we are currently\n                    // idle and the load doesn't re-enter write, so that's all fine.\n                    let replacement = replacement();\n                    let replace_addr = T::as_ptr(&replacement) as usize;\n                    // If we succeed in helping the other thread, we take their empty space in\n                    // return for us that we pass to them. It's already there, the value is synced\n                    // to us by Acquire on control.\n                    let their_space = who.space_offer.load(SeqCst);\n                    // Relaxed is fine, our own thread and nobody but us writes in here.\n                    let my_space = self.space_offer.load(SeqCst);\n                    // Relaxed is fine, we'll sync by the next compare-exchange. If we don't, the\n                    // value won't ever be read anyway.\n                    unsafe {\n                        (*my_space).0.store(replace_addr, SeqCst);\n                    }\n                    // Ensured by the align annotation at the type.\n                    assert_eq!(my_space as usize & TAG_MASK, 0);\n                    let space_addr = (my_space as usize) | REPLACEMENT_TAG;\n                    // Acquire on failure -> same reason as at the top, reading the value.\n                    // Release on success -> we send data to that thread through here. Must be\n                    // AcqRel, because success must be superset of failure. Also, load to get their\n                    // space (it won't have changed, it does when the control is set to IDLE).\n                    match who\n                        .control\n                        .compare_exchange(control, space_addr, SeqCst, SeqCst)\n                    {\n                        Ok(_) => {\n                            // We have successfully sent our replacement out (Release) and got\n                            // their space in return (Acquire on that load above).\n                            self.space_offer.store(their_space, SeqCst);\n                            // The ref count went with it, so forget about it here.\n                            T::into_ptr(replacement);\n                            // We have successfully helped out, so we are done.\n                            break;\n                        }\n                        Err(new_control) => {\n                            // Something has changed in between. Let's try again, nothing changed\n                            // (the replacement will get dropped at the end of scope, we didn't do\n                            // anything with the spaces, etc.\n                            control = new_control;\n                        }\n                    }\n                }\n                _ => unreachable!(\"Invalid control value {:X}\", control),\n            }\n        }\n    }"
}