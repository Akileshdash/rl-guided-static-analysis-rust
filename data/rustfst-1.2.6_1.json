{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `algorithms::rm_epsilon::rm_epsilon_state::RmEpsilonState::<W, Q>::expand`",
    "file": "rustfst-1.2.6/src/algorithms/rm_epsilon/rm_epsilon_state.rs",
    "start_line": 42,
    "start_col": 5,
    "end_line": 119,
    "end_col": 6,
    "code_snippet": "pub fn expand<F: ExpandedFst<W>, B: Borrow<F>>(\n        &mut self,\n        source: StateId,\n        fst: B,\n    ) -> Result<(Vec<Tr<W>>, W)> {\n        let distance = self\n            .sd_state\n            .shortest_distance::<F, _>(Some(source), fst.borrow())?;\n\n        let tr_filter = EpsilonTrFilter {};\n\n        let mut eps_queue = vec![source];\n\n        let mut trs = vec![];\n        let mut final_weight = W::zero();\n        while let Some(state) = eps_queue.pop() {\n            while self.visited.len() <= (state as usize) {\n                self.visited.push(false);\n            }\n            if self.visited[state as usize] {\n                continue;\n            }\n            self.visited[state as usize] = true;\n            self.visited_states.push(state);\n            for tr in fst.borrow().get_trs(state)?.trs() {\n                // TODO: Remove this clone\n                let mut tr = tr.clone();\n                tr.weight = distance[state as usize].times(&tr.weight)?;\n                if tr_filter.keep(&tr) {\n                    while self.visited.len() <= (tr.nextstate as usize) {\n                        self.visited.push(false);\n                    }\n                    if !self.visited[tr.nextstate as usize] {\n                        eps_queue.push(tr.nextstate);\n                    }\n                } else {\n                    let elt = Element {\n                        ilabel: tr.ilabel,\n                        olabel: tr.olabel,\n                        nextstate: tr.nextstate,\n                    };\n                    let val = (self.expand_id, trs.len());\n\n                    match self.element_map.entry(elt) {\n                        Entry::Vacant(e) => {\n                            e.insert(val);\n                            trs.push(tr);\n                        }\n                        Entry::Occupied(mut e) => {\n                            if e.get().0 == self.expand_id {\n                                unsafe {\n                                    trs.get_unchecked_mut(e.get().1)\n                                        .weight\n                                        .plus_assign(&tr.weight)?;\n                                }\n                            } else {\n                                e.get_mut().0 = self.expand_id;\n                                e.get_mut().1 = trs.len();\n                                trs.push(tr);\n                            }\n                        }\n                    };\n                }\n            }\n            final_weight.plus_assign(\n                distance[state as usize]\n                    .times(fst.borrow().final_weight(state)?.unwrap_or_else(W::zero))?,\n            )?;\n        }\n\n        while let Some(s) = self.visited_states.pop() {\n            self.visited[s as usize] = false;\n        }\n\n        self.expand_id += 1;\n\n        Ok((trs, final_weight))\n    }"
}