{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `rank_select::select::CombinedSampling::<D>::select_unchecked`",
    "file": "bitm-0.5.1/src/rank_select/select.rs",
    "start_line": 641,
    "start_col": 5,
    "end_line": 674,
    "end_col": 6,
    "code_snippet": "unsafe fn select_unchecked<const ONE: bool>(&self, content: &[u64], #[cfg(target_pointer_width = \"64\")] l1ranks: &[usize], l2ranks: &[u64], mut rank: usize) -> usize {\n        #[cfg(target_pointer_width = \"64\")] let l1_index = select_l1::<ONE>(l1ranks, &mut rank);\n        #[cfg(target_pointer_width = \"64\")] let l2_begin = l1_index * L2_ENTRIES_PER_L1_ENTRY;\n\n        /*let l2chunk = l2ranks.get_unchecked(l2_begin..l2ranks.len().min(l2_begin+L2_ENTRIES_PER_L1_ENTRY));\n        let mut l2_index = *self.select.get_unchecked(self.select_begin.get_unchecked(l1_index) + D::divide_by_density(rank as usize, self.density)) as usize;\n        while let Some(v) = l2chunk.get(l2_index+1) {\n            let v = if ONE {(*v & 0xFF_FF_FF_FF) as usize}\n                else {(l2_index+1) * BITS_PER_L2_ENTRY - (*v & 0xFF_FF_FF_FF) as usize};\n            if v > rank { break; }\n            l2_index += 1;\n        }\n        unsafe { select_from_l2_unchecked::<ONE>(content, l2ranks, l2_begin+l2_index, rank) }*/\n\n        //let mut l2_index = l2_begin + self.get_select_unchecked(l1_index, rank) as usize;\n        #[cfg(target_pointer_width = \"64\")] let mut l2_index = l2_begin + self.decode_shift(\n            *self.select.get_unchecked(self.select_begin.get_unchecked(l1_index) + D::divide(rank, self.density)),\n            rank) as usize;\n        #[cfg(target_pointer_width = \"64\")] let l2_chunk_end = l2ranks.len().min(l2_begin+L2_ENTRIES_PER_L1_ENTRY);\n\n        #[cfg(target_pointer_width = \"32\")] let l2_begin = 0;\n        #[cfg(target_pointer_width = \"32\")] let mut l2_index = self.decode_shift(\n            *self.select.get_unchecked(D::divide(rank, self.density)), rank) as usize;\n        #[cfg(target_pointer_width = \"32\")] let l2_chunk_end = l2ranks.len();\n\n        while l2_index+1 < l2_chunk_end &&\n             if ONE {(l2ranks.get_unchecked(l2_index+1) & 0xFF_FF_FF_FF) as usize}\n             else {(l2_index+1-l2_begin) /*% L2_ENTRIES_PER_L1_ENTRY*/ * BITS_PER_L2_ENTRY - (l2ranks.get_unchecked(l2_index+1) & 0xFF_FF_FF_FF) as usize}\n             <= rank\n        {\n            l2_index += 1;\n        }\n        unsafe { select_from_l2_unchecked::<ONE>(content, l2ranks, l2_index, rank) }\n    }"
}