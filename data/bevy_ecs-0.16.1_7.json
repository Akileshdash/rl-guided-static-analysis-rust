{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `observer::runner::observer_system_runner`",
    "file": "bevy_ecs-0.16.1/src/observer/runner.rs",
    "start_line": 350,
    "start_col": 1,
    "end_line": 435,
    "end_col": 2,
    "code_snippet": "fn observer_system_runner<E: Event, B: Bundle, S: ObserverSystem<E, B>>(\n    mut world: DeferredWorld,\n    observer_trigger: ObserverTrigger,\n    ptr: PtrMut,\n    propagate: &mut bool,\n) {\n    let world = world.as_unsafe_world_cell();\n    // SAFETY: Observer was triggered so must still exist in world\n    let observer_cell = unsafe {\n        world\n            .get_entity(observer_trigger.observer)\n            .debug_checked_unwrap()\n    };\n    // SAFETY: Observer was triggered so must have an `ObserverState`\n    let mut state = unsafe {\n        observer_cell\n            .get_mut::<ObserverState>()\n            .debug_checked_unwrap()\n    };\n\n    // TODO: Move this check into the observer cache to avoid dynamic dispatch\n    let last_trigger = world.last_trigger_id();\n    if state.last_trigger_id == last_trigger {\n        return;\n    }\n    state.last_trigger_id = last_trigger;\n\n    // SAFETY: Observer was triggered so must have an `Observer` component.\n    let error_handler = unsafe {\n        observer_cell\n            .get::<Observer>()\n            .debug_checked_unwrap()\n            .error_handler\n            .debug_checked_unwrap()\n    };\n\n    let trigger: Trigger<E, B> = Trigger::new(\n        // SAFETY: Caller ensures `ptr` is castable to `&mut T`\n        unsafe { ptr.deref_mut() },\n        propagate,\n        observer_trigger,\n    );\n    // SAFETY:\n    // - observer was triggered so must have an `Observer` component.\n    // - observer cannot be dropped or mutated until after the system pointer is already dropped.\n    let system: *mut dyn ObserverSystem<E, B> = unsafe {\n        let mut observe = observer_cell.get_mut::<Observer>().debug_checked_unwrap();\n        let system = observe.system.downcast_mut::<S>().unwrap();\n        &mut *system\n    };\n\n    // SAFETY:\n    // - `update_archetype_component_access` is called first\n    // - there are no outstanding references to world except a private component\n    // - system is an `ObserverSystem` so won't mutate world beyond the access of a `DeferredWorld`\n    //   and is never exclusive\n    // - system is the same type erased system from above\n    unsafe {\n        (*system).update_archetype_component_access(world);\n        match (*system).validate_param_unsafe(world) {\n            Ok(()) => {\n                if let Err(err) = (*system).run_unsafe(trigger, world) {\n                    error_handler(\n                        err,\n                        ErrorContext::Observer {\n                            name: (*system).name(),\n                            last_run: (*system).get_last_run(),\n                        },\n                    );\n                };\n                (*system).queue_deferred(world.into_deferred());\n            }\n            Err(e) => {\n                if !e.skipped {\n                    error_handler(\n                        e.into(),\n                        ErrorContext::Observer {\n                            name: (*system).name(),\n                            last_run: (*system).get_last_run(),\n                        },\n                    );\n                }\n            }\n        }\n    }\n}"
}