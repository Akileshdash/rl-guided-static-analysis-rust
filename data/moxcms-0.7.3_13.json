{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `conversions::sse::rgb_xyz::TransformShaperRgbSse::<T, SRC_LAYOUT, DST_LAYOUT, LINEAR_CAP, GAMMA_LUT, BIT_DEPTH>::transform_impl`",
    "file": "moxcms-0.7.3/src/conversions/sse/rgb_xyz.rs",
    "start_line": 64,
    "start_col": 5,
    "end_line": 139,
    "end_col": 6,
    "code_snippet": "unsafe fn transform_impl(&self, src: &[T], dst: &mut [T]) -> Result<(), CmsError> {\n        let src_cn = Layout::from(SRC_LAYOUT);\n        let dst_cn = Layout::from(DST_LAYOUT);\n        let src_channels = src_cn.channels();\n        let dst_channels = dst_cn.channels();\n\n        let mut temporary = SseAlignedU16([0; 8]);\n\n        if src.len() / src_channels != dst.len() / dst_channels {\n            return Err(CmsError::LaneSizeMismatch);\n        }\n        if src.len() % src_channels != 0 {\n            return Err(CmsError::LaneMultipleOfChannels);\n        }\n        if dst.len() % dst_channels != 0 {\n            return Err(CmsError::LaneMultipleOfChannels);\n        }\n\n        let t = self.profile.adaptation_matrix.transpose();\n\n        let scale = (GAMMA_LUT - 1) as f32;\n        let max_colors: T = ((1 << BIT_DEPTH) - 1).as_();\n\n        unsafe {\n            let m0 = _mm_setr_ps(t.v[0][0], t.v[0][1], t.v[0][2], 0f32);\n            let m1 = _mm_setr_ps(t.v[1][0], t.v[1][1], t.v[1][2], 0f32);\n            let m2 = _mm_setr_ps(t.v[2][0], t.v[2][1], t.v[2][2], 0f32);\n\n            let zeros = _mm_setzero_ps();\n\n            let v_scale = _mm_set1_ps(scale);\n\n            for (src, dst) in src\n                .chunks_exact(src_channels)\n                .zip(dst.chunks_exact_mut(dst_channels))\n            {\n                let rp = &self.profile.r_linear[src[src_cn.r_i()]._as_usize()];\n                let gp = &self.profile.g_linear[src[src_cn.g_i()]._as_usize()];\n                let bp = &self.profile.b_linear[src[src_cn.b_i()]._as_usize()];\n\n                let mut r = _mm_load_ss(rp);\n                let mut g = _mm_load_ss(gp);\n                let mut b = _mm_load_ss(bp);\n                let a = if src_channels == 4 {\n                    src[src_cn.a_i()]\n                } else {\n                    max_colors\n                };\n\n                r = _mm_shuffle_ps::<0>(r, r);\n                g = _mm_shuffle_ps::<0>(g, g);\n                b = _mm_shuffle_ps::<0>(b, b);\n\n                let v0 = _mm_mul_ps(r, m0);\n                let v1 = _mm_mul_ps(g, m1);\n                let v2 = _mm_mul_ps(b, m2);\n\n                let mut v = _mm_add_ps(_mm_add_ps(v0, v1), v2);\n                v = _mm_max_ps(v, zeros);\n                v = _mm_mul_ps(v, v_scale);\n                v = _mm_min_ps(v, v_scale);\n\n                let zx = _mm_cvtps_epi32(v);\n                _mm_store_si128(temporary.0.as_mut_ptr() as *mut _, zx);\n\n                dst[dst_cn.r_i()] = self.profile.r_gamma[temporary.0[0] as usize];\n                dst[dst_cn.g_i()] = self.profile.g_gamma[temporary.0[2] as usize];\n                dst[dst_cn.b_i()] = self.profile.b_gamma[temporary.0[4] as usize];\n                if dst_channels == 4 {\n                    dst[dst_cn.a_i()] = a;\n                }\n            }\n        }\n\n        Ok(())\n    }"
}