{
    "level": "Warning",
    "analyzer": "UnsafeDestructor",
    "op_type": null,
    "description": "unsafe block detected in drop",
    "file": "drain_filter_polyfill-0.1.3/src/copypasted_impl.rs",
    "start_line": 173,
    "start_col": 9,
    "end_line": 175,
    "end_col": 38,
    "code_snippet": "impl<'a, 'b, T, F> Drop for BackshiftOnDrop<'a, 'b, T, F>\n        where\n            F: FnMut(&mut T) -> bool,\n        {\n            fn drop(&mut self) {\n                unsafe {\n                    if self.drain.idx < self.drain.old_len && self.drain.del > 0 {\n                        // This is a pretty messed up state, and there isn't really an\n                        // obviously right thing to do. We don't want to keep trying\n                        // to execute `pred`, so we just backshift all the unprocessed\n                        // elements and tell the vec that they still exist. The backshift\n                        // is required to prevent a double-drop of the last successfully\n                        // drained item prior to a panic in the predicate.\n                        let ptr = self.drain.vec.as_mut_ptr();\n                        let src = ptr.add(self.drain.idx);\n                        let dst = src.sub(self.drain.del);\n                        let tail_len = self.drain.old_len - self.drain.idx;\n                        src.copy_to(dst, tail_len);\n                    }\n                    self.drain.vec.set_len(self.drain.old_len - self.drain.del);\n                }\n            }\n        }"
}