{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<rank_select::RankSelect101111<S, S0, BV> as rank_select::Rank>::rank_unchecked`",
    "file": "bitm-0.5.1/src/rank_select/mod.rs",
    "start_line": 225,
    "start_col": 15,
    "end_line": 243,
    "end_col": 6,
    "code_snippet": "#[inline] unsafe fn rank_unchecked(&self, index: usize) -> usize {\n        let block = index / 512;\n        let word_idx = index / 64;   \n        let block_content = *unsafe{ self.l2ranks.get_unchecked(index/2048) };\n        #[cfg(target_pointer_width = \"64\")] let mut r = *self.l1ranks.get_unchecked(index >> 32) + (block_content & 0xFFFFFFFFu64) as usize; // 32 lowest bits   // for 34 bits: 0x3FFFFFFFFu64\n        #[cfg(target_pointer_width = \"32\")] let mut r = (block_content & 0xFFFFFFFFu64) as usize;\n        r += (self.content.get_unchecked(word_idx) & n_lowest_bits(index as u8 % 64)).count_ones() as usize;\n\n        //r += (((block_content>>32) >> (33 - 11 * (block & 3))) & 0b1_11111_11111) as usize;\n        //r += (((block_content >> (33 - 11 * (block & 3))) >> 32) & 0b1_11111_11111) as usize;\n        //if block & 3 != 0 { r += ((block_content >> ((32+33) - 11 * (block & 3))) & 0b1_11111_11111) as usize }\n        //r += (((block_content >> 32) >> (11 * (3 - (block & 3)))) & 0b1_11111_11111) as usize;\n        \n        r += (((block_content >> (11 * (!block & 3))) >> 32) & 0b1_11111_11111) as usize;\n        //r += (((block_content >> 32) >> (11 * (!block & 3))) & 0b1_11111_11111) as usize;\n\n        //r + count_bits_in(self.content.get_unchecked(block * 8..word_idx))\n        r + count_bits_in(self.content.get_unchecked(word_idx&!7..word_idx))\n    }"
}