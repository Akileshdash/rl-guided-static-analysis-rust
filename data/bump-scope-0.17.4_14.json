{
    "level": "Warning",
    "analyzer": "UnsafeDestructor",
    "op_type": null,
    "description": "unsafe block detected in drop",
    "file": "bump-scope-0.17.4/src/bump_vec/splice.rs",
    "start_line": 56,
    "start_col": 1,
    "end_line": 56,
    "end_col": 62,
    "code_snippet": "impl<I: Iterator, A: BumpAllocator> Drop for Splice<'_, I, A> {\n    fn drop(&mut self) {\n        self.drain.by_ref().for_each(drop);\n        // At this point draining is done and the only remaining tasks are splicing\n        // and moving things into the final place.\n        // Which means we can replace the slice::Iter with pointers that won't point to deallocated\n        // memory, so that Drain::drop is still allowed to call iter.len(), otherwise it would break\n        // the ptr.sub_ptr contract.\n        self.drain.iter = <[I::Item]>::iter(&[]);\n\n        unsafe {\n            if self.drain.tail_len == 0 {\n                self.drain.vec.as_mut().extend(self.replace_with.by_ref());\n                return;\n            }\n\n            // First fill the range left by drain().\n            if !self.drain.fill(&mut self.replace_with) {\n                return;\n            }\n\n            // There may be more elements. Use the lower bound as an estimate.\n            // STD-FIXME: Is the upper bound a better guess? Or something else?\n            let (lower_bound, _upper_bound) = self.replace_with.size_hint();\n            if lower_bound > 0 {\n                self.drain.move_tail(lower_bound);\n                if !self.drain.fill(&mut self.replace_with) {\n                    return;\n                }\n            }\n\n            // Collect any remaining elements.\n            // This is a zero-length vector which does not allocate if `lower_bound` was exact.\n            let collected = BumpVec::from_iter_in(&mut self.replace_with, self.drain.vec.as_ref().allocator());\n\n            // We can't use `into_fixed_vec` here because that would require a\n            // `BumpAllocatorScope<'a>` instead of just a `BumpAllocator`.\n            destructure!(let BumpVec::<I::Item, &A> { fixed: collected } = collected);\n            let mut collected = collected.cook().into_iter();\n\n            // Now we have an exact count.\n            #[allow(clippy::len_zero)]\n            if collected.len() > 0 {\n                self.drain.move_tail(collected.len());\n                let filled = self.drain.fill(&mut collected);\n                debug_assert!(filled);\n                debug_assert_eq!(collected.len(), 0);\n            }\n        }\n        // Let `Drain::drop` move the tail back if necessary and restore `vec.len`.\n    }\n}"
}