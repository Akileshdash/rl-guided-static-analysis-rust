{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<algorithm::type2and3_splitradix::Type2And3SplitRadix<T> as Dct3<T>>::process_dct3_with_scratch`",
    "file": "rustdct-0.7.1/src/algorithm/type2and3_splitradix.rs",
    "start_line": 150,
    "start_col": 5,
    "end_line": 222,
    "end_col": 6,
    "code_snippet": "fn process_dct3_with_scratch(&self, buffer: &mut [T], scratch: &mut [T]) {\n        let scratch = validate_buffers!(buffer, scratch, self.len(), self.get_scratch_len());\n\n        let len = buffer.len();\n        let half_len = len / 2;\n        let quarter_len = len / 4;\n\n        // divide the output into 3 sub-lists to use for our inner DCTs, one of size N/2 and two of size N/4\n        let (recursive_input_evens, recursive_input_odds) = scratch.split_at_mut(half_len);\n        let (recursive_input_n1, recursive_input_n3) =\n            recursive_input_odds.split_at_mut(quarter_len);\n\n        // do the same pre-loop setup as DCT4ViaDCT3, and since we're skipping the first iteration of the loop we\n        // to also set up the corresponding evens cells\n        recursive_input_evens[0] = buffer[0];\n        recursive_input_evens[1] = buffer[2];\n        recursive_input_n1[0] = buffer[1] * T::two();\n        recursive_input_n3[0] = buffer[len - 1] * T::two();\n\n        // populate the recursive input arrays\n        for i in 1..quarter_len {\n            let k = 4 * i;\n\n            unsafe {\n                // the evens are the easy ones - just copy straight over\n                *recursive_input_evens.get_unchecked_mut(i * 2) = *buffer.get_unchecked(k);\n                *recursive_input_evens.get_unchecked_mut(i * 2 + 1) = *buffer.get_unchecked(k + 2);\n\n                // for the odd ones we're going to do the same addition/subtraction we do in the setup for DCT4ViaDCT3\n                *recursive_input_n1.get_unchecked_mut(i) =\n                    *buffer.get_unchecked(k - 1) + *buffer.get_unchecked(k + 1);\n                *recursive_input_n3.get_unchecked_mut(quarter_len - i) =\n                    *buffer.get_unchecked(k - 1) - *buffer.get_unchecked(k + 1);\n            }\n        }\n\n        //perform our recursive DCTs, using the original buffer as scratch space\n        self.half_dct\n            .process_dct3_with_scratch(recursive_input_evens, buffer);\n        self.quarter_dct\n            .process_dct3_with_scratch(recursive_input_n1, buffer);\n        self.quarter_dct\n            .process_dct3_with_scratch(recursive_input_n3, buffer);\n\n        //merge the results. we're going to combine 2 separate things:\n        // - merging the two smaller DCT3 outputs into a DCT4 output\n        // - marging the DCT4 outputand the larger DCT3 output into the final output\n        for i in 0..quarter_len {\n            let twiddle = self.twiddles[i];\n            let cosine_value = recursive_input_n1[i];\n\n            // flip the sign of every other sine value to finish the job of using a DCT3 to compute a DST3\n            let sine_value = if i % 2 == 0 {\n                recursive_input_n3[i]\n            } else {\n                -recursive_input_n3[i]\n            };\n\n            let lower_dct4 = cosine_value * twiddle.re + sine_value * twiddle.im;\n            let upper_dct4 = cosine_value * twiddle.im - sine_value * twiddle.re;\n\n            unsafe {\n                let lower_dct3 = *recursive_input_evens.get_unchecked(i);\n                let upper_dct3 = *recursive_input_evens.get_unchecked(half_len - i - 1);\n\n                *buffer.get_unchecked_mut(i) = lower_dct3 + lower_dct4;\n                *buffer.get_unchecked_mut(len - i - 1) = lower_dct3 - lower_dct4;\n\n                *buffer.get_unchecked_mut(half_len - i - 1) = upper_dct3 + upper_dct4;\n                *buffer.get_unchecked_mut(half_len + i) = upper_dct3 - upper_dct4;\n            }\n        }\n    }"
}