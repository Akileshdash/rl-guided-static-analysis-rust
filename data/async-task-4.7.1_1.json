{
    "level": "Warning",
    "analyzer": "UnsafeDestructor",
    "op_type": null,
    "description": "unsafe block detected in drop",
    "file": "async-task-4.7.1/src/raw.rs",
    "start_line": 682,
    "start_col": 9,
    "end_line": 685,
    "end_col": 28,
    "code_snippet": "impl<F, T, S, M> Drop for Guard<F, T, S, M>\n        where\n            F: Future<Output = T>,\n            S: Schedule<M>,\n        {\n            fn drop(&mut self) {\n                let raw = self.0;\n                let ptr = raw.header as *const ();\n\n                unsafe {\n                    let mut state = (*raw.header).state.load(Ordering::Acquire);\n\n                    loop {\n                        // If the task was closed while running, then unschedule it, drop its\n                        // future, and drop the task reference.\n                        if state & CLOSED != 0 {\n                            // The thread that closed the task didn't drop the future because it\n                            // was running so now it's our responsibility to do so.\n                            RawTask::<F, T, S, M>::drop_future(ptr);\n\n                            // Mark the task as not running and not scheduled.\n                            (*raw.header)\n                                .state\n                                .fetch_and(!RUNNING & !SCHEDULED, Ordering::AcqRel);\n\n                            // Take the awaiter out.\n                            let mut awaiter = None;\n                            if state & AWAITER != 0 {\n                                awaiter = (*raw.header).take(None);\n                            }\n\n                            // Drop the task reference.\n                            RawTask::<F, T, S, M>::drop_ref(ptr);\n\n                            // Notify the awaiter that the future has been dropped.\n                            if let Some(w) = awaiter {\n                                abort_on_panic(|| w.wake());\n                            }\n                            break;\n                        }\n\n                        // Mark the task as not running, not scheduled, and closed.\n                        match (*raw.header).state.compare_exchange_weak(\n                            state,\n                            (state & !RUNNING & !SCHEDULED) | CLOSED,\n                            Ordering::AcqRel,\n                            Ordering::Acquire,\n                        ) {\n                            Ok(state) => {\n                                // Drop the future because the task is now closed.\n                                RawTask::<F, T, S, M>::drop_future(ptr);\n\n                                // Take the awaiter out.\n                                let mut awaiter = None;\n                                if state & AWAITER != 0 {\n                                    awaiter = (*raw.header).take(None);\n                                }\n\n                                // Drop the task reference.\n                                RawTask::<F, T, S, M>::drop_ref(ptr);\n\n                                // Notify the awaiter that the future has been dropped.\n                                if let Some(w) = awaiter {\n                                    abort_on_panic(|| w.wake());\n                                }\n                                break;\n                            }\n                            Err(s) => state = s,\n                        }\n                    }\n                }\n            }\n        }"
}