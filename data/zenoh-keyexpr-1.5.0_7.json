{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<keyexpr_tree::iters::inclusion::InclusionMut<'a, Children, Node, Weight> as std::iter::Iterator>::next`",
    "file": "zenoh-keyexpr-1.5.0/src/keyexpr_tree/iters/inclusion.rs",
    "start_line": 236,
    "start_col": 5,
    "end_line": 342,
    "end_col": 6,
    "code_snippet": "fn next(&mut self) -> Option<Self::Item> {\n        loop {\n            let StackFrameMut {\n                iterator,\n                start,\n                end,\n                _marker,\n            } = self.iterators.last_mut()?;\n            match iterator.next() {\n                Some(node) => {\n                    let mut node_matches = false;\n                    let new_start = *end;\n                    let mut new_end = *end;\n                    macro_rules! push {\n                        ($index: expr) => {\n                            let index = $index;\n                            if new_end == new_start\n                                || self.ke_indices[new_start..new_end]\n                                    .iter()\n                                    .rev()\n                                    .all(|c| *c < index)\n                            {\n                                self.ke_indices.push(index);\n                                new_end += 1;\n                            }\n                        };\n                    }\n                    let chunk = node.chunk();\n                    let chunk_is_verbatim = chunk.first_byte() == b'@';\n                    for i in *start..*end {\n                        let kec_start = self.ke_indices[i];\n                        if kec_start == self.key.len() {\n                            break;\n                        }\n                        let key = &self.key.as_bytes()[kec_start..];\n                        match key.iter().position(|&c| c == b'/') {\n                            Some(kec_end) => {\n                                let subkey =\n                                    unsafe { keyexpr::from_slice_unchecked(&key[..kec_end]) };\n                                if unlikely(subkey == \"**\") {\n                                    if !chunk_is_verbatim {\n                                        push!(kec_start);\n                                        push!(kec_start + kec_end + 1);\n                                    }\n                                    let post_key = &key[kec_end + 1..];\n                                    match post_key.iter().position(|&c| c == b'/') {\n                                        Some(sec_end) => {\n                                            let post_key = unsafe {\n                                                keyexpr::from_slice_unchecked(&post_key[..sec_end])\n                                            };\n                                            if post_key.includes(chunk) {\n                                                push!(kec_start + kec_end + sec_end + 2);\n                                            }\n                                        }\n                                        None => {\n                                            if unsafe { keyexpr::from_slice_unchecked(post_key) }\n                                                .includes(chunk)\n                                            {\n                                                node_matches = true;\n                                            }\n                                        }\n                                    }\n                                } else if subkey.includes(chunk) {\n                                    push!(kec_start + kec_end + 1);\n                                }\n                            }\n                            None => {\n                                let key = unsafe { keyexpr::from_slice_unchecked(key) };\n                                if unlikely(key == \"**\") && chunk.first_byte() != b'@' {\n                                    push!(kec_start);\n                                    node_matches = true;\n                                } else if key.includes(chunk) {\n                                    push!(self.key.len());\n                                    node_matches = true;\n                                }\n                            }\n                        }\n                    }\n                    if new_end > new_start {\n                        for &i in &self.ke_indices[new_start..new_end] {\n                            if &self.key.as_bytes()[i..] == b\"**\" {\n                                node_matches = true;\n                                break;\n                            }\n                        }\n                        let iterator = unsafe { &mut *(node.as_node_mut() as *mut Node) }\n                            .children_mut()\n                            .children_mut();\n                        self.iterators.push(StackFrameMut {\n                            iterator,\n                            start: new_start,\n                            end: new_end,\n                            _marker: Default::default(),\n                        })\n                    }\n                    if node_matches {\n                        return Some(node);\n                    }\n                }\n                None => {\n                    if let Some(StackFrameMut { start, .. }) = self.iterators.pop() {\n                        self.ke_indices.truncate(start);\n                    }\n                }\n            }\n        }\n    }"
}