{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `graph::Graph::<B, T>::run`",
    "file": "rendy-graph-0.5.1/src/graph/mod.rs",
    "start_line": 167,
    "start_col": 5,
    "end_line": 251,
    "end_col": 6,
    "code_snippet": "pub fn run(&mut self, factory: &mut Factory<B>, families: &mut Families<B>, aux: &T) {\n        profile_scope!(\"run\");\n\n        self.assert_device_owner(factory.device());\n\n        if self.frames.next().index() >= self.inflight as _ {\n            let wait = Frame::with_index(self.frames.next().index() - self.inflight as u64);\n            let ref mut self_fences = self.fences;\n            self.frames.wait_complete(wait, factory, |mut fences| {\n                factory.reset_fences(&mut fences).unwrap();\n                self_fences.push(fences);\n            });\n        }\n\n        let mut fences = self.fences.pop().unwrap_or_else(Fences::<B>::default);\n        let mut fences_used = 0;\n        let ref semaphores = self.semaphores;\n\n        for submission in self.schedule.ordered() {\n            log::trace!(\"Run node {}\", submission.node());\n            let sid = submission.id();\n            let qid = sid.queue();\n\n            let GraphNode { node, queue } = self\n                .nodes\n                .get_mut(submission.node())\n                .expect(\"Submission references node with out of bound index\");\n            debug_assert_eq!(\n                (qid.family(), qid.index()),\n                (QueueFamilyId(queue.0), queue.1),\n                \"Node's queue doesn't match schedule\"\n            );\n\n            let last_in_queue = sid.index() + 1 == self.schedule.queue(qid).unwrap().len();\n            let fence = if last_in_queue {\n                if fences_used >= fences.len() {\n                    fences.push(factory.create_fence(false).unwrap());\n                }\n                fences_used += 1;\n                Some(&mut fences[fences_used - 1])\n            } else {\n                None\n            };\n\n            unsafe {\n                node.run(\n                    &self.ctx,\n                    factory,\n                    families.family_by_index_mut(queue.0).queue_mut(queue.1),\n                    aux,\n                    &self.frames,\n                    &submission\n                        .sync()\n                        .wait\n                        .iter()\n                        .map(|wait| {\n                            log::trace!(\n                                \"Node {} waits for {}\",\n                                submission.node(),\n                                *wait.semaphore()\n                            );\n                            (&semaphores[*wait.semaphore()], wait.stage())\n                        })\n                        .collect::<smallvec::SmallVec<[_; 16]>>(),\n                    &submission\n                        .sync()\n                        .signal\n                        .iter()\n                        .map(|signal| {\n                            log::trace!(\n                                \"Node {} signals {}\",\n                                submission.node(),\n                                *signal.semaphore()\n                            );\n                            &semaphores[*signal.semaphore()]\n                        })\n                        .collect::<smallvec::SmallVec<[_; 16]>>(),\n                    fence,\n                )\n            }\n        }\n\n        fences.truncate(fences_used);\n        self.frames.advance(fences);\n    }"
}