{
    "level": "Warning",
    "analyzer": "UnsafeDataflow",
    "op_type": "ReadFlow",
    "description": "Potential unsafe dataflow issue in `wrappers::Unalign::<T>::update`",
    "file": "zerocopy-0.8.26/src/wrappers.rs",
    "start_line": 319,
    "start_col": 5,
    "end_line": 374,
    "end_col": 6,
    "code_snippet": "pub fn update<O, F: FnOnce(&mut T) -> O>(&mut self, f: F) -> O {\n        if mem::align_of::<T>() == 1 {\n            // While we advise callers to use `DerefMut` when `T: Unaligned`,\n            // not all callers will be able to guarantee `T: Unaligned` in all\n            // cases. In particular, callers who are themselves providing an API\n            // which is generic over `T` may sometimes be called by *their*\n            // callers with `T` such that `align_of::<T>() == 1`, but cannot\n            // guarantee this in the general case. Thus, this optimization may\n            // sometimes be helpful.\n\n            // SAFETY: Since `T`'s alignment is 1, `self` satisfies its\n            // alignment by definition.\n            let t = unsafe { self.deref_mut_unchecked() };\n            return f(t);\n        }\n\n        // On drop, this moves `copy` out of itself and uses `ptr::write` to\n        // overwrite `slf`.\n        struct WriteBackOnDrop<T> {\n            copy: ManuallyDrop<T>,\n            slf: *mut Unalign<T>,\n        }\n\n        impl<T> Drop for WriteBackOnDrop<T> {\n            fn drop(&mut self) {\n                // SAFETY: We never use `copy` again as required by\n                // `ManuallyDrop::take`.\n                let copy = unsafe { ManuallyDrop::take(&mut self.copy) };\n                // SAFETY: `slf` is the raw pointer value of `self`. We know it\n                // is valid for writes and properly aligned because `self` is a\n                // mutable reference, which guarantees both of these properties.\n                unsafe { ptr::write(self.slf, Unalign::new(copy)) };\n            }\n        }\n\n        // SAFETY: We know that `self` is valid for reads, properly aligned, and\n        // points to an initialized `Unalign<T>` because it is a mutable\n        // reference, which guarantees all of these properties.\n        //\n        // Since `T: !Copy`, it would be unsound in the general case to allow\n        // both the original `Unalign<T>` and the copy to be used by safe code.\n        // We guarantee that the copy is used to overwrite the original in the\n        // `Drop::drop` impl of `WriteBackOnDrop`. So long as this `drop` is\n        // called before any other safe code executes, soundness is upheld.\n        // While this method can terminate in two ways (by returning normally or\n        // by unwinding due to a panic in `f`), in both cases, `write_back` is\n        // dropped - and its `drop` called - before any other safe code can\n        // execute.\n        let copy = unsafe { ptr::read(self) }.into_inner();\n        let mut write_back = WriteBackOnDrop { copy: ManuallyDrop::new(copy), slf: self };\n\n        let ret = f(&mut write_back.copy);\n\n        drop(write_back);\n        ret\n    }"
}