{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `lazy::expanded::ExpandingReader::<Encoding, Input>::next_system_item`",
    "file": "ion-rs-1.0.0-rc.11/src/lazy/expanded/mod.rs",
    "start_line": 590,
    "start_col": 5,
    "end_line": 681,
    "end_col": 6,
    "code_snippet": "pub fn next_system_item(&self) -> IonResult<SystemStreamItem<'_, Encoding>> {\n        // NB: This method takes an immutable reference to `self` but uses `UnsafeCell` to modify\n        //     `self` safely. This allows `next_item` to be used in a loop from next_value without\n        //     encountering the borrow checker limitations this method skirts. If/when the borrow\n        //     checker issue is addressed, we may change this to `&mut self`.\n\n        // If there's already an active macro evaluator, that means the reader is still in the process\n        // of expanding a macro invocation it previously encountered. See if it has a value to give us.\n        if let Some(ptr) = self.evaluator_ptr.get() {\n            // If there's already an evaluator, dereference the pointer.\n            let evaluator = Self::ptr_to_evaluator(ptr);\n            match evaluator.next() {\n                Ok(Some(value)) => {\n                    if evaluator.is_empty() {\n                        // If the evaluator is empty, unset the pointer so we know not to query it\n                        // further.\n                        self.evaluator_ptr.set(None);\n                    }\n                    return self.interpret_value(value);\n                }\n                Ok(None) => {}\n                Err(e) => return Err(e),\n            }\n        }\n\n        // Otherwise, we're now between top level expressions. Take this opportunity to apply any\n        // pending changes to the encoding context and reset state as needed.\n        self.between_top_level_expressions();\n\n        // See if the raw reader can get another expression from the input stream. It's possible\n        // to find an expression that yields no values (for example: `(:none)`), so we perform this\n        // step in a loop until we get a value or end-of-stream.\n        let context_ref = self.context();\n\n        loop {\n            // Pull another top-level expression from the input stream if one is available.\n            use crate::lazy::raw_stream_item::RawStreamItem::*;\n            let raw_reader = unsafe { &mut *self.raw_reader.get() };\n            match raw_reader.next(context_ref)? {\n                VersionMarker(marker) => {\n                    return self.interpret_ivm(marker);\n                }\n                // We got our value; return it.\n                Value(raw_value) => {\n                    let value = LazyExpandedValue::from_literal(context_ref, raw_value);\n                    return self.interpret_value(value);\n                }\n                // It's another macro invocation, we'll start evaluating it.\n                EExp(e_exp) => {\n                    let resolved_e_exp = e_exp.resolve(context_ref)?;\n\n                    // If this e-expression invokes a template with a non-system, singleton expansion, we can use the\n                    // e-expression to back a LazyExpandedValue. It will only be evaluated if the user calls `read()`.\n                    if let Some(value) = LazyExpandedValue::try_from_e_expression(resolved_e_exp) {\n                        // Because the expansion is guaranteed not to be a system value, we do not need to interpret it.\n                        return Ok(SystemStreamItem::Value(LazyValue::new(value)));\n                    }\n                    let new_evaluator = MacroEvaluator::for_eexp(resolved_e_exp)?;\n                    // Get the current evaluator or make a new one\n                    let evaluator = match self.evaluator_ptr.get() {\n                        // If there's already an evaluator in the bump, it's empty. Overwrite it with our new one.\n                        Some(ptr) => {\n                            let bump_evaluator_ref = Self::ptr_to_evaluator(ptr);\n                            *bump_evaluator_ref = new_evaluator;\n                            bump_evaluator_ref\n                        }\n                        // If there's not an evaluator in the bump, make a new one.\n                        None => context_ref.allocator.alloc_with(|| new_evaluator),\n                    };\n\n                    // Try to get a value by starting to evaluate the e-expression.\n                    if let Some(value) = evaluator.next()? {\n                        // If we get a value and the evaluator isn't empty yet, save its pointer\n                        // so we can try to get more out of it when `next_at_or_above_depth` is called again.\n                        if !evaluator.is_empty() {\n                            self.evaluator_ptr\n                                .set(Some(Self::evaluator_to_ptr(evaluator)));\n                        }\n                        // If we get a value, return it.\n                        return self.interpret_value(value);\n                    } else {\n                        // If the expression was equivalent to `(:none)`, return to the top of\n                        // the loop and get the next expression.\n                        continue;\n                    }\n                }\n                EndOfStream(end_position) => {\n                    return Ok(SystemStreamItem::EndOfStream(end_position));\n                }\n            };\n        }\n    }"
}