{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `matrix::decomposition::svd::<impl matrix::Matrix<T>>::svd_golub_reinsch`",
    "file": "rulinalg-0.4.2/src/matrix/decomposition/svd.rs",
    "start_line": 136,
    "start_col": 5,
    "end_line": 225,
    "end_col": 6,
    "code_snippet": "fn svd_golub_reinsch(mut self) -> Result<(Matrix<T>, Matrix<T>, Matrix<T>), Error> {\n        let mut flipped = false;\n\n        // The algorithm assumes rows > cols. If this is not the case we transpose and fix later.\n        if self.cols > self.rows {\n            self = self.transpose();\n            flipped = true;\n        }\n\n        let eps = T::from(3.0).unwrap() * T::epsilon();\n        let n = self.cols;\n\n        // Get the bidiagonal decomposition\n        let (mut b, mut u, mut v) = try!(self.bidiagonal_decomp()\n            .map_err(|_| Error::new(ErrorKind::DecompFailure, \"Could not compute SVD.\")));\n\n        loop {\n            // Values to count the size of lower diagonal block\n            let mut q = 0;\n            let mut on_lower = true;\n\n            // Values to count top block\n            let mut p = 0;\n            let mut on_middle = false;\n\n            // Iterate through and hard set the super diag if converged\n            for i in (0..n - 1).rev() {\n                let (b_ii, b_sup_diag, diag_abs_sum): (T, T, T);\n                unsafe {\n                    b_ii = *b.get_unchecked([i, i]);\n                    b_sup_diag = b.get_unchecked([i, i + 1]).abs();\n                    diag_abs_sum = eps * (b_ii.abs() + b.get_unchecked([i + 1, i + 1]).abs());\n                }\n                if b_sup_diag <= diag_abs_sum {\n                    // Adjust q or p to define boundaries of sup-diagonal box\n                    if on_lower {\n                        q += 1;\n                    } else if on_middle {\n                        on_middle = false;\n                        p = i + 1;\n                    }\n                    unsafe {\n                        *b.get_unchecked_mut([i, i + 1]) = T::zero();\n                    }\n                } else {\n                    if on_lower {\n                        // No longer on the lower diagonal\n                        on_middle = true;\n                        on_lower = false;\n                    }\n                }\n            }\n\n            // We have converged!\n            if q == n - 1 {\n                break;\n            }\n\n            // Zero off diagonals if needed.\n            for i in p..n - q - 1 {\n                let (b_ii, b_sup_diag): (T, T);\n                unsafe {\n                    b_ii = *b.get_unchecked([i, i]);\n                    b_sup_diag = *b.get_unchecked([i, i + 1]);\n                }\n\n                if b_ii.abs() < eps {\n                    let (c, s) = Matrix::<T>::givens_rot(b_ii, b_sup_diag);\n                    let givens = Matrix::new(2, 2, vec![c, s, -s, c]);\n                    let b_i = MatrixSliceMut::from_matrix(&mut b, [i, i], 1, 2);\n                    let zerod_line = &b_i * givens;\n\n                    b_i.set_to(zerod_line.as_slice());\n                }\n            }\n\n            // Apply Golub-Kahan svd step\n            unsafe {\n                try!(Matrix::<T>::golub_kahan_svd_step(&mut b, &mut u, &mut v, p, q)\n                    .map_err(|_| Error::new(ErrorKind::DecompFailure, \"Could not compute SVD.\")));\n            }\n        }\n\n        if flipped {\n            Ok((b.transpose(), v, u))\n        } else {\n            Ok((b, u, v))\n        }\n\n    }"
}