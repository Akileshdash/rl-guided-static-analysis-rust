{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `raw::HashMap::<K, V, S>::retain`",
    "file": "papaya-0.2.3/src/raw/mod.rs",
    "start_line": 1103,
    "start_col": 5,
    "end_line": 1208,
    "end_col": 6,
    "code_snippet": "pub fn retain<F>(&self, mut f: F, guard: &impl VerifiedGuard)\n    where\n        F: FnMut(&K, &V) -> bool,\n    {\n        // Load the root table.\n        let mut table = self.root(guard);\n\n        // The table has not been initialized yet.\n        if table.raw.is_null() {\n            return;\n        }\n\n        loop {\n            // Get a clean copy of the table to delete from.\n            table = self.linearize(table, guard);\n\n            let mut copying = false;\n            'probe: for i in 0..table.len() {\n                // Load the entry metadata first to ensure consistency with calls to `get`\n                // for entries that are retained.\n                //\n                // Safety: `i` is in bounds for the table length.\n                let meta = unsafe { table.meta(i) }.load(Ordering::Acquire);\n\n                // The entry is empty or deleted.\n                if matches!(meta, meta::EMPTY | meta::TOMBSTONE) {\n                    continue 'probe;\n                }\n\n                // Load the entry to delete.\n                //\n                // Safety: `i` is in bounds for the table length.\n                let mut entry = guard\n                    .protect(unsafe { table.entry(i) }, Ordering::Acquire)\n                    .unpack();\n\n                loop {\n                    // The entry is empty or already deleted.\n                    if entry.ptr.is_null() {\n                        continue 'probe;\n                    }\n\n                    // Found a non-empty entry being copied.\n                    if entry.tag() & Entry::COPYING != 0 {\n                        // Clear every entry in this table that we can, then deal with the copy.\n                        copying = true;\n                        continue 'probe;\n                    }\n\n                    // Safety: We performed a protected load of the pointer using a verified guard with\n                    // `Acquire` and ensured that it is non-null, meaning it is valid for reads as long\n                    // as we hold the guard.\n                    let entry_ref = unsafe { &*entry.ptr };\n\n                    // Should we retain this entry?\n                    if f(&entry_ref.key, &entry_ref.value) {\n                        continue 'probe;\n                    }\n\n                    // Try to delete the entry.\n                    //\n                    // Safety: `i` is in bounds for the table length.\n                    let result = unsafe {\n                        table.entry(i).compare_exchange(\n                            entry.raw,\n                            Entry::TOMBSTONE,\n                            Ordering::Release,\n                            Ordering::Acquire,\n                        )\n                    };\n\n                    match result {\n                        // Successfully deleted the entry.\n                        Ok(_) => {\n                            // Update the metadata table.\n                            //\n                            // Safety: `i` is in bounds for the table length.\n                            unsafe { table.meta(i).store(meta::TOMBSTONE, Ordering::Release) };\n\n                            // Decrement the table length.\n                            self.count.get(guard).fetch_sub(1, Ordering::Relaxed);\n\n                            // Safety: The caller guarantees that `current` is a valid non-null entry that was\n                            // inserted into the map. Additionally, it is now unreachable from this table due\n                            // to the CAS above.\n                            unsafe { self.defer_retire(entry, &table, guard) };\n                            continue 'probe;\n                        }\n\n                        // Lost to a concurrent update, retry.\n                        Err(found) => entry = found.unpack(),\n                    }\n                }\n            }\n\n            // We cleared every entry in this table.\n            if !copying {\n                break;\n            }\n\n            // A resize prevented us from deleting all the entries in this table.\n            //\n            // Complete the resize and retry in the new table.\n            table = self.help_copy(true, &table, guard);\n        }\n    }"
}