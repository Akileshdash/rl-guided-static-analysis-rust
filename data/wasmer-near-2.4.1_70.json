{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `sys::native::NativeFunc::<(A1, A2, A3, A4, A5, A6), Rets>::call`",
    "file": "wasmer-near-2.4.1/src/sys/native.rs",
    "start_line": 136,
    "start_col": 13,
    "end_line": 221,
    "end_col": 14,
    "code_snippet": "pub fn call(&self, $( $x: $x, )* ) -> Result<Rets, RuntimeError> {\n                if !self.is_host() {\n                    // We assume the trampoline is always going to be present for\n                    // Wasm functions\n                    let trampoline = self.exported.vm_function.call_trampoline.expect(\"Call trampoline not found in wasm function\");\n                    // TODO: when `const fn` related features mature more, we can declare a single array\n                    // of the correct size here.\n                    let mut params_list = [ $( $x.to_native().to_binary() ),* ];\n                    let mut rets_list_array = Rets::empty_array();\n                    let rets_list = rets_list_array.as_mut();\n                    let using_rets_array;\n                    let args_rets: &mut [i128] = if params_list.len() > rets_list.len() {\n                        using_rets_array = false;\n                        params_list.as_mut()\n                    } else {\n                        using_rets_array = true;\n                        for (i, &arg) in params_list.iter().enumerate() {\n                            rets_list[i] = arg;\n                        }\n                        rets_list.as_mut()\n                    };\n                    unsafe {\n                        wasmer_vm::wasmer_call_trampoline(\n                            self.vmctx(),\n                            trampoline,\n                            self.address(),\n                            args_rets.as_mut_ptr() as *mut u8,\n                        )\n                    }?;\n                    let num_rets = rets_list.len();\n                    if !using_rets_array && num_rets > 0 {\n                        let src_pointer = params_list.as_ptr();\n                        let rets_list = &mut rets_list_array.as_mut()[0] as *mut i128;\n                        unsafe {\n                            // TODO: we can probably remove this copy by doing some clever `transmute`s.\n                            // we know it's not overlapping because `using_rets_array` is false\n                            std::ptr::copy_nonoverlapping(src_pointer,\n                                                          rets_list,\n                                                          num_rets);\n                        }\n                    }\n                    Ok(Rets::from_array(rets_list_array))\n                    // TODO: When the Host ABI and Wasm ABI are the same, we could do this instead:\n                    // but we can't currently detect whether that's safe.\n                    //\n                    // let results = unsafe {\n                    //     wasmer_vm::catch_traps_with_result(self.vmctx, || {\n                    //         let f = std::mem::transmute::<_, unsafe extern \"C\" fn( *mut VMContext, $( $x, )*) -> Rets::CStruct>(self.address());\n                    //         // We always pass the vmctx\n                    //         f( self.vmctx, $( $x, )* )\n                    //     }).map_err(RuntimeError::from_trap)?\n                    // };\n                    // Ok(Rets::from_c_struct(results))\n\n                }\n                else {\n                    match self.arg_kind() {\n                        VMFunctionKind::Static => {\n                            let results = catch_unwind(AssertUnwindSafe(|| unsafe {\n                                let f = std::mem::transmute::<_, unsafe extern \"C\" fn( VMFunctionEnvironment, $( $x, )*) -> Rets::CStruct>(self.address());\n                                // We always pass the vmctx\n                                f( self.vmctx(), $( $x, )* )\n                            })).map_err(|e| RuntimeError::new(format!(\"{:?}\", e)))?;\n                            Ok(Rets::from_c_struct(results))\n                        },\n                        VMFunctionKind::Dynamic => {\n                            let params_list = [ $( $x.to_native().to_value() ),* ];\n                            let results = {\n                                type VMContextWithEnv = VMDynamicFunctionContext<DynamicFunction<std::ffi::c_void>>;\n                                unsafe {\n                                    let ctx = self.vmctx().host_env as *mut VMContextWithEnv;\n                                    (*ctx).ctx.call(&params_list)?\n                                }\n                            };\n                            let mut rets_list_array = Rets::empty_array();\n                            let mut_rets = rets_list_array.as_mut() as *mut [i128] as *mut i128;\n                            for (i, ret) in results.iter().enumerate() {\n                                unsafe {\n                                    ret.write_value_to(mut_rets.add(i));\n                                }\n                            }\n                            Ok(Rets::from_array(rets_list_array))\n                        }\n                    }\n                }\n            }"
}