{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `avx::avx_raders::RadersAvx2::<A, T>::perform_fft_out_of_place`",
    "file": "rustfft-6.4.0/src/avx/avx_raders.rs",
    "start_line": 414,
    "start_col": 5,
    "end_line": 480,
    "end_col": 6,
    "code_snippet": "fn perform_fft_out_of_place(\n        &self,\n        input: &mut [Complex<T>],\n        output: &mut [Complex<T>],\n        scratch: &mut [Complex<T>],\n    ) {\n        unsafe {\n            // Specialization workaround: See the comments in FftPlannerAvx::new() for why these calls to array_utils::workaround_transmute are necessary\n            let transmuted_input: &mut [Complex<A>] = array_utils::workaround_transmute_mut(input);\n            let transmuted_output: &mut [Complex<A>] =\n                array_utils::workaround_transmute_mut(output);\n            self.prepare_raders(transmuted_input, transmuted_output)\n        }\n\n        let (first_input, inner_input) = input.split_first_mut().unwrap();\n        let (first_output, inner_output) = output.split_first_mut().unwrap();\n\n        // perform the first of two inner FFTs\n        let inner_scratch = if scratch.len() > 0 {\n            &mut scratch[..]\n        } else {\n            &mut inner_input[..]\n        };\n        self.inner_fft\n            .process_with_scratch(inner_output, inner_scratch);\n\n        // inner_output[0] now contains the sum of elements 1..n. we want the sum of all inputs, so all we need to do is add the first input\n        *first_output = inner_output[0] + *first_input;\n\n        // multiply the inner result with our cached setup data\n        // also conjugate every entry. this sets us up to do an inverse FFT\n        // (because an inverse FFT is equivalent to a normal FFT where you conjugate both the inputs and outputs)\n        unsafe {\n            // Specialization workaround: See the comments in FftPlannerAvx::new() for why these calls to array_utils::workaround_transmute are necessary\n            let transmuted_inner_output: &mut [Complex<A>] =\n                array_utils::workaround_transmute_mut(inner_input);\n            let transmuted_inner_input: &mut [Complex<A>] =\n                array_utils::workaround_transmute_mut(inner_output);\n            avx_vector::pairwise_complex_mul_conjugated(\n                transmuted_inner_input,\n                transmuted_inner_output,\n                &self.twiddles,\n            )\n        };\n\n        // We need to add the first input value to all output values. We can accomplish this by adding it to the DC input of our inner ifft.\n        // Of course, we have to conjugate it, just like we conjugated the complex multiplied above\n        inner_input[0] = inner_input[0] + first_input.conj();\n\n        // execute the second FFT\n        let inner_scratch = if scratch.len() > 0 {\n            scratch\n        } else {\n            &mut inner_output[..]\n        };\n        self.inner_fft\n            .process_with_scratch(inner_input, inner_scratch);\n\n        // copy the final values into the output, reordering as we go\n        unsafe {\n            // Specialization workaround: See the comments in FftPlannerAvx::new() for why these calls to array_utils::workaround_transmute are necessary\n            let transmuted_input: &mut [Complex<A>] = array_utils::workaround_transmute_mut(input);\n            let transmuted_output: &mut [Complex<A>] =\n                array_utils::workaround_transmute_mut(output);\n            self.finalize_raders(transmuted_input, transmuted_output);\n        }\n    }"
}