{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `floyd_rivest::select_`",
    "file": "order-stat-0.1.3/src/floyd_rivest.rs",
    "start_line": 14,
    "start_col": 1,
    "end_line": 82,
    "end_col": 2,
    "code_snippet": "fn select_<T, F>(array: &mut [T], cmp: &mut F, mut left: usize, mut right: usize, k: usize)\n    where F: FnMut(&T, &T) -> cmp::Ordering\n{\n    let array = array;\n    while right > left {\n        if right - left > A {\n            let n = (right - left + 1) as f32;\n            let i = (k - left + 1) as f32;\n            let z = n.ln();\n            let s = B * (z * (2.0 / 3.0)).exp();\n            let sn = s / n;\n            let sd = B * (z * s * (1.0 - sn)).sqrt() * (i - n * 0.5).signum();\n\n            let isn = i * s / n;\n            let inner = k as f32 - isn + sd;\n            let new_left = cmp::max(left, inner as usize);\n            let new_right = cmp::min(right, (inner + s) as usize);\n\n            select_(array, cmp, new_left, new_right, k)\n        }\n\n        let mut i = left + 1;\n        let mut j = right - 1;\n        array.swap(left, k);\n        let t_idx = if cmp(&array[left], &array[right]) != cmp::Ordering::Less {\n            array.swap(left, right);\n            right\n        } else {\n            left\n        };\n\n        // need to cancel the borrow (but the assertion above ensures this doesn't alias)\n        let t = &array[t_idx] as *const _;\n        unsafe {\n            while cmp(&*array.get_unchecked(i), &*t) == Ordering::Less { i += 1 }\n            while cmp(&*array.get_unchecked(j), &*t) == Ordering::Greater { j -= 1 }\n        }\n\n        if i < j {\n            // i < j, and i and j move toward each other, so this\n            // assertion ensures that all indexing here is in-bounds.\n            assert!(j < array.len());\n\n            // FIXME: this unsafe code *should* be unnecessary: the\n            // assertions above mean that LLVM could theoretically\n            // optimise out the bounds checks, but it doesn't seem to\n            // at the moment (2015-04-25).\n            unsafe {\n                while i < j {\n                    ptr::swap(array.get_unchecked_mut(i),\n                              array.get_unchecked_mut(j));\n                    i += 1;\n                    j -= 1;\n                    while cmp(&*array.get_unchecked(i), &*t) == Ordering::Less { i += 1 }\n                    while cmp(&*array.get_unchecked(j), &*t) == Ordering::Greater { j -= 1 }\n                }\n            }\n        }\n\n        if left == t_idx {\n            array.swap(left, j);\n        } else {\n            j += 1;\n            array.swap(right, j);\n        }\n        if j <= k { left = j + 1 }\n        if k <= j { right = j.saturating_sub(1); }\n    }\n}"
}