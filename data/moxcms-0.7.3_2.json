{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `conversions::sse::lut4_to_3::TransformLut4To3Sse::<T, U, LAYOUT, GRID_SIZE, BIT_DEPTH, BINS, BARYCENTRIC_BINS>::transform_chunk`",
    "file": "moxcms-0.7.3/src/conversions/sse/lut4_to_3.rs",
    "start_line": 81,
    "start_col": 5,
    "end_line": 157,
    "end_col": 6,
    "code_snippet": "unsafe fn transform_chunk<'b, Interpolator: SseMdInterpolation<'b, GRID_SIZE>>(\n        &'b self,\n        src: &[T],\n        dst: &mut [T],\n    ) {\n        let cn = Layout::from(LAYOUT);\n        let channels = cn.channels();\n        let grid_size = GRID_SIZE as i32;\n        let grid_size3 = grid_size * grid_size * grid_size;\n\n        let value_scale = unsafe { _mm_set1_ps(((1 << BIT_DEPTH) - 1) as f32) };\n        let max_value = ((1 << BIT_DEPTH) - 1u32).as_();\n\n        for (src, dst) in src.chunks_exact(4).zip(dst.chunks_exact_mut(channels)) {\n            let c = <() as LutBarycentricReduction<T, U>>::reduce::<BIT_DEPTH, BARYCENTRIC_BINS>(\n                src[0],\n            );\n            let m = <() as LutBarycentricReduction<T, U>>::reduce::<BIT_DEPTH, BARYCENTRIC_BINS>(\n                src[1],\n            );\n            let y = <() as LutBarycentricReduction<T, U>>::reduce::<BIT_DEPTH, BARYCENTRIC_BINS>(\n                src[2],\n            );\n            let k = <() as LutBarycentricReduction<T, U>>::reduce::<BIT_DEPTH, BARYCENTRIC_BINS>(\n                src[3],\n            );\n\n            let k_weights = self.weights[k.as_()];\n\n            let w: i32 = k_weights.x;\n            let w_n: i32 = k_weights.x_n;\n            let t: f32 = k_weights.w;\n\n            let table1 = &self.lut[(w * grid_size3) as usize..];\n            let table2 = &self.lut[(w_n * grid_size3) as usize..];\n\n            let tetrahedral1 = Interpolator::new(table1);\n            let tetrahedral2 = Interpolator::new(table2);\n            let a0 = tetrahedral1.inter3_sse(c, m, y, &self.weights).v;\n            let b0 = tetrahedral2.inter3_sse(c, m, y, &self.weights).v;\n\n            if T::FINITE {\n                unsafe {\n                    let t0 = _mm_set1_ps(t);\n                    let ones = _mm_set1_ps(1f32);\n                    let hp = _mm_mul_ps(a0, _mm_sub_ps(ones, t0));\n                    let mut v = _mm_add_ps(_mm_mul_ps(b0, t0), hp);\n                    v = _mm_max_ps(v, _mm_setzero_ps());\n                    v = _mm_mul_ps(v, value_scale);\n                    v = _mm_min_ps(v, value_scale);\n                    let jvz = _mm_cvtps_epi32(v);\n\n                    let x = _mm_extract_epi32::<0>(jvz);\n                    let y = _mm_extract_epi32::<1>(jvz);\n                    let z = _mm_extract_epi32::<2>(jvz);\n\n                    dst[cn.r_i()] = (x as u32).as_();\n                    dst[cn.g_i()] = (y as u32).as_();\n                    dst[cn.b_i()] = (z as u32).as_();\n                }\n            } else {\n                unsafe {\n                    let t0 = _mm_set1_ps(t);\n                    let ones = _mm_set1_ps(1f32);\n                    let hp = _mm_mul_ps(a0, _mm_sub_ps(ones, t0));\n                    let v = _mm_add_ps(_mm_mul_ps(b0, t0), hp);\n\n                    dst[cn.r_i()] = f32::from_bits(_mm_extract_ps::<0>(v) as u32).as_();\n                    dst[cn.g_i()] = f32::from_bits(_mm_extract_ps::<1>(v) as u32).as_();\n                    dst[cn.b_i()] = f32::from_bits(_mm_extract_ps::<2>(v) as u32).as_();\n                }\n            }\n            if channels == 4 {\n                dst[cn.a_i()] = max_value;\n            }\n        }\n    }"
}