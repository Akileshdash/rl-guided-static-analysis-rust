{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "SliceFromRaw",
    "description": "Potential unsafe dataflow issue in `<bump_vec::drain::Drain<'_, T, A> as core::ops::Drop>::drop`",
    "file": "bump-scope-0.17.4/src/bump_vec/drain.rs",
    "start_line": 92,
    "start_col": 5,
    "end_line": 157,
    "end_col": 6,
    "code_snippet": "fn drop(&mut self) {\n        /// Moves back the un-`Drain`ed elements to restore the original vector.\n        struct DropGuard<'r, 'a, T, A: BumpAllocator>(&'r mut Drain<'a, T, A>);\n\n        impl<T, A: BumpAllocator> Drop for DropGuard<'_, '_, T, A> {\n            fn drop(&mut self) {\n                if self.0.tail_len > 0 {\n                    unsafe {\n                        let source_vec = self.0.vec.as_mut();\n                        // memmove back untouched tail, update to new length\n                        let start = source_vec.len();\n                        let tail = self.0.tail_start;\n                        if tail != start {\n                            let src = source_vec.as_ptr().add(tail);\n                            let dst = source_vec.as_mut_ptr().add(start);\n                            ptr::copy(src, dst, self.0.tail_len);\n                        }\n                        source_vec.set_len(start + self.0.tail_len);\n                    }\n                }\n            }\n        }\n\n        let iter = mem::replace(&mut self.iter, [].iter());\n        let drop_len = iter.len();\n\n        let mut vec = self.vec;\n\n        if T::IS_ZST {\n            // ZSTs have no identity, so we don't need to move them around, we only need to drop the correct amount.\n            // this can be achieved by manipulating the vector length instead of moving values out from `iter`.\n            unsafe {\n                let vec = vec.as_mut();\n                let old_len = vec.len();\n                vec.set_len(old_len + drop_len + self.tail_len);\n                vec.truncate(old_len + self.tail_len);\n            }\n\n            return;\n        }\n\n        // ensure elements are moved back into their appropriate places, even when drop_in_place panics\n        let _guard = DropGuard(self);\n\n        if drop_len == 0 {\n            return;\n        }\n\n        // as_slice() must only be called when iter.len() is > 0 because\n        // vec::Splice modifies vec::Drain fields and may grow the vec which would invalidate\n        // the iterator's internal pointers. Creating a reference to deallocated memory\n        // is invalid even when it is zero-length\n        let drop_ptr = iter.as_slice().as_ptr();\n\n        #[allow(clippy::cast_sign_loss)]\n        unsafe {\n            // drop_ptr comes from a slice::Iter which only gives us a &[T] but for drop_in_place\n            // a pointer with mutable provenance is necessary. Therefore we must reconstruct\n            // it from the original vec but also avoid creating a &mut to the front since that could\n            // invalidate raw pointers to it which some unsafe code might rely on.\n            let vec_ptr = vec.as_mut().as_mut_ptr();\n            let drop_offset = drop_ptr.offset_from(vec_ptr) as usize;\n            let to_drop = ptr::slice_from_raw_parts_mut(vec_ptr.add(drop_offset), drop_len);\n            ptr::drop_in_place(to_drop);\n        }\n    }"
}