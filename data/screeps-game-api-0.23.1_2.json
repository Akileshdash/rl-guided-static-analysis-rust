{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `objects::impls::room::FindPathOptions::<F, R>::into_js_options`",
    "file": "screeps-game-api-0.23.1/src/objects/impls/room.rs",
    "start_line": 631,
    "start_col": 5,
    "end_line": 711,
    "end_col": 6,
    "code_snippet": "pub(crate) fn into_js_options<CR>(self, callback: impl Fn(&JsFindPathOptions) -> CR) -> CR {\n        let mut raw_callback = self.cost_callback;\n\n        let mut owned_callback = move |room: RoomName, cost_matrix: CostMatrix| -> JsValue {\n            raw_callback(room, cost_matrix).into()\n        };\n\n        //\n        // Type erased and boxed callback: no longer a type specific to the closure\n        // passed in, now unified as &Fn\n        //\n\n        let callback_type_erased: &mut dyn FnMut(RoomName, CostMatrix) -> JsValue =\n            &mut owned_callback;\n\n        // Overwrite lifetime of reference so it can be passed to javascript.\n        // It's now pretending to be static data. This should be entirely safe\n        // because we control the only use of it and it remains valid during the\n        // pathfinder callback. This transmute is necessary because \"some lifetime\n        // above the current scope but otherwise unknown\" is not a valid lifetime.\n        //\n\n        let callback_lifetime_erased: &'static mut dyn FnMut(RoomName, CostMatrix) -> JsValue =\n            unsafe { std::mem::transmute(callback_type_erased) };\n\n        let boxed_callback = Box::new(move |room: JsString, cost_matrix: CostMatrix| -> JsValue {\n            let room = room\n                .try_into()\n                .expect(\"expected room name in cost callback\");\n\n            callback_lifetime_erased(room, cost_matrix)\n        }) as Box<dyn FnMut(JsString, CostMatrix) -> JsValue>;\n\n        let closure = Closure::wrap(boxed_callback);\n\n        //\n        // Create JS object and set properties.\n        //\n\n        let js_options = JsFindPathOptions::new();\n\n        js_options.cost_callback(&closure);\n\n        if let Some(ignore_creeps) = self.ignore_creeps {\n            js_options.ignore_creeps(ignore_creeps);\n        }\n\n        if let Some(ignore_destructible_structures) = self.ignore_destructible_structures {\n            js_options.ignore_destructible_structures(ignore_destructible_structures);\n        }\n\n        if let Some(max_ops) = self.max_ops {\n            js_options.max_ops(max_ops);\n        }\n\n        if let Some(heuristic_weight) = self.heuristic_weight {\n            js_options.heuristic_weight(heuristic_weight);\n        }\n\n        if let Some(serialize) = self.serialize {\n            js_options.serialize(serialize);\n        }\n\n        if let Some(max_rooms) = self.max_rooms {\n            js_options.max_rooms(max_rooms);\n        }\n\n        if let Some(range) = self.range {\n            js_options.range(range);\n        }\n\n        if let Some(plain_cost) = self.plain_cost {\n            js_options.plain_cost(plain_cost);\n        }\n\n        if let Some(swamp_cost) = self.swamp_cost {\n            js_options.swamp_cost(swamp_cost);\n        }\n\n        callback(&js_options)\n    }"
}