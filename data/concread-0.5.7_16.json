{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `internals::bptree::node::Branch::<K, V>::merge`",
    "file": "concread-0.5.7/src/internals/bptree/node.rs",
    "start_line": 1525,
    "start_col": 5,
    "end_line": 1561,
    "end_col": 6,
    "code_snippet": "pub(crate) fn merge(&mut self, right: &mut Self) {\n        debug_assert_branch!(self);\n        debug_assert_branch!(right);\n        let sc = self.count();\n        let rc = right.count();\n        if rc == 0 {\n            let node = right.nodes[0];\n            debug_assert!(!node.is_null());\n            let k: K = unsafe { &*Node::min_raw(node) }.clone();\n            let ins_idx = self.count();\n            let leaf_ins_idx = ins_idx + 1;\n            unsafe {\n                slice_insert(&mut self.key, MaybeUninit::new(k), ins_idx);\n                slice_insert(&mut self.nodes, node, leaf_ins_idx);\n            }\n            self.inc_count();\n        } else {\n            debug_assert!(sc == 0);\n            unsafe {\n                // Move all the nodes from right.\n                slice_merge(&mut self.nodes, 1, &mut right.nodes, rc + 1);\n                // Move the related keys.\n                slice_merge(&mut self.key, 1, &mut right.key, rc);\n            }\n            // Set our count correctly.\n            self.meta.set_count(rc + 1);\n            // Set right len to 0\n            right.meta.set_count(0);\n            // rekey the lowest pointer.\n            unsafe {\n                let nptr = self.nodes[1];\n                let k: K = { &*Node::min_raw(nptr) }.clone();\n                self.key[0].as_mut_ptr().write(k);\n            }\n            // done!\n        }\n    }"
}