{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<array::list::builder::ListArrayBuilder<O, B> as array::builder::StaticArrayBuilder>::opt_gather_extend`",
    "file": "polars-arrow-0.49.1/src/array/list/builder.rs",
    "start_line": 175,
    "start_col": 5,
    "end_line": 237,
    "end_col": 6,
    "code_snippet": "fn opt_gather_extend(&mut self, other: &ListArray<O>, idxs: &[IdxSize], share: ShareStrategy) {\n        let other_values = &**other.values();\n        let other_offsets = other.offsets();\n\n        unsafe {\n            // Pre-compute proper length for reserve.\n            let total_len: usize = idxs\n                .iter()\n                .map(|idx| {\n                    if (*idx as usize) < other.len() {\n                        let start = other_offsets.get_unchecked(*idx as usize).to_usize();\n                        let stop = other_offsets.get_unchecked(*idx as usize + 1).to_usize();\n                        stop - start\n                    } else {\n                        0\n                    }\n                })\n                .sum();\n            self.inner_builder.reserve(total_len);\n\n            // Group consecutive indices into larger copies.\n            let mut group_start = 0;\n            while group_start < idxs.len() {\n                let start_idx = idxs[group_start] as usize;\n                let mut group_len = 1;\n                let in_bounds = start_idx < other.len();\n\n                if in_bounds {\n                    while group_start + group_len < idxs.len()\n                        && idxs[group_start + group_len] as usize == start_idx + group_len\n                        && start_idx + group_len < other.len()\n                    {\n                        group_len += 1;\n                    }\n\n                    let start_offset = other_offsets.get_unchecked(start_idx).to_usize();\n                    let stop_offset = other_offsets\n                        .get_unchecked(start_idx + group_len)\n                        .to_usize();\n                    self.offsets\n                        .try_extend_from_slice(other_offsets, start_idx, group_len)\n                        .unwrap();\n                    self.inner_builder.subslice_extend(\n                        other_values,\n                        start_offset,\n                        stop_offset - start_offset,\n                        share,\n                    );\n                } else {\n                    while group_start + group_len < idxs.len()\n                        && idxs[group_start + group_len] as usize >= other.len()\n                    {\n                        group_len += 1;\n                    }\n                    self.offsets.extend_constant(group_len);\n                }\n                group_start += group_len;\n            }\n\n            self.validity\n                .opt_gather_extend_from_opt_validity(other.validity(), idxs, other.len());\n        }\n    }"
}