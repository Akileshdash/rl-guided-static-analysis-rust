{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `impl_::pymethods::_call_traverse`",
    "file": "pyo3-0.25.1/src/impl_/pymethods.rs",
    "start_line": 278,
    "start_col": 1,
    "end_line": 340,
    "end_col": 2,
    "code_snippet": "pub unsafe fn _call_traverse<T>(\n    slf: *mut ffi::PyObject,\n    impl_: fn(&T, PyVisit<'_>) -> Result<(), PyTraverseError>,\n    visit: ffi::visitproc,\n    arg: *mut c_void,\n    current_traverse: ffi::traverseproc,\n) -> c_int\nwhere\n    T: PyClass,\n{\n    // It is important the implementation of `__traverse__` cannot safely access the GIL,\n    // c.f. https://github.com/PyO3/pyo3/issues/3165, and hence we do not expose our GIL\n    // token to the user code and lock safe methods for acquiring the GIL.\n    // (This includes enforcing the `&self` method receiver as e.g. `PyRef<Self>` could\n    // reconstruct a GIL token via `PyRef::py`.)\n    // Since we do not create a `GILPool` at all, it is important that our usage of the GIL\n    // token does not produce any owned objects thereby calling into `register_owned`.\n    let trap = PanicTrap::new(\"uncaught panic inside __traverse__ handler\");\n    let lock = LockGIL::during_traverse();\n\n    let super_retval = unsafe { call_super_traverse(slf, visit, arg, current_traverse) };\n    if super_retval != 0 {\n        return super_retval;\n    }\n\n    // SAFETY: `slf` is a valid Python object pointer to a class object of type T, and\n    // traversal is running so no mutations can occur.\n    let class_object: &PyClassObject<T> = unsafe { &*slf.cast() };\n\n    let retval =\n    // `#[pyclass(unsendable)]` types can only be deallocated by their own thread, so\n    // do not traverse them if not on their owning thread :(\n    if class_object.check_threadsafe().is_ok()\n    // ... and we cannot traverse a type which might be being mutated by a Rust thread\n    && class_object.borrow_checker().try_borrow().is_ok() {\n        struct TraverseGuard<'a, T: PyClass>(&'a PyClassObject<T>);\n        impl<T: PyClass> Drop for TraverseGuard<'_,  T> {\n            fn drop(&mut self) {\n                self.0.borrow_checker().release_borrow()\n            }\n        }\n\n        // `.try_borrow()` above created a borrow, we need to release it when we're done\n        // traversing the object. This allows us to read `instance` safely.\n        let _guard = TraverseGuard(class_object);\n        let instance = unsafe {&*class_object.contents.value.get()};\n\n        let visit = PyVisit { visit, arg, _guard: PhantomData };\n\n        match catch_unwind(AssertUnwindSafe(move || impl_(instance, visit))) {\n            Ok(Ok(())) => 0,\n            Ok(Err(traverse_error)) => traverse_error.into_inner(),\n            Err(_err) => -1,\n        }\n    } else {\n        0\n    };\n\n    // Drop lock before trap just in case dropping lock panics\n    drop(lock);\n    trap.disarm();\n    retval\n}"
}