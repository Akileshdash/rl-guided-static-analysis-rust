{
    "level": "Warning",
    "analyzer": "UnsafeDataflow",
    "op_type": "ReadFlow",
    "description": "Potential unsafe dataflow issue in `adjust_heap`",
    "file": "partial_sort-1.0.0/src/lib.rs",
    "start_line": 93,
    "start_col": 1,
    "end_line": 158,
    "end_col": 2,
    "code_snippet": "fn adjust_heap<T, F>(v: &mut [T], hole_index: usize, len: usize, is_less: &mut F)\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n    assert!(len <= v.len());\n    assert!(hole_index < v.len());\n\n    let mut left_child = hole_index * 2 + 1;\n\n    // SAFETY: Reading from a reference is always valid. The original memory\n    // location is now conceptually moved-from. At the end of the function,\n    // or if `is_less()` panics at any point, `hole` is dropped and fills\n    // the moved-from location with a valid element.\n    let tmp = mem::ManuallyDrop::new(unsafe { ptr::read(&v[hole_index]) });\n    let mut hole = InsertionHole {\n        src: &*tmp,\n        dest: &mut v[hole_index],\n    };\n\n    while left_child < len {\n        if left_child + 1 < len {\n            left_child += usize::from(is_less(\n                unsafe { v.get_unchecked(left_child) }, // SAFETY: left_child < len\n                unsafe { v.get_unchecked(left_child + 1) }, // SAFETY: left_child + 1 < len\n            ));\n        }\n\n        // SAFETY: left_child (even incremented) is still in bounds.\n        if !is_less(&*tmp, unsafe { v.get_unchecked(left_child) }) {\n            break;\n        }\n\n        // SAFETY: Source and destination are references. Now the location\n        // at index left_child is conceptually moved-from and `hole` is updated\n        // accordingly. At the end of the function, or if `is_less()` panics\n        // at any point, `hole` is dropped and fills the moved-from location\n        // with a valid element.\n        unsafe {\n            ptr::copy_nonoverlapping(\n                v.get_unchecked(left_child), // SAFETY: still in bounds\n                hole.dest,\n                1,\n            );\n        }\n        hole.dest = &mut v[left_child];\n\n        left_child = left_child * 2 + 1;\n    }\n\n    // When dropped, copies from `src` into `dest`. Adapted from\n    // `std::sort_by()`.\n    struct InsertionHole<T> {\n        src: *const T,\n        dest: *mut T,\n    }\n\n    impl<T> Drop for InsertionHole<T> {\n        fn drop(&mut self) {\n            // SAFETY: `self.src` and `self.dest` have been created from\n            // references.\n            unsafe {\n                ptr::copy_nonoverlapping(self.src, self.dest, 1);\n            }\n        }\n    }\n}"
}