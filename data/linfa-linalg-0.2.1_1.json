{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `svd::svd`",
    "file": "linfa-linalg-0.2.1/src/svd.rs",
    "start_line": 17,
    "start_col": 1,
    "end_line": 224,
    "end_col": 2,
    "code_snippet": "fn svd<A: NdFloat, S: DataMut<Elem = A>>(\n    mut matrix: ArrayBase<S, Ix2>,\n    compute_u: bool,\n    compute_v: bool,\n    eps: A,\n) -> Result<(Option<Array2<A>>, Array1<A>, Option<Array2<A>>)> {\n    if matrix.is_empty() {\n        return Err(LinalgError::EmptyMatrix);\n    }\n    let (nrows, ncols) = matrix.dim();\n    let dim = nrows.min(ncols);\n\n    let amax = matrix\n        .iter()\n        .map(|f| f.abs())\n        .fold(A::neg_infinity(), |a, b| a.max(b));\n\n    if amax != A::zero() {\n        matrix /= amax;\n    }\n\n    let bidiag = matrix.bidiagonal()?;\n    let is_upper_diag = bidiag.is_upper_diag();\n    let mut u = compute_u.then(|| bidiag.generate_u());\n    let mut vt = compute_v.then(|| bidiag.generate_vt());\n    let (mut diag, mut off_diag) = bidiag.into_diagonals();\n\n    let (mut start, mut end) = delimit_subproblem(\n        &mut diag,\n        &mut off_diag,\n        &mut u,\n        &mut vt,\n        is_upper_diag,\n        dim - 1,\n        eps,\n    );\n\n    #[allow(clippy::comparison_chain)]\n    while end != start {\n        let subdim = end - start + 1;\n\n        if subdim > 2 {\n            let m = end - 1;\n            let n = end;\n\n            let mut vec = unsafe {\n                let dm = *diag.at(m);\n                let dn = *diag.at(n);\n                let fm = *off_diag.at(m);\n                let fm1 = *off_diag.at(m - 1);\n\n                let tmm = dm * dm + fm1 * fm1;\n                let tmn = dm * fm;\n                let tnn = dn * dn + fm * fm;\n                let shift = wilkinson_shift(tmm, tnn, tmn);\n\n                let ds = *diag.at(start);\n                (ds * ds - shift, ds * *off_diag.at(start))\n            };\n\n            for k in start..n {\n                let mut subm = unsafe {\n                    let m12 = if k == n - 1 {\n                        A::zero()\n                    } else {\n                        *off_diag.at(k + 1)\n                    };\n                    Array2::from_shape_vec(\n                        (2, 3),\n                        vec![\n                            *diag.at(k),\n                            *off_diag.at(k),\n                            A::zero(),\n                            A::zero(),\n                            *diag.at(k + 1),\n                            m12,\n                        ],\n                    )\n                    .unwrap()\n                };\n\n                if let Some((rot1, norm1)) = GivensRotation::cancel_y(vec.0, vec.1) {\n                    rot1.inverse()\n                        .rotate_rows(&mut subm.slice_mut(s![.., 0..=1]))\n                        .unwrap();\n\n                    let (rot2, norm2);\n                    unsafe {\n                        if k > start {\n                            *off_diag.atm(k - 1) = norm1;\n                        }\n\n                        let (v1, v2) = (*subm.at((0, 0)), *subm.at((1, 0)));\n                        if let Some((rot, norm)) = GivensRotation::cancel_y(v1, v2) {\n                            rot.rotate_cols(&mut subm.slice_mut(s![.., 1..=2])).unwrap();\n                            rot2 = Some(rot);\n                            norm2 = norm;\n                        } else {\n                            rot2 = None;\n                            norm2 = v1;\n                        };\n                        *subm.atm((0, 0)) = norm2;\n                    }\n\n                    if let Some(ref mut vt) = vt {\n                        if is_upper_diag {\n                            rot1.rotate_cols(&mut vt.slice_mut(s![k..k + 2, ..]))\n                                .unwrap();\n                        } else if let Some(rot2) = &rot2 {\n                            rot2.rotate_cols(&mut vt.slice_mut(s![k..k + 2, ..]))\n                                .unwrap();\n                        }\n                    }\n\n                    if let Some(ref mut u) = u {\n                        if !is_upper_diag {\n                            rot1.inverse()\n                                .rotate_rows(&mut u.slice_mut(s![.., k..k + 2]))\n                                .unwrap();\n                        } else if let Some(rot2) = &rot2 {\n                            rot2.inverse()\n                                .rotate_rows(&mut u.slice_mut(s![.., k..k + 2]))\n                                .unwrap();\n                        }\n                    }\n\n                    unsafe {\n                        *diag.atm(k) = *subm.at((0, 0));\n                        *diag.atm(k + 1) = *subm.at((1, 1));\n                        *off_diag.atm(k) = *subm.at((0, 1));\n                        if k != n - 1 {\n                            *off_diag.atm(k + 1) = *subm.at((1, 2));\n                        }\n                        vec.0 = *subm.at((0, 1));\n                        vec.1 = *subm.at((0, 2));\n                    }\n                } else {\n                    break;\n                }\n            }\n        } else if subdim == 2 {\n            // Solve 2x2 subproblem\n            let (rot_u, rot_v) = unsafe {\n                let (s1, s2, u2, v2) = compute_2x2_uptrig_svd(\n                    *diag.at(start),\n                    *off_diag.at(start),\n                    *diag.at(start + 1),\n                    compute_u && is_upper_diag || compute_v && !is_upper_diag,\n                    compute_v && is_upper_diag || compute_u && !is_upper_diag,\n                );\n                *diag.atm(start) = s1;\n                *diag.atm(start + 1) = s2;\n                *off_diag.atm(start) = A::zero();\n\n                if is_upper_diag {\n                    (u2, v2)\n                } else {\n                    (v2, u2)\n                }\n            };\n\n            if let Some(ref mut u) = u {\n                rot_u\n                    .unwrap()\n                    .rotate_rows(&mut u.slice_mut(s![.., start..start + 2]))\n                    .unwrap();\n            }\n\n            if let Some(ref mut vt) = vt {\n                rot_v\n                    .unwrap()\n                    .inverse()\n                    .rotate_cols(&mut vt.slice_mut(s![start..start + 2, ..]))\n                    .unwrap();\n            }\n\n            end -= 1;\n        }\n\n        // Re-delimit the subproblem in case some decoupling occurred.\n        let sub = delimit_subproblem(\n            &mut diag,\n            &mut off_diag,\n            &mut u,\n            &mut vt,\n            is_upper_diag,\n            end,\n            eps,\n        );\n        start = sub.0;\n        end = sub.1;\n    }\n\n    diag *= amax;\n\n    // Ensure singular values are positive\n    for i in 0..dim {\n        let val = diag[i];\n        if val.is_sign_negative() {\n            diag[i] = -val;\n            if let Some(u) = &mut u {\n                u.column_mut(i).mul_assign(-A::zero());\n            }\n        }\n    }\n\n    Ok((u, diag, vt))\n}"
}