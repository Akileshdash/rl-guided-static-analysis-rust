{
    "level": "Warning",
    "analyzer": "UnsafeDataflow",
    "op_type": "WriteFlow",
    "description": "Potential unsafe dataflow issue in `Arc::<HeaderSlice<H, T>>::from_header_and_iter_alloc`",
    "file": "servo_arc-0.4.1/lib.rs",
    "start_line": 764,
    "start_col": 5,
    "end_line": 846,
    "end_col": 6,
    "code_snippet": "pub fn from_header_and_iter_alloc<F, I>(\n        alloc: F,\n        header: H,\n        mut items: I,\n        num_items: usize,\n        is_static: bool,\n    ) -> Self\n    where\n        F: FnOnce(Layout) -> *mut u8,\n        I: Iterator<Item = T>,\n    {\n        assert_ne!(size_of::<T>(), 0, \"Need to think about ZST\");\n\n        let layout = Layout::new::<ArcInner<HeaderSlice<H, T>>>();\n        debug_assert!(layout.align() >= align_of::<T>());\n        debug_assert!(layout.align() >= align_of::<usize>());\n        let array_layout = Layout::array::<T>(num_items).expect(\"Overflow\");\n        let (layout, _offset) = layout.extend(array_layout).expect(\"Overflow\");\n        let p = unsafe {\n            // Allocate the buffer.\n            let buffer = alloc(layout);\n            let mut p = ptr::NonNull::new(buffer)\n                .unwrap_or_else(|| alloc::handle_alloc_error(layout))\n                .cast::<ArcInner<HeaderSlice<H, T>>>();\n\n            // Write the data.\n            //\n            // Note that any panics here (i.e. from the iterator) are safe, since\n            // we'll just leak the uninitialized memory.\n            let count = if is_static {\n                atomic::AtomicUsize::new(STATIC_REFCOUNT)\n            } else {\n                atomic::AtomicUsize::new(1)\n            };\n            ptr::write(&mut p.as_mut().count, count);\n            #[cfg(feature = \"track_alloc_size\")]\n            ptr::write(&mut p.as_mut().alloc_size, layout.size());\n            ptr::write(&mut p.as_mut().data.header, header);\n            ptr::write(&mut p.as_mut().data.len, num_items);\n            if num_items != 0 {\n                let mut current = std::ptr::addr_of_mut!(p.as_mut().data.data) as *mut T;\n                for _ in 0..num_items {\n                    ptr::write(\n                        current,\n                        items\n                            .next()\n                            .expect(\"ExactSizeIterator over-reported length\"),\n                    );\n                    current = current.offset(1);\n                }\n                // We should have consumed the buffer exactly, maybe accounting\n                // for some padding from the alignment.\n                debug_assert!(\n                    (buffer.add(layout.size()) as usize - current as *mut u8 as usize) < layout.align()\n                );\n            }\n            assert!(\n                items.next().is_none(),\n                \"ExactSizeIterator under-reported length\"\n            );\n            p\n        };\n        #[cfg(feature = \"gecko_refcount_logging\")]\n        unsafe {\n            if !is_static {\n                // FIXME(emilio): Would be so amazing to have\n                // std::intrinsics::type_name() around.\n                NS_LogCtor(p.as_ptr() as *mut _, b\"ServoArc\\0\".as_ptr() as *const _, 8)\n            }\n        }\n\n        // Return the fat Arc.\n        assert_eq!(\n            size_of::<Self>(),\n            size_of::<usize>(),\n            \"The Arc should be thin\"\n        );\n\n        Arc {\n            p,\n            phantom: PhantomData,\n        }\n    }"
}