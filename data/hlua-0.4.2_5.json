{
    "level": "Warning",
    "analyzer": "UnsafeDataflow",
    "op_type": "WriteFlow",
    "description": "Potential unsafe dataflow issue in `userdata::push_userdata`",
    "file": "hlua-0.4.2/src/userdata.rs",
    "start_line": 55,
    "start_col": 1,
    "end_line": 120,
    "end_col": 2,
    "code_snippet": "pub fn push_userdata<'lua, L, T, F>(data: T, mut lua: L, metatable: F) -> PushGuard<L>\n    where F: FnOnce(LuaTable<&mut PushGuard<&mut L>>),\n          L: AsMutLua<'lua>,\n          T: Send + 'static + Any\n{\n    unsafe {\n        let typeid = TypeId::of::<T>();\n\n        let lua_data = {\n            let tot_size = mem::size_of_val(&typeid) + mem::size_of_val(&data);\n            ffi::lua_newuserdata(lua.as_mut_lua().0, tot_size as libc::size_t)\n        };\n\n        // We check the alignment requirements.\n        debug_assert_eq!(lua_data as usize % mem::align_of_val(&data), 0);\n        // Since the size of a `TypeId` should always be a usize, this assert should pass every\n        // time as well.\n        debug_assert_eq!(mem::size_of_val(&typeid) % mem::align_of_val(&data), 0);\n\n        // We write the `TypeId` first, and the data right next to it.\n        ptr::write(lua_data as *mut TypeId, typeid);\n        let data_loc = (lua_data as *const u8).offset(mem::size_of_val(&typeid) as isize);\n        ptr::write(data_loc as *mut _, data);\n\n        let lua_raw = lua.as_mut_lua();\n\n        // Creating a metatable.\n        ffi::lua_newtable(lua.as_mut_lua().0);\n\n        // Index \"__gc\" in the metatable calls the object's destructor.\n\n        // TODO: Could use std::intrinsics::needs_drop to avoid that if not needed.\n        // After some discussion on IRC, it would be acceptable to add a reexport in libcore\n        // without going through the RFC process.\n        {\n            match \"__gc\".push_to_lua(&mut lua) {\n                Ok(p) => p.forget(),\n                Err(_) => unreachable!(),\n            };\n\n            ffi::lua_pushcfunction(lua.as_mut_lua().0, destructor_wrapper::<T>);\n            ffi::lua_settable(lua.as_mut_lua().0, -3);\n        }\n\n        // Calling the metatable closure.\n        {\n            let raw_lua = lua.as_lua();\n            let mut guard = PushGuard {\n                lua: &mut lua,\n                size: 1,\n                raw_lua: raw_lua,\n            };\n            metatable(LuaRead::lua_read(&mut guard).ok().unwrap());\n            guard.forget();\n        }\n\n        ffi::lua_setmetatable(lua_raw.0, -2);\n    }\n\n    let raw_lua = lua.as_lua();\n    PushGuard {\n        lua: lua,\n        size: 1,\n        raw_lua: raw_lua,\n    }\n}"
}