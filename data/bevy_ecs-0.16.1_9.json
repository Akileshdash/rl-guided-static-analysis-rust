{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `world::entity_ref::EntityWorldMut::<'w>::take`",
    "file": "bevy_ecs-0.16.1/src/world/entity_ref.rs",
    "start_line": 1984,
    "start_col": 5,
    "end_line": 2083,
    "end_col": 6,
    "code_snippet": "pub fn take<T: Bundle + BundleFromComponents>(&mut self) -> Option<T> {\n        self.assert_not_despawned();\n        let world = &mut self.world;\n        let storages = &mut world.storages;\n        // SAFETY: These come from the same world.\n        let mut registrator =\n            unsafe { ComponentsRegistrator::new(&mut world.components, &mut world.component_ids) };\n        let bundle_id = world.bundles.register_info::<T>(&mut registrator, storages);\n        // SAFETY: We just ensured this bundle exists\n        let bundle_info = unsafe { world.bundles.get_unchecked(bundle_id) };\n        let old_location = self.location;\n        // SAFETY: `archetype_id` exists because it is referenced in the old `EntityLocation` which is valid,\n        // components exist in `bundle_info` because `Bundles::init_info` initializes a `BundleInfo` containing all components of the bundle type `T`\n        let new_archetype_id = unsafe {\n            bundle_info.remove_bundle_from_archetype(\n                &mut world.archetypes,\n                storages,\n                &registrator,\n                &world.observers,\n                old_location.archetype_id,\n                false,\n            )?\n        };\n\n        if new_archetype_id == old_location.archetype_id {\n            return None;\n        }\n\n        let entity = self.entity;\n        // SAFETY: Archetypes and Bundles cannot be mutably aliased through DeferredWorld\n        let (old_archetype, bundle_info, mut deferred_world) = unsafe {\n            let bundle_info: *const BundleInfo = bundle_info;\n            let world = world.as_unsafe_world_cell();\n            (\n                &world.archetypes()[old_location.archetype_id],\n                &*bundle_info,\n                world.into_deferred(),\n            )\n        };\n\n        // SAFETY: all bundle components exist in World\n        unsafe {\n            trigger_on_replace_and_on_remove_hooks_and_observers(\n                &mut deferred_world,\n                old_archetype,\n                entity,\n                bundle_info,\n                MaybeLocation::caller(),\n            );\n        }\n\n        let archetypes = &mut world.archetypes;\n        let storages = &mut world.storages;\n        let components = &mut world.components;\n        let entities = &mut world.entities;\n        let removed_components = &mut world.removed_components;\n\n        let entity = self.entity;\n        let mut bundle_components = bundle_info.iter_explicit_components();\n        // SAFETY: bundle components are iterated in order, which guarantees that the component type\n        // matches\n        let result = unsafe {\n            T::from_components(storages, &mut |storages| {\n                let component_id = bundle_components.next().unwrap();\n                // SAFETY:\n                // - entity location is valid\n                // - table row is removed below, without dropping the contents\n                // - `components` comes from the same world as `storages`\n                // - the component exists on the entity\n                take_component(\n                    storages,\n                    components,\n                    removed_components,\n                    component_id,\n                    entity,\n                    old_location,\n                )\n            })\n        };\n\n        #[expect(\n            clippy::undocumented_unsafe_blocks,\n            reason = \"Needs to be documented; see #17345.\"\n        )]\n        unsafe {\n            Self::move_entity_from_remove::<false>(\n                entity,\n                &mut self.location,\n                old_location.archetype_id,\n                old_location,\n                entities,\n                archetypes,\n                storages,\n                new_archetype_id,\n            );\n        }\n        self.world.flush();\n        self.update_location();\n        Some(result)\n    }"
}