{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<serialize_packed::PackedRead<R> as io::Read>::read`",
    "file": "capnp-0.21.4/src/serialize_packed.rs",
    "start_line": 80,
    "start_col": 5,
    "end_line": 228,
    "end_col": 6,
    "code_snippet": "fn read(&mut self, out_buf: &mut [u8]) -> Result<usize> {\n        let len = out_buf.len();\n        if len == 0 {\n            return Ok(0);\n        }\n\n        assert!(len % 8 == 0, \"PackedRead reads must be word-aligned.\");\n\n        unsafe {\n            let out_buf_start = out_buf.as_mut_ptr();\n            let mut out = out_buf_start;\n            let out_end: *mut u8 = out.wrapping_add(len);\n\n            let (mut in_ptr, mut in_end) = self.get_read_buffer()?;\n            let mut buffer_begin = in_ptr;\n            let mut size = ptr_sub(in_end, in_ptr);\n            if size == 0 {\n                return Ok(0);\n            }\n\n            loop {\n                let tag: u8;\n\n                assert_eq!(\n                    ptr_sub(out, out_buf_start) % 8,\n                    0,\n                    \"Output pointer should always be aligned here.\"\n                );\n\n                if ptr_sub(in_end, in_ptr) < 10 {\n                    if ptr_sub(in_end, in_ptr) == 0 {\n                        refresh_buffer!(self, size, in_ptr, in_end, out, out_buf, buffer_begin);\n                        continue;\n                    }\n\n                    //# We have at least 1, but not 10, bytes available. We need to read\n                    //# slowly, doing a bounds check on each byte.\n\n                    tag = *in_ptr;\n                    in_ptr = in_ptr.offset(1);\n\n                    for i in 0..8 {\n                        if (tag & (1u8 << i)) != 0 {\n                            if ptr_sub(in_end, in_ptr) == 0 {\n                                refresh_buffer!(\n                                    self,\n                                    size,\n                                    in_ptr,\n                                    in_end,\n                                    out,\n                                    out_buf,\n                                    buffer_begin\n                                );\n                            }\n                            *out = *in_ptr;\n                            out = out.offset(1);\n                            in_ptr = in_ptr.offset(1);\n                        } else {\n                            *out = 0;\n                            out = out.offset(1);\n                        }\n                    }\n\n                    if ptr_sub(in_end, in_ptr) == 0 && (tag == 0 || tag == 0xff) {\n                        refresh_buffer!(self, size, in_ptr, in_end, out, out_buf, buffer_begin);\n                    }\n                } else {\n                    tag = *in_ptr;\n                    in_ptr = in_ptr.offset(1);\n\n                    for n in 0..8 {\n                        let is_nonzero = (tag & (1u8 << n)) != 0;\n                        *out = (*in_ptr) & ((-i8::from(is_nonzero)) as u8);\n                        out = out.offset(1);\n                        in_ptr = in_ptr.offset(isize::from(is_nonzero));\n                    }\n                }\n                if tag == 0 {\n                    assert!(\n                        ptr_sub(in_end, in_ptr) > 0,\n                        \"Should always have non-empty buffer here.\"\n                    );\n\n                    let run_length: usize = (*in_ptr) as usize * 8;\n                    in_ptr = in_ptr.offset(1);\n\n                    if run_length > ptr_sub(out_end, out) {\n                        return Err(Error::from_kind(\n                            ErrorKind::PackedInputDidNotEndCleanlyOnASegmentBoundary,\n                        ));\n                    }\n\n                    ptr::write_bytes(out, 0, run_length);\n                    out = out.add(run_length);\n                } else if tag == 0xff {\n                    assert!(\n                        ptr_sub(in_end, in_ptr) > 0,\n                        \"Should always have non-empty buffer here\"\n                    );\n\n                    let mut run_length: usize = (*in_ptr) as usize * 8;\n                    in_ptr = in_ptr.offset(1);\n\n                    if run_length > ptr_sub(out_end, out) {\n                        return Err(Error::from_kind(\n                            ErrorKind::PackedInputDidNotEndCleanlyOnASegmentBoundary,\n                        ));\n                    }\n\n                    let in_remaining = ptr_sub(in_end, in_ptr);\n                    if in_remaining >= run_length {\n                        //# Fast path.\n                        ptr::copy_nonoverlapping(in_ptr, out, run_length);\n                        out = out.add(run_length);\n                        in_ptr = in_ptr.add(run_length);\n                    } else {\n                        //# Copy over the first buffer, then do one big read for the rest.\n                        ptr::copy_nonoverlapping(in_ptr, out, in_remaining);\n                        out = out.add(in_remaining);\n                        run_length -= in_remaining;\n\n                        self.inner.consume(size);\n                        {\n                            let buf = slice::from_raw_parts_mut::<u8>(out, run_length);\n                            self.inner.read_exact(buf)?;\n                        }\n\n                        out = out.add(run_length);\n\n                        if out == out_end {\n                            return Ok(len);\n                        } else {\n                            let (b, e) = self.get_read_buffer()?;\n                            in_ptr = b;\n                            in_end = e;\n                            size = ptr_sub(e, b);\n                            buffer_begin = in_ptr;\n                            continue;\n                        }\n                    }\n                }\n\n                if out == out_end {\n                    self.inner.consume(ptr_sub(in_ptr, buffer_begin));\n                    return Ok(len);\n                }\n            }\n        }\n    }"
}