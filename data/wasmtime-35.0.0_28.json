{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "SliceFromRaw",
    "description": "Potential unsafe dataflow issue in `runtime::component::func::Func::call_raw`",
    "file": "wasmtime-35.0.0/src/runtime/component/func.rs",
    "start_line": 365,
    "start_col": 5,
    "end_line": 500,
    "end_col": 6,
    "code_snippet": "fn call_raw<T, Params: ?Sized, Return, LowerParams, LowerReturn>(\n        &self,\n        store: &mut StoreContextMut<'_, T>,\n        params: &Params,\n        lower: impl FnOnce(\n            &mut LowerContext<'_, T>,\n            &Params,\n            InterfaceType,\n            &mut MaybeUninit<LowerParams>,\n        ) -> Result<()>,\n        lift: impl FnOnce(&mut LiftContext<'_>, InterfaceType, &LowerReturn) -> Result<Return>,\n    ) -> Result<Return>\n    where\n        LowerParams: Copy,\n        LowerReturn: Copy,\n    {\n        let vminstance = self.instance.id().get(store.0);\n        let component = vminstance.component().clone();\n        let (ty, def, options) = component.export_lifted_function(self.index);\n\n        let mem_opts = match options.data_model {\n            CanonicalOptionsDataModel::Gc {} => todo!(\"CM+GC\"),\n            CanonicalOptionsDataModel::LinearMemory(opts) => opts,\n        };\n\n        let export = match self.instance.lookup_vmdef(store.0, def) {\n            Export::Function(f) => f,\n            _ => unreachable!(),\n        };\n        let vminstance = self.instance.id().get(store.0);\n        let component_instance = options.instance;\n        let memory = mem_opts\n            .memory\n            .map(|i| NonNull::new(vminstance.runtime_memory(i)).unwrap());\n        let realloc = mem_opts.realloc.map(|i| vminstance.runtime_realloc(i));\n        let options =\n            unsafe { Options::new(store.0.id(), memory, realloc, options.string_encoding) };\n\n        let space = &mut MaybeUninit::<ParamsAndResults<LowerParams, LowerReturn>>::uninit();\n\n        // Double-check the size/alignment of `space`, just in case.\n        //\n        // Note that this alone is not enough to guarantee the validity of the\n        // `unsafe` block below, but it's definitely required. In any case LLVM\n        // should be able to trivially see through these assertions and remove\n        // them in release mode.\n        let val_size = mem::size_of::<ValRaw>();\n        let val_align = mem::align_of::<ValRaw>();\n        assert!(mem::size_of_val(space) % val_size == 0);\n        assert!(mem::size_of_val(map_maybe_uninit!(space.params)) % val_size == 0);\n        assert!(mem::size_of_val(map_maybe_uninit!(space.ret)) % val_size == 0);\n        assert!(mem::align_of_val(space) == val_align);\n        assert!(mem::align_of_val(map_maybe_uninit!(space.params)) == val_align);\n        assert!(mem::align_of_val(map_maybe_uninit!(space.ret)) == val_align);\n\n        let types = component.types();\n        let mut flags = vminstance.instance_flags(component_instance);\n\n        unsafe {\n            // Test the \"may enter\" flag which is a \"lock\" on this instance.\n            // This is immediately set to `false` afterwards and note that\n            // there's no on-cleanup setting this flag back to true. That's an\n            // intentional design aspect where if anything goes wrong internally\n            // from this point on the instance is considered \"poisoned\" and can\n            // never be entered again. The only time this flag is set to `true`\n            // again is after post-return logic has completed successfully.\n            if !flags.may_enter() {\n                bail!(crate::Trap::CannotEnterComponent);\n            }\n            flags.set_may_enter(false);\n\n            debug_assert!(flags.may_leave());\n            flags.set_may_leave(false);\n            let mut cx = LowerContext::new(store.as_context_mut(), &options, &types, self.instance);\n            cx.enter_call();\n            let result = lower(\n                &mut cx,\n                params,\n                InterfaceType::Tuple(types[ty].params),\n                map_maybe_uninit!(space.params),\n            );\n            flags.set_may_leave(true);\n            result?;\n\n            // This is unsafe as we are providing the guarantee that all the\n            // inputs are valid. The various pointers passed in for the function\n            // are all valid since they're coming from our store, and the\n            // `params_and_results` should have the correct layout for the core\n            // wasm function we're calling. Note that this latter point relies\n            // on the correctness of this module and `ComponentType`\n            // implementations, hence `ComponentType` being an `unsafe` trait.\n            crate::Func::call_unchecked_raw(\n                store,\n                export.func_ref,\n                NonNull::new(core::ptr::slice_from_raw_parts_mut(\n                    space.as_mut_ptr().cast(),\n                    mem::size_of_val(space) / mem::size_of::<ValRaw>(),\n                ))\n                .unwrap(),\n            )?;\n\n            // Note that `.assume_init_ref()` here is unsafe but we're relying\n            // on the correctness of the structure of `LowerReturn` and the\n            // type-checking performed to acquire the `TypedFunc` to make this\n            // safe. It should be the case that `LowerReturn` is the exact\n            // representation of the return value when interpreted as\n            // `[ValRaw]`, and additionally they should have the correct types\n            // for the function we just called (which filled in the return\n            // values).\n            let ret = map_maybe_uninit!(space.ret).assume_init_ref();\n\n            // Lift the result into the host while managing post-return state\n            // here as well.\n            //\n            // After a successful lift the return value of the function, which\n            // is currently required to be 0 or 1 values according to the\n            // canonical ABI, is saved within the `Store`'s `FuncData`. This'll\n            // later get used in post-return.\n            flags.set_needs_post_return(true);\n            let val = lift(\n                &mut LiftContext::new(store.0, &options, &types, self.instance),\n                InterfaceType::Tuple(types[ty].results),\n                ret,\n            )?;\n            let ret_slice = storage_as_slice(ret);\n            self.instance.id().get_mut(store.0).post_return_arg_set(\n                self.index,\n                match ret_slice.len() {\n                    0 => ValRaw::i32(0),\n                    1 => ret_slice[0],\n                    _ => unreachable!(),\n                },\n            );\n            return Ok(val);\n        }\n    }"
}