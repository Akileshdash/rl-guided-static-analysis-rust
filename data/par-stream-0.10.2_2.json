{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<shared_stream::Shared<St> as futures::Stream>::poll_next`",
    "file": "par-stream-0.10.2/src/shared_stream.rs",
    "start_line": 203,
    "start_col": 5,
    "end_line": 304,
    "end_col": 6,
    "code_snippet": "fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n        let this = &mut *self;\n\n        // Return end of stream if polled again after completion\n        let inner = match this.inner.take() {\n            Some(inner) => inner,\n            None => {\n                return Ready(None);\n            }\n        };\n\n        // Fast path for when the wrapped stream has already completed\n        if inner.state.load(Acquire) == COMPLETE {\n            return Ready(None);\n        }\n\n        // Make sure a waker key is registered for this waker.\n        inner.record_waker(&mut this.waker_key, cx);\n\n        // Transfer state: IDLE -> POLLING\n        match inner\n            .state\n            .compare_exchange(IDLE, POLLING, SeqCst, SeqCst)\n            .unwrap_or_else(|x| x)\n        {\n            IDLE => {\n                // Lock acquired, fall through\n            }\n            POLLING => {\n                // Another task is currently polling, at this point we just want\n                // to ensure that the waker for this task is registered\n                inner.notifier.register_pending(this.waker_key);\n                this.inner = Some(inner);\n                return Pending;\n            }\n            COMPLETE => {\n                return Ready(None);\n            }\n            POISONED => panic!(\"inner stream panicked during poll\"),\n            _ => unreachable!(),\n        }\n\n        /* start of critical section (to the end of function) */\n\n        // the guard marks poisoned state when dropping if panic happened\n        let _reset = Reset(&inner.state);\n\n        // create context for underlying stream\n        let waker = waker_ref(&inner.notifier);\n        let mut stream_cx = Context::from_waker(&waker);\n\n        // get stream reference\n        let stream = unsafe {\n            let stream = &mut *inner.stream.get();\n            Pin::new_unchecked(stream)\n        };\n\n        // remember the wake count before polling\n        let wake_count = inner.notifier.wake_count();\n\n        match stream.poll_next(&mut stream_cx) {\n            Pending => {\n                // Transfer state: POLLING -> IDLE\n                inner.state.store(IDLE, SeqCst);\n\n                // Register the waker key to pending list.\n                let should_wake = inner\n                    .notifier\n                    .wake_or_register_pending(this.waker_key, wake_count);\n\n                // If the wake_count changed, indicating the stream wakes earlier, wake itself.\n                if should_wake {\n                    cx.waker().wake_by_ref();\n                }\n\n                drop(_reset);\n                this.inner = Some(inner);\n                Pending\n            }\n            Ready(Some(item)) => {\n                // Transfer state: POLLING -> IDLE\n                inner.state.store(IDLE, SeqCst);\n\n                // Wake pending tasks\n                inner.notifier.notify();\n\n                drop(_reset); // Make borrow checker happy\n                this.inner = Some(inner);\n                Ready(Some(item))\n            }\n            Ready(None) => {\n                // Transfer state: POLLING -> COMPLETE\n                inner.state.store(COMPLETE, SeqCst);\n\n                // Wake all tasks\n                inner.notifier.close(this.waker_key);\n                drop(_reset); // Make borrow checker happy\n\n                Ready(None)\n            }\n        }\n    }"
}