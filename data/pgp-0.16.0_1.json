{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `packet::signature::types::Signature::verify_third_party_certification`",
    "file": "pgp-0.16.0/src/packet/signature/types.rs",
    "start_line": 425,
    "start_col": 5,
    "end_line": 511,
    "end_col": 6,
    "code_snippet": "pub fn verify_third_party_certification<P, K>(\n        &self,\n        signee: &P,\n        signer: &K,\n        tag: Tag,\n        id: &impl Serialize,\n    ) -> Result<()>\n    where\n        P: PublicKeyTrait + Serialize,\n        K: PublicKeyTrait + Serialize,\n    {\n        let InnerSignature::Known {\n            ref config,\n            ref signed_hash_value,\n            ref signature,\n        } = self.inner\n        else {\n            unsupported_err!(\"signature version {:?}\", self.version());\n        };\n        let key_id = signee.key_id();\n        debug!(\"verifying certification {:?} {:#?}\", key_id, self);\n\n        Self::check_signature_key_version_alignment(&signer, config)?;\n        Self::check_signature_hash_strength(config)?;\n\n        ensure!(\n            Self::match_identity(self, signer),\n            \"verify_certification: No matching issuer or issuer_fingerprint for Key ID: {:?}\",\n            key_id,\n        );\n\n        let mut hasher = config.hash_alg.new_hasher()?;\n\n        if let SignatureVersionSpecific::V6 { salt } = &config.version_specific {\n            hasher.update(salt.as_ref())\n        }\n\n        // the key of the signee\n        {\n            // TODO: this is different for V5\n            serialize_for_hashing(signee, &mut hasher)?;\n        }\n\n        // the packet content\n        {\n            let packet_len = id.write_len();\n\n            match config.version() {\n                SignatureVersion::V2 | SignatureVersion::V3 => {\n                    // Nothing to do\n                }\n                SignatureVersion::V4 | SignatureVersion::V6 => {\n                    let prefix = match tag {\n                        Tag::UserId => 0xB4,\n                        Tag::UserAttribute => 0xD1,\n                        _ => bail!(\"invalid tag for certification validation: {:?}\", tag),\n                    };\n\n                    let mut prefix_buf = [prefix, 0u8, 0u8, 0u8, 0u8];\n                    BigEndian::write_u32(&mut prefix_buf[1..], packet_len.try_into()?);\n\n                    // prefixes\n                    hasher.update(&prefix_buf);\n                }\n                SignatureVersion::V5 => {\n                    bail!(\"v5 signature unsupported tpc\")\n                }\n                SignatureVersion::Other(version) => {\n                    bail!(\"unsupported signature version: {:?}\", version)\n                }\n            }\n\n            id.to_writer(&mut WriteHasher(&mut hasher))?;\n        }\n\n        let len = config.hash_signature_data(&mut hasher)?;\n        hasher.update(&config.trailer(len)?);\n\n        let hash = &hasher.finalize()[..];\n        ensure_eq!(\n            signed_hash_value,\n            &hash[0..2],\n            \"certification: invalid signed hash value\"\n        );\n\n        signer.verify_signature(config.hash_alg, hash, signature)\n    }"
}