{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `map::bucket_array_ref::BucketArrayRef::<'a, K, V, S>::remove_entry_if_and`",
    "file": "cht-0.5.0/src/map/bucket_array_ref.rs",
    "start_line": 130,
    "start_col": 5,
    "end_line": 179,
    "end_col": 6,
    "code_snippet": "pub(crate) fn remove_entry_if_and<\n        Q: Hash + Eq + ?Sized,\n        F: FnMut(&K, &V) -> bool,\n        G: FnOnce(&K, &V) -> T,\n        T,\n    >(\n        &self,\n        key: &Q,\n        hash: u64,\n        mut condition: F,\n        with_previous_entry: G,\n    ) -> Option<T>\n    where\n        K: Borrow<Q>,\n    {\n        let guard = &crossbeam_epoch::pin();\n        let current_ref = self.get(guard);\n        let mut bucket_array_ref = current_ref;\n\n        let result;\n\n        loop {\n            match bucket_array_ref.remove_if(guard, hash, key, condition) {\n                Ok(previous_bucket_ptr) => {\n                    if let Some(previous_bucket_ref) = unsafe { previous_bucket_ptr.as_ref() } {\n                        let Bucket {\n                            key,\n                            maybe_value: value,\n                        } = previous_bucket_ref;\n                        self.len.fetch_sub(1, Ordering::Relaxed);\n                        result = Some(with_previous_entry(key, unsafe { &*value.as_ptr() }));\n\n                        unsafe { bucket::defer_destroy_tombstone(guard, previous_bucket_ptr) };\n                    } else {\n                        result = None;\n                    }\n\n                    break;\n                }\n                Err(c) => {\n                    condition = c;\n                    bucket_array_ref = bucket_array_ref.rehash(guard, self.build_hasher);\n                }\n            }\n        }\n\n        self.swing(guard, current_ref, bucket_array_ref);\n\n        result\n    }"
}