{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `value::impl_map::<impl value::Value<Type>>::try_extract_key_values`",
    "file": "ort-2.0.0-rc.10/src/value/impl_map.rs",
    "start_line": 88,
    "start_col": 2,
    "end_line": 188,
    "end_col": 3,
    "code_snippet": "pub fn try_extract_key_values<K: IntoTensorElementType + Clone + Hash + Eq, V: PrimitiveTensorElementType + Clone>(&self) -> Result<Vec<(K, V)>> {\n\t\tmatch self.dtype() {\n\t\t\tValueType::Map { key, value } => {\n\t\t\t\tlet k_type = K::into_tensor_element_type();\n\t\t\t\tif k_type != *key {\n\t\t\t\t\treturn Err(Error::new_with_code(ErrorCode::InvalidArgument, format!(\"Cannot extract Map<{:?}, _> (value has K type {:?})\", k_type, key)));\n\t\t\t\t}\n\t\t\t\tlet v_type = V::into_tensor_element_type();\n\t\t\t\tif v_type != *value {\n\t\t\t\t\treturn Err(Error::new_with_code(\n\t\t\t\t\t\tErrorCode::InvalidArgument,\n\t\t\t\t\t\tformat!(\"Cannot extract Map<{}, {}> from Map<{}, {}>\", K::into_tensor_element_type(), V::into_tensor_element_type(), k_type, v_type)\n\t\t\t\t\t));\n\t\t\t\t}\n\n\t\t\t\tlet allocator = Allocator::default();\n\n\t\t\t\tlet mut key_tensor_ptr = ptr::null_mut();\n\t\t\t\tortsys![unsafe GetValue(self.ptr(), 0, allocator.ptr().cast_mut(), &mut key_tensor_ptr)?; nonNull(key_tensor_ptr)];\n\t\t\t\tlet key_value: DynTensor = unsafe { Value::from_ptr(key_tensor_ptr, None) };\n\t\t\t\tif K::into_tensor_element_type() != TensorElementType::String {\n\t\t\t\t\tlet dtype = key_value.dtype();\n\t\t\t\t\tlet (key_tensor_shape, key_tensor) = match dtype {\n\t\t\t\t\t\tValueType::Tensor { ty, shape, .. } => {\n\t\t\t\t\t\t\tlet mem = key_value.memory_info();\n\t\t\t\t\t\t\tif !mem.is_cpu_accessible() {\n\t\t\t\t\t\t\t\treturn Err(Error::new(format!(\n\t\t\t\t\t\t\t\t\t\"Cannot extract from value on device `{}`, which is not CPU accessible\",\n\t\t\t\t\t\t\t\t\tmem.allocation_device().as_str()\n\t\t\t\t\t\t\t\t)));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif *ty == K::into_tensor_element_type() {\n\t\t\t\t\t\t\t\tlet mut output_array_ptr: *mut K = ptr::null_mut();\n\t\t\t\t\t\t\t\tlet output_array_ptr_ptr: *mut *mut K = &mut output_array_ptr;\n\t\t\t\t\t\t\t\tlet output_array_ptr_ptr_void: *mut *mut c_void = output_array_ptr_ptr.cast();\n\t\t\t\t\t\t\t\tortsys![unsafe GetTensorMutableData(key_tensor_ptr.as_ptr(), output_array_ptr_ptr_void)?];\n\t\t\t\t\t\t\t\tif output_array_ptr.is_null() {\n\t\t\t\t\t\t\t\t\toutput_array_ptr = NonNull::dangling().as_ptr();\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t(shape, unsafe { slice::from_raw_parts(output_array_ptr, shape.num_elements()) })\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn Err(Error::new_with_code(\n\t\t\t\t\t\t\t\t\tErrorCode::InvalidArgument,\n\t\t\t\t\t\t\t\t\tformat!(\n\t\t\t\t\t\t\t\t\t\t\"Cannot extract Map<{}, {}> from Map<{}, {}>\",\n\t\t\t\t\t\t\t\t\t\tK::into_tensor_element_type(),\n\t\t\t\t\t\t\t\t\t\tV::into_tensor_element_type(),\n\t\t\t\t\t\t\t\t\t\tk_type,\n\t\t\t\t\t\t\t\t\t\tv_type\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_ => unreachable!()\n\t\t\t\t\t};\n\n\t\t\t\t\tlet mut value_tensor_ptr = ptr::null_mut();\n\t\t\t\t\tortsys![unsafe GetValue(self.ptr(), 1, allocator.ptr().cast_mut(), &mut value_tensor_ptr)?; nonNull(value_tensor_ptr)];\n\t\t\t\t\tlet value_value: DynTensor = unsafe { Value::from_ptr(value_tensor_ptr, None) };\n\t\t\t\t\tlet (value_tensor_shape, value_tensor) = value_value.try_extract_tensor::<V>()?;\n\n\t\t\t\t\tassert_eq!(key_tensor_shape.len(), 1);\n\t\t\t\t\tassert_eq!(value_tensor_shape.len(), 1);\n\t\t\t\t\tassert_eq!(key_tensor_shape[0], value_tensor_shape[0]);\n\n\t\t\t\t\tlet mut vec = Vec::with_capacity(key_tensor_shape[0] as _);\n\t\t\t\t\tfor i in 0..key_tensor_shape[0] as usize {\n\t\t\t\t\t\tvec.push((key_tensor[i].clone(), value_tensor[i].clone()));\n\t\t\t\t\t}\n\t\t\t\t\tOk(vec)\n\t\t\t\t} else {\n\t\t\t\t\tlet (key_tensor_shape, key_tensor) = key_value.try_extract_strings()?;\n\t\t\t\t\t// SAFETY: `IntoTensorElementType` is a private trait, and we only map the `String` type to `TensorElementType::String`,\n\t\t\t\t\t// so at this point, `K` is **always** the `String` type, and this transmute really does nothing but please the type\n\t\t\t\t\t// checker.\n\t\t\t\t\tlet key_tensor: Vec<K> = unsafe { mem::transmute(key_tensor) };\n\n\t\t\t\t\tlet mut value_tensor_ptr = ptr::null_mut();\n\t\t\t\t\tortsys![unsafe GetValue(self.ptr(), 1, allocator.ptr().cast_mut(), &mut value_tensor_ptr)?; nonNull(value_tensor_ptr)];\n\t\t\t\t\tlet value_value: DynTensor = unsafe { Value::from_ptr(value_tensor_ptr, None) };\n\t\t\t\t\tlet (value_tensor_shape, value_tensor) = value_value.try_extract_tensor::<V>()?;\n\n\t\t\t\t\tassert_eq!(key_tensor_shape.len(), 1);\n\t\t\t\t\tassert_eq!(value_tensor_shape.len(), 1);\n\t\t\t\t\tassert_eq!(key_tensor_shape[0], value_tensor_shape[0]);\n\n\t\t\t\t\tlet mut vec = Vec::with_capacity(key_tensor_shape[0] as _);\n\t\t\t\t\tfor i in 0..key_tensor_shape[0] as usize {\n\t\t\t\t\t\tvec.push((key_tensor[i].clone(), value_tensor[i].clone()));\n\t\t\t\t\t}\n\t\t\t\t\tOk(vec.into_iter().collect())\n\t\t\t\t}\n\t\t\t}\n\t\t\tt => Err(Error::new_with_code(\n\t\t\t\tErrorCode::InvalidArgument,\n\t\t\t\tformat!(\"Cannot extract Map<{}, {}> from {t}\", K::into_tensor_element_type(), V::into_tensor_element_type())\n\t\t\t))\n\t\t}\n\t}"
}