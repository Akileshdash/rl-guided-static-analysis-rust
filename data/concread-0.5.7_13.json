{
    "level": "Warning",
    "analyzer": "UnsafeDataflow",
    "op_type": "ReadFlow/Transmute",
    "description": "Potential unsafe dataflow issue in `internals::bptree::node::Branch::<K, V>::add_node`",
    "file": "concread-0.5.7/src/internals/bptree/node.rs",
    "start_line": 1080,
    "start_col": 5,
    "end_line": 1225,
    "end_col": 6,
    "code_snippet": "pub(crate) fn add_node(&mut self, node: *mut Node<K, V>) -> BranchInsertState<K, V> {\n        debug_assert_branch!(self);\n        // do we have space?\n        if self.count() == L_CAPACITY {\n            // if no space ->\n            //    split and send two nodes back for new branch\n            // There are three possible states that this causes.\n            // 1 * The inserted node is the greater than all current values, causing l(max, node)\n            //     to be returned.\n            // 2 * The inserted node is between max - 1 and max, causing l(node, max) to be returned.\n            // 3 * The inserted node is a low/middle value, causing max and max -1 to be returned.\n            //\n            let kr = unsafe { &*Node::min_raw(node) };\n            let r = key_search!(self, kr);\n            let ins_idx = r.unwrap_err();\n            // Everything will pop max.\n            let max = unsafe { *(self.nodes.get_unchecked(BV_CAPACITY - 1)) };\n            let res = match ins_idx {\n                // Case 1\n                L_CAPACITY => {\n                    // println!(\"case 1\");\n                    // Greater than all current values, so we'll just return max and node.\n                    let _kdrop =\n                        unsafe { ptr::read(self.key.get_unchecked(L_CAPACITY - 1)).assume_init() };\n                    // Now setup the ret val NOTICE compared to case 2 that we swap node and max?\n                    BranchInsertState::Split(max, node)\n                }\n                // Case 2\n                L_CAPACITY_N1 => {\n                    // println!(\"case 2\");\n                    // Greater than all but max, so we return max and node in the correct order.\n                    // Drop the key between them.\n                    let _kdrop =\n                        unsafe { ptr::read(self.key.get_unchecked(L_CAPACITY - 1)).assume_init() };\n                    // Now setup the ret val NOTICE compared to case 1 that we swap node and max?\n                    BranchInsertState::Split(node, max)\n                }\n                // Case 3\n                ins_idx => {\n                    // Get the max - 1 and max nodes out.\n                    let maxn1 = unsafe { *(self.nodes.get_unchecked(BV_CAPACITY - 2)) };\n                    // Drop the key between them.\n                    let _kdrop =\n                        unsafe { ptr::read(self.key.get_unchecked(L_CAPACITY - 1)).assume_init() };\n                    // Drop the key before us that we are about to replace.\n                    let _kdrop =\n                        unsafe { ptr::read(self.key.get_unchecked(L_CAPACITY - 2)).assume_init() };\n                    // Add node and it's key to the correct location.\n                    let k: K = kr.clone();\n                    let leaf_ins_idx = ins_idx + 1;\n                    unsafe {\n                        slice_insert(&mut self.key, MaybeUninit::new(k), ins_idx);\n                        slice_insert(&mut self.nodes, node, leaf_ins_idx);\n                    }\n\n                    BranchInsertState::Split(maxn1, max)\n                }\n            };\n            // Dec count as we always reduce branch by one as we split return\n            // two.\n            self.dec_count();\n            res\n        } else {\n            // if space ->\n            // Get the nodes min-key - we clone it because we'll certainly be inserting it!\n            let k: K = unsafe { &*Node::min_raw(node) }.clone();\n            // bst and find when min-key < key[idx]\n            let r = key_search!(self, &k);\n            // if r is ever found, I think this is a bug, because we should never be able to\n            // add a node with an existing min.\n            //\n            //       [ 5 ]\n            //        / \\\n            //    [0,]   [5,]\n            //\n            // So if we added here to [0, ], and it had to overflow to split, then everything\n            // must be < 5. Why? Because to get to [0,] as your insert target, you must be < 5.\n            // if we added to [5,] then a split must be greater than, or the insert would replace 5.\n            //\n            // if we consider\n            //\n            //       [ 5 ]\n            //        / \\\n            //    [0,]   [7,]\n            //\n            // Now we insert 5, and 7, splits. 5 would remain in the tree and we'd split 7 to the right\n            //\n            // As a result, any \"Ok(idx)\" must represent a corruption of the tree.\n            // debug_assert!(r.is_err());\n            let ins_idx = r.unwrap_err();\n            let leaf_ins_idx = ins_idx + 1;\n            // So why do we only need to insert right? Because the left-most\n            // leaf when it grows, it splits to the right. That importantly\n            // means that we only need to insert to replace the min and it's\n            // right leaf, or anything higher. As a result, we are always\n            // targeting ins_idx and leaf_ins_idx = ins_idx + 1.\n            //\n            // We have a situation like:\n            //\n            //   [1, 3, 9, 18]\n            //\n            // and ins_idx is 2. IE:\n            //\n            //   [1, 3, 9, 18]\n            //          ^-- k=6\n            //\n            // So this we need to shift those r-> and insert.\n            //\n            //   [1, 3, x, 9, 18]\n            //          ^-- k=6\n            //\n            //   [1, 3, 6, 9, 18]\n            //\n            // Now we need to consider the leaves too:\n            //\n            //   [1, 3, 9, 18]\n            //   | |  |  |   |\n            //   v v  v  v   v\n            //   0 1  3  9   18\n            //\n            // So that means we need to move leaf_ins_idx = (ins_idx + 1)\n            // right also\n            //\n            //   [1, 3, x, 9, 18]\n            //   | |  |  |  |   |\n            //   v v  v  v  v   v\n            //   0 1  3  x  9   18\n            //           ^-- leaf for k=6 will go here.\n            //\n            // Now to talk about the right expand issue - lets say 0 conducted\n            // a split, it returns the new right node - which would push\n            // 3 to the right to insert a new right hand side as required. So we\n            // really never need to consider the left most leaf to have to be\n            // replaced in any conditions.\n            //\n            // Magic!\n            unsafe {\n                slice_insert(&mut self.key, MaybeUninit::new(k), ins_idx);\n                slice_insert(&mut self.nodes, node, leaf_ins_idx);\n            }\n            // finally update the count\n            self.inc_count();\n            // Return that we are okay to go!\n            BranchInsertState::Ok\n        }\n    }"
}