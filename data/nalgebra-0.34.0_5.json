{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "SliceFromRaw",
    "description": "Potential unsafe dataflow issue in `base::edition::<impl base::matrix::Matrix<T, R, C, S>>::resize_generic`",
    "file": "nalgebra-0.34.0/src/base/edition.rs",
    "start_line": 874,
    "start_col": 5,
    "end_line": 953,
    "end_col": 6,
    "code_snippet": "pub fn resize_generic<R2: Dim, C2: Dim>(\n        self,\n        new_nrows: R2,\n        new_ncols: C2,\n        val: T,\n    ) -> OMatrix<T, R2, C2>\n    where\n        DefaultAllocator: Reallocator<T, R, C, R2, C2>,\n    {\n        let (nrows, ncols) = self.shape();\n        let mut data = self.into_owned();\n\n        if new_nrows.value() == nrows {\n            if new_ncols.value() < ncols {\n                unsafe {\n                    let num_cols_to_delete = ncols - new_ncols.value();\n                    let col_ptr = data.data.ptr_mut().add(new_ncols.value() * nrows);\n                    let s = ptr::slice_from_raw_parts_mut(col_ptr, num_cols_to_delete * nrows);\n                    // Safety: drop the elements of the deleted columns.\n                    //         these are the elements that will be truncated\n                    //         by the `reallocate_copy` afterward.\n                    ptr::drop_in_place(s)\n                };\n            }\n\n            let res = unsafe { DefaultAllocator::reallocate_copy(new_nrows, new_ncols, data.data) };\n            let mut res = Matrix::from_data(res);\n\n            if new_ncols.value() > ncols {\n                res.columns_range_mut(ncols..)\n                    .fill_with(|| MaybeUninit::new(val.clone()));\n            }\n\n            // Safety: the result is now fully initialized by `reallocate_copy` and\n            //         `fill_with` (if the output has more columns than the input).\n            unsafe { res.assume_init() }\n        } else {\n            let mut res;\n\n            unsafe {\n                if new_nrows.value() < nrows {\n                    compress_rows(\n                        data.as_mut_slice(),\n                        nrows,\n                        ncols,\n                        new_nrows.value(),\n                        nrows - new_nrows.value(),\n                    );\n                    res = Matrix::from_data(DefaultAllocator::reallocate_copy(\n                        new_nrows, new_ncols, data.data,\n                    ));\n                } else {\n                    res = Matrix::from_data(DefaultAllocator::reallocate_copy(\n                        new_nrows, new_ncols, data.data,\n                    ));\n                    extend_rows(\n                        res.as_mut_slice(),\n                        nrows,\n                        new_ncols.value(),\n                        nrows,\n                        new_nrows.value() - nrows,\n                    );\n                }\n            }\n\n            if new_ncols.value() > ncols {\n                res.columns_range_mut(ncols..)\n                    .fill_with(|| MaybeUninit::new(val.clone()));\n            }\n\n            if new_nrows.value() > nrows {\n                res.view_range_mut(nrows.., ..cmp::min(ncols, new_ncols.value()))\n                    .fill_with(|| MaybeUninit::new(val.clone()));\n            }\n\n            // Safety: the result is now fully initialized by `reallocate_copy` and\n            //         `fill_with` (whenever applicable).\n            unsafe { res.assume_init() }\n        }\n    }"
}