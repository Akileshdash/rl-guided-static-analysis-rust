{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `visualizers::depth_images::DepthImageVisualizer::process_depth_image_data`",
    "file": "re_view_spatial-0.24.0/src/visualizers/depth_images.rs",
    "start_line": 55,
    "start_col": 5,
    "end_line": 160,
    "end_col": 6,
    "code_snippet": "fn process_depth_image_data(\n        &mut self,\n        ctx: &QueryContext<'_>,\n        depth_clouds: &mut Vec<DepthCloud>,\n        ent_context: &SpatialSceneEntityContext<'_>,\n        images: impl Iterator<Item = DepthImageComponentData>,\n    ) {\n        let is_3d_view = ent_context.view_class_identifier == SpatialView3D::identifier();\n\n        let entity_path = ctx.target_entity_path;\n\n        for data in images {\n            let DepthImageComponentData {\n                image,\n                depth_meter,\n                fill_ratio,\n                colormap,\n                value_range,\n            } = data;\n\n            let depth_meter = depth_meter.unwrap_or_else(|| self.fallback_for(ctx));\n\n            // All depth images must have a colormap:\n            let colormap = colormap.unwrap_or_else(|| self.fallback_for(ctx));\n            let value_range = value_range\n                .map(|r| [r[0] as f32, r[1] as f32])\n                .unwrap_or_else(|| {\n                    // Don't use fallback provider since it has to query information we already have.\n                    let image_stats = ctx\n                        .store_ctx()\n                        .caches\n                        .entry(|c: &mut ImageStatsCache| c.entry(&image));\n                    ColormapWithRange::default_range_for_depth_images(&image_stats)\n                });\n            let colormap_with_range = ColormapWithRange {\n                colormap,\n                value_range,\n            };\n\n            // First try to create a textured rect for this image.\n            // Even if we end up only showing a depth cloud,\n            // we still need most of this for ui interaction which still shows the image!\n            let Some(textured_rect) = textured_rect_from_image(\n                ctx.viewer_ctx(),\n                entity_path,\n                ent_context,\n                &image,\n                Some(&colormap_with_range),\n                re_renderer::Rgba::WHITE,\n                DepthImage::name(),\n            ) else {\n                // If we can't create a textured rect from this, we don't have to bother with clouds either.\n                return;\n            };\n\n            if is_3d_view {\n                if let Some(twod_in_threed_info) = &ent_context.transform_info.twod_in_threed_info {\n                    let fill_ratio = fill_ratio.unwrap_or_default();\n\n                    // NOTE: we don't pass in `world_from_obj` because this corresponds to the\n                    // transform of the projection plane, which is of no use to us here.\n                    // What we want are the extrinsics of the depth camera!\n                    match Self::process_entity_view_as_depth_cloud(\n                        ctx,\n                        ent_context,\n                        entity_path,\n                        twod_in_threed_info,\n                        depth_meter,\n                        fill_ratio,\n                        &textured_rect.colormapped_texture,\n                    ) {\n                        Ok(cloud) => {\n                            self.data.add_bounding_box(\n                                entity_path.hash(),\n                                cloud.world_space_bbox(),\n                                glam::Affine3A::IDENTITY,\n                            );\n                            self.depth_cloud_entities.insert(\n                                entity_path.hash(),\n                                (image, depth_meter, textured_rect.colormapped_texture),\n                            );\n                            depth_clouds.push(cloud);\n\n                            // Skip creating a textured rect.\n                            return;\n                        }\n                        Err(err) => {\n                            re_log::warn_once!(\"{err}\");\n                        }\n                    }\n                };\n            }\n\n            self.data.add_pickable_rect(\n                PickableTexturedRect {\n                    ent_path: entity_path.clone(),\n                    textured_rect,\n                    source_data: PickableRectSourceData::Image {\n                        image,\n                        depth_meter: Some(depth_meter),\n                    },\n                },\n                ent_context.view_class_identifier,\n            );\n        }\n    }"
}