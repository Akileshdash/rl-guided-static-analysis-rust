{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `avx::avx_raders::RadersAvx2::<A, T>::perform_fft_inplace`",
    "file": "rustfft-6.4.0/src/avx/avx_raders.rs",
    "start_line": 481,
    "start_col": 5,
    "end_line": 536,
    "end_col": 6,
    "code_snippet": "fn perform_fft_inplace(&self, buffer: &mut [Complex<T>], scratch: &mut [Complex<T>]) {\n        let (scratch, extra_scratch) = scratch.split_at_mut(self.len());\n        unsafe {\n            // Specialization workaround: See the comments in FftPlannerAvx::new() for why these calls to array_utils::workaround_transmute are necessary\n            let transmuted_scratch: &mut [Complex<A>] =\n                array_utils::workaround_transmute_mut(scratch);\n            let transmuted_buffer: &mut [Complex<A>] =\n                array_utils::workaround_transmute_mut(buffer);\n            self.prepare_raders(transmuted_buffer, transmuted_scratch)\n        }\n\n        let first_input = buffer[0];\n\n        let truncated_scratch = &mut scratch[1..];\n\n        // perform the first of two inner FFTs\n        let inner_scratch = if extra_scratch.len() > 0 {\n            extra_scratch\n        } else {\n            &mut buffer[..]\n        };\n        self.inner_fft\n            .process_with_scratch(truncated_scratch, inner_scratch);\n\n        // truncated_scratch[0] now contains the sum of elements 1..n. we want the sum of all inputs, so all we need to do is add the first input\n        let first_output = first_input + truncated_scratch[0];\n\n        // multiply the inner result with our cached setup data\n        // also conjugate every entry. this sets us up to do an inverse FFT\n        // (because an inverse FFT is equivalent to a normal FFT where you conjugate both the inputs and outputs)\n        unsafe {\n            // Specialization workaround: See the comments in FftPlannerAvx::new() for why these calls to array_utils::workaround_transmute are necessary\n            let transmuted_scratch: &mut [Complex<A>] =\n                array_utils::workaround_transmute_mut(truncated_scratch);\n            avx_vector::pairwise_complex_mul_assign_conjugated(transmuted_scratch, &self.twiddles)\n        };\n\n        // We need to add the first input value to all output values. We can accomplish this by adding it to the DC input of our inner ifft.\n        // Of course, we have to conjugate it, just like we conjugated the complex multiplied above\n        truncated_scratch[0] = truncated_scratch[0] + first_input.conj();\n\n        // execute the second FFT\n        self.inner_fft\n            .process_with_scratch(truncated_scratch, inner_scratch);\n\n        // copy the final values into the output, reordering as we go\n        buffer[0] = first_output;\n        unsafe {\n            // Specialization workaround: See the comments in FftPlannerAvx::new() for why these calls to array_utils::workaround_transmute are necessary\n            let transmuted_scratch: &mut [Complex<A>] =\n                array_utils::workaround_transmute_mut(scratch);\n            let transmuted_buffer: &mut [Complex<A>] =\n                array_utils::workaround_transmute_mut(buffer);\n            self.finalize_raders(transmuted_scratch, transmuted_buffer);\n        }\n    }"
}