{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `routing::router::get_route`",
    "file": "lightning-0.1.5/src/routing/router.rs",
    "start_line": 2179,
    "start_col": 1,
    "end_line": 3468,
    "end_col": 2,
    "code_snippet": "pub(crate) fn get_route<L: Deref, S: ScoreLookUp>(\n\tour_node_pubkey: &PublicKey, route_params: &RouteParameters, network_graph: &ReadOnlyNetworkGraph,\n\tfirst_hops: Option<&[&ChannelDetails]>, logger: L, scorer: &S, score_params: &S::ScoreParams,\n\t_random_seed_bytes: &[u8; 32]\n) -> Result<Route, LightningError>\nwhere L::Target: Logger {\n\n\tlet payment_params = &route_params.payment_params;\n\tlet max_path_length = core::cmp::min(payment_params.max_path_length, MAX_PATH_LENGTH_ESTIMATE);\n\tlet final_value_msat = route_params.final_value_msat;\n\t// If we're routing to a blinded recipient, we won't have their node id. Therefore, keep the\n\t// unblinded payee id as an option. We also need a non-optional \"payee id\" for path construction,\n\t// so use a dummy id for this in the blinded case.\n\tlet payee_node_id_opt = payment_params.payee.node_id().map(|pk| NodeId::from_pubkey(&pk));\n\tconst DUMMY_BLINDED_PAYEE_ID: [u8; 33] = [2; 33];\n\tlet maybe_dummy_payee_pk = payment_params.payee.node_id().unwrap_or_else(|| PublicKey::from_slice(&DUMMY_BLINDED_PAYEE_ID).unwrap());\n\tlet maybe_dummy_payee_node_id = NodeId::from_pubkey(&maybe_dummy_payee_pk);\n\tlet our_node_id = NodeId::from_pubkey(&our_node_pubkey);\n\n\tif payee_node_id_opt.map_or(false, |payee| payee == our_node_id) {\n\t\treturn Err(LightningError{err: \"Cannot generate a route to ourselves\".to_owned(), action: ErrorAction::IgnoreError});\n\t}\n\tif our_node_id == maybe_dummy_payee_node_id {\n\t\treturn Err(LightningError{err: \"Invalid origin node id provided, use a different one\".to_owned(), action: ErrorAction::IgnoreError});\n\t}\n\n\tif final_value_msat > MAX_VALUE_MSAT {\n\t\treturn Err(LightningError{err: \"Cannot generate a route of more value than all existing satoshis\".to_owned(), action: ErrorAction::IgnoreError});\n\t}\n\n\tif final_value_msat == 0 {\n\t\treturn Err(LightningError{err: \"Cannot send a payment of 0 msat\".to_owned(), action: ErrorAction::IgnoreError});\n\t}\n\n\tlet final_cltv_expiry_delta = payment_params.payee.final_cltv_expiry_delta().unwrap_or(0);\n\tif payment_params.max_total_cltv_expiry_delta <= final_cltv_expiry_delta {\n\t\treturn Err(LightningError{err: \"Can't find a route where the maximum total CLTV expiry delta is below the final CLTV expiry.\".to_owned(), action: ErrorAction::IgnoreError});\n\t}\n\n\t// The general routing idea is the following:\n\t// 1. Fill first/last hops communicated by the caller.\n\t// 2. Attempt to construct a path from payer to payee for transferring\n\t//    any ~sufficient (described later) value.\n\t//    If succeed, remember which channels were used and how much liquidity they have available,\n\t//    so that future paths don't rely on the same liquidity.\n\t// 3. Proceed to the next step if:\n\t//    - we hit the recommended target value;\n\t//    - OR if we could not construct a new path. Any next attempt will fail too.\n\t//    Otherwise, repeat step 2.\n\t// 4. See if we managed to collect paths which aggregately are able to transfer target value\n\t//    (not recommended value).\n\t// 5. If yes, proceed. If not, fail routing.\n\t// 6. Select the paths which have the lowest cost (fee plus scorer penalty) per amount\n\t//    transferred up to the transfer target value.\n\t// 7. Reduce the value of the last path until we are sending only the target value.\n\t// 8. If our maximum channel saturation limit caused us to pick two identical paths, combine\n\t//    them so that we're not sending two HTLCs along the same path.\n\n\t// As for the actual search algorithm, we do a payee-to-payer Dijkstra's sorting by each node's\n\t// distance from the payee\n\t//\n\t// We are not a faithful Dijkstra's implementation because we can change values which impact\n\t// earlier nodes while processing later nodes. Specifically, if we reach a channel with a lower\n\t// liquidity limit (via htlc_maximum_msat, on-chain capacity or assumed liquidity limits) than\n\t// the value we are currently attempting to send over a path, we simply reduce the value being\n\t// sent along the path for any hops after that channel. This may imply that later fees (which\n\t// we've already tabulated) are lower because a smaller value is passing through the channels\n\t// (and the proportional fee is thus lower). There isn't a trivial way to recalculate the\n\t// channels which were selected earlier (and which may still be used for other paths without a\n\t// lower liquidity limit), so we simply accept that some liquidity-limited paths may be\n\t// de-preferenced.\n\t//\n\t// One potentially problematic case for this algorithm would be if there are many\n\t// liquidity-limited paths which are liquidity-limited near the destination (ie early in our\n\t// graph walking), we may never find a path which is not liquidity-limited and has lower\n\t// proportional fee (and only lower absolute fee when considering the ultimate value sent).\n\t// Because we only consider paths with at least 5% of the total value being sent, the damage\n\t// from such a case should be limited, however this could be further reduced in the future by\n\t// calculating fees on the amount we wish to route over a path, ie ignoring the liquidity\n\t// limits for the purposes of fee calculation.\n\t//\n\t// Alternatively, we could store more detailed path information in the heap (targets, below)\n\t// and index the best-path map (dist, below) by node *and* HTLC limits, however that would blow\n\t// up the runtime significantly both algorithmically (as we'd traverse nodes multiple times)\n\t// and practically (as we would need to store dynamically-allocated path information in heap\n\t// objects, increasing malloc traffic and indirect memory access significantly). Further, the\n\t// results of such an algorithm would likely be biased towards lower-value paths.\n\t//\n\t// Further, we could return to a faithful Dijkstra's algorithm by rejecting paths with limits\n\t// outside of our current search value, running a path search more times to gather candidate\n\t// paths at different values. While this may be acceptable, further path searches may increase\n\t// runtime for little gain. Specifically, the current algorithm rather efficiently explores the\n\t// graph for candidate paths, calculating the maximum value which can realistically be sent at\n\t// the same time, remaining generic across different payment values.\n\n\tlet network_channels = network_graph.channels();\n\tlet network_nodes = network_graph.nodes();\n\n\tif payment_params.max_path_count == 0 {\n\t\treturn Err(LightningError{err: \"Can't find a route with no paths allowed.\".to_owned(), action: ErrorAction::IgnoreError});\n\t}\n\n\t// Allow MPP only if we have a features set from somewhere that indicates the payee supports\n\t// it. If the payee supports it they're supposed to include it in the invoice, so that should\n\t// work reliably.\n\tlet allow_mpp = if payment_params.max_path_count == 1 {\n\t\tfalse\n\t} else if payment_params.payee.supports_basic_mpp() {\n\t\ttrue\n\t} else if let Some(payee) = payee_node_id_opt {\n\t\tnetwork_nodes.get(&payee).map_or(false, |node| node.announcement_info.as_ref().map_or(false,\n\t\t\t|info| info.features().supports_basic_mpp()))\n\t} else { false };\n\n\tlet max_total_routing_fee_msat = route_params.max_total_routing_fee_msat.unwrap_or(u64::max_value());\n\n\tlet first_hop_count = first_hops.map(|hops| hops.len()).unwrap_or(0);\n\tlog_trace!(logger, \"Searching for a route from payer {} to {} {} MPP and {} first hops {}overriding the network graph of {} nodes and {} channels with a fee limit of {} msat\",\n\t\tour_node_pubkey, LoggedPayeePubkey(payment_params.payee.node_id()),\n\t\tif allow_mpp { \"with\" } else { \"without\" },\n\t\tfirst_hop_count, if first_hops.is_some() { \"\" } else { \"not \" },\n\t\tnetwork_graph.nodes().len(), network_graph.channels().len(),\n\t\tmax_total_routing_fee_msat);\n\n\tif first_hop_count < 10 {\n\t\tif let Some(hops) = first_hops {\n\t\t\tfor hop in hops {\n\t\t\t\tlog_trace!(\n\t\t\t\t\tlogger,\n\t\t\t\t\t\" First hop through {}/{} can send between {}msat and {}msat (inclusive).\",\n\t\t\t\t\thop.counterparty.node_id,\n\t\t\t\t\thop.get_outbound_payment_scid().unwrap_or(0),\n\t\t\t\t\thop.next_outbound_htlc_minimum_msat,\n\t\t\t\t\thop.next_outbound_htlc_limit_msat\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tlet mut node_counter_builder = NodeCountersBuilder::new(&network_graph);\n\n\tlet payer_node_counter = node_counter_builder.select_node_counter_for_pubkey(*our_node_pubkey);\n\tlet payee_node_counter = node_counter_builder.select_node_counter_for_pubkey(maybe_dummy_payee_pk);\n\n\tfor route in payment_params.payee.unblinded_route_hints().iter() {\n\t\tfor hop in route.0.iter() {\n\t\t\tnode_counter_builder.select_node_counter_for_pubkey(hop.src_node_id);\n\t\t}\n\t}\n\n\t// Step (1). Prepare first and last hop targets.\n\t//\n\t// For unblinded first- and last-hop channels, cache them in maps so that we can detect them as\n\t// we walk the graph and incorporate them into our candidate set.\n\t// For blinded last-hop paths, look up their introduction point and cache the node counters\n\t// identifying them.\n\tlet mut first_hop_targets: HashMap<_, (Vec<&ChannelDetails>, u32)> =\n\t\thash_map_with_capacity(if first_hops.is_some() { first_hops.as_ref().unwrap().len() } else { 0 });\n\tif let Some(hops) = first_hops {\n\t\tfor chan in hops {\n\t\t\tif chan.get_outbound_payment_scid().is_none() {\n\t\t\t\tpanic!(\"first_hops should be filled in with usable channels, not pending ones\");\n\t\t\t}\n\t\t\tif chan.counterparty.node_id == *our_node_pubkey {\n\t\t\t\treturn Err(LightningError{err: \"First hop cannot have our_node_pubkey as a destination.\".to_owned(), action: ErrorAction::IgnoreError});\n\t\t\t}\n\t\t\tlet counterparty_id = NodeId::from_pubkey(&chan.counterparty.node_id);\n\t\t\tfirst_hop_targets\n\t\t\t\t.entry(counterparty_id)\n\t\t\t\t.or_insert_with(|| {\n\t\t\t\t\t// Make sure there's a counter assigned for the counterparty\n\t\t\t\t\tlet node_counter = node_counter_builder.select_node_counter_for_id(counterparty_id);\n\t\t\t\t\t(Vec::new(), node_counter)\n\t\t\t\t})\n\t\t\t\t.0.push(chan);\n\t\t}\n\t\tif first_hop_targets.is_empty() {\n\t\t\treturn Err(LightningError{err: \"Cannot route when there are no outbound routes away from us\".to_owned(), action: ErrorAction::IgnoreError});\n\t\t}\n\t}\n\n\tlet node_counters = node_counter_builder.build();\n\n\tlet introduction_node_id_cache = calculate_blinded_path_intro_points(\n\t\t&payment_params, &node_counters, network_graph, &logger, our_node_id, &first_hop_targets,\n\t)?;\n\n\tlet mut last_hop_candidates =\n\t\thash_map_with_capacity(payment_params.payee.unblinded_route_hints().len());\n\tfor route in payment_params.payee.unblinded_route_hints().iter()\n\t\t.filter(|route| !route.0.is_empty())\n\t{\n\t\tlet hop_iter = route.0.iter().rev();\n\t\tlet prev_hop_iter = core::iter::once(&maybe_dummy_payee_pk).chain(\n\t\t\troute.0.iter().skip(1).rev().map(|hop| &hop.src_node_id));\n\n\t\tfor (hop, prev_hop_id) in hop_iter.zip(prev_hop_iter) {\n\t\t\tlet (target, private_target_node_counter) =\n\t\t\t\tnode_counters.private_node_counter_from_pubkey(&prev_hop_id)\n\t\t\t\t\t.ok_or_else(|| {\n\t\t\t\t\t\tdebug_assert!(false);\n\t\t\t\t\t\tLightningError { err: \"We should always have private target node counters available\".to_owned(), action: ErrorAction::IgnoreError }\n\t\t\t\t\t})?;\n\t\t\tlet (_src_id, private_source_node_counter) =\n\t\t\t\tnode_counters.private_node_counter_from_pubkey(&hop.src_node_id)\n\t\t\t\t\t.ok_or_else(|| {\n\t\t\t\t\t\tdebug_assert!(false);\n\t\t\t\t\t\tLightningError { err: \"We should always have private source node counters available\".to_owned(), action: ErrorAction::IgnoreError }\n\t\t\t\t\t})?;\n\n\t\t\tif let Some((first_channels, _)) = first_hop_targets.get(target) {\n\t\t\t\tlet matches_an_scid = |d: &&ChannelDetails|\n\t\t\t\t\td.outbound_scid_alias == Some(hop.short_channel_id) || d.short_channel_id == Some(hop.short_channel_id);\n\t\t\t\tif first_channels.iter().any(matches_an_scid) {\n\t\t\t\t\tlog_trace!(logger, \"Ignoring route hint with SCID {} (and any previous) due to it being a direct channel of ours.\",\n\t\t\t\t\t\thop.short_channel_id);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet candidate = network_channels\n\t\t\t\t.get(&hop.short_channel_id)\n\t\t\t\t.and_then(|channel| channel.as_directed_to(target))\n\t\t\t\t.map(|(info, _)| CandidateRouteHop::PublicHop(PublicHopCandidate {\n\t\t\t\t\tinfo,\n\t\t\t\t\tshort_channel_id: hop.short_channel_id,\n\t\t\t\t}))\n\t\t\t\t.unwrap_or_else(|| CandidateRouteHop::PrivateHop(PrivateHopCandidate {\n\t\t\t\t\thint: hop, target_node_id: target,\n\t\t\t\t\tsource_node_counter: *private_source_node_counter,\n\t\t\t\t\ttarget_node_counter: *private_target_node_counter,\n\t\t\t\t}));\n\n\t\t\tlast_hop_candidates.entry(private_target_node_counter).or_insert_with(Vec::new).push(candidate);\n\t\t}\n\t}\n\n\t// The main heap containing all candidate next-hops sorted by their score (max(fee,\n\t// htlc_minimum)). Ideally this would be a heap which allowed cheap score reduction instead of\n\t// adding duplicate entries when we find a better path to a given node.\n\tlet mut targets: BinaryHeap<RouteGraphNode> = BinaryHeap::new();\n\n\t// Map from node_id to information about the best current path to that node, including feerate\n\t// information.\n\tlet dist_len = node_counters.max_counter() + 1;\n\tlet mut dist: Vec<Option<PathBuildingHop>> = vec![None; dist_len as usize];\n\n\t// During routing, if we ignore a path due to an htlc_minimum_msat limit, we set this,\n\t// indicating that we may wish to try again with a higher value, potentially paying to meet an\n\t// htlc_minimum with extra fees while still finding a cheaper path.\n\tlet mut hit_minimum_limit;\n\n\t// When arranging a route, we select multiple paths so that we can make a multi-path payment.\n\t// We start with a path_value of the exact amount we want, and if that generates a route we may\n\t// return it immediately. Otherwise, we don't stop searching for paths until we have 3x the\n\t// amount we want in total across paths, selecting the best subset at the end.\n\tconst ROUTE_CAPACITY_PROVISION_FACTOR: u64 = 3;\n\tlet recommended_value_msat = final_value_msat * ROUTE_CAPACITY_PROVISION_FACTOR as u64;\n\tlet mut path_value_msat = final_value_msat;\n\n\t// Routing Fragmentation Mitigation heuristic:\n\t//\n\t// Routing fragmentation across many payment paths increases the overall routing\n\t// fees as you have irreducible routing fees per-link used (`fee_base_msat`).\n\t// Taking too many smaller paths also increases the chance of payment failure.\n\t// Thus to avoid this effect, we require from our collected links to provide\n\t// at least a minimal contribution to the recommended value yet-to-be-fulfilled.\n\t// This requirement is currently set to be 1/max_path_count of the payment\n\t// value to ensure we only ever return routes that do not violate this limit.\n\tlet minimal_value_contribution_msat: u64 = if allow_mpp {\n\t\t(final_value_msat + (payment_params.max_path_count as u64 - 1)) / payment_params.max_path_count as u64\n\t} else {\n\t\tfinal_value_msat\n\t};\n\n\t// When we start collecting routes we enforce the max_channel_saturation_power_of_half\n\t// requirement strictly. After we've collected enough (or if we fail to find new routes) we\n\t// drop the requirement by setting this to 0.\n\tlet mut channel_saturation_pow_half = payment_params.max_channel_saturation_power_of_half;\n\n\t// In order to already account for some of the privacy enhancing random CLTV\n\t// expiry delta offset we add on top later, we subtract a rough estimate\n\t// (2*MEDIAN_HOP_CLTV_EXPIRY_DELTA) here.\n\tlet max_total_cltv_expiry_delta: u16 =\n\t\t(payment_params.max_total_cltv_expiry_delta - final_cltv_expiry_delta)\n\t\t.checked_sub(2*MEDIAN_HOP_CLTV_EXPIRY_DELTA)\n\t\t.unwrap_or(payment_params.max_total_cltv_expiry_delta - final_cltv_expiry_delta)\n\t\t.try_into()\n\t\t.unwrap_or(u16::MAX);\n\n\t// Keep track of how much liquidity has been used in selected channels or blinded paths. Used to\n\t// determine if the channel can be used by additional MPP paths or to inform path finding\n\t// decisions. It is aware of direction *only* to ensure that the correct htlc_maximum_msat value\n\t// is used. Hence, liquidity used in one direction will not offset any used in the opposite\n\t// direction.\n\tlet mut used_liquidities: HashMap<CandidateHopId, u64> =\n\t\thash_map_with_capacity(network_nodes.len());\n\n\t// Keeping track of how much value we already collected across other paths. Helps to decide\n\t// when we want to stop looking for new paths.\n\tlet mut already_collected_value_msat = 0;\n\n\tfor (_, (channels, _)) in first_hop_targets.iter_mut() {\n\t\tsort_first_hop_channels(channels, &used_liquidities, recommended_value_msat,\n\t\t\tour_node_pubkey);\n\t}\n\n\tlog_trace!(logger, \"Building path from {} to payer {} for value {} msat.\",\n\t\tLoggedPayeePubkey(payment_params.payee.node_id()), our_node_pubkey, final_value_msat);\n\n\t// Remember how many candidates we ignored to allow for some logging afterwards.\n\tlet mut num_ignored_value_contribution: u32 = 0;\n\tlet mut num_ignored_path_length_limit: u32 = 0;\n\tlet mut num_ignored_cltv_delta_limit: u32 = 0;\n\tlet mut num_ignored_previously_failed: u32 = 0;\n\tlet mut num_ignored_total_fee_limit: u32 = 0;\n\tlet mut num_ignored_avoid_overpayment: u32 = 0;\n\tlet mut num_ignored_htlc_minimum_msat_limit: u32 = 0;\n\n\tmacro_rules! add_entry {\n\t\t// Adds entry which goes from $candidate.source() to $candidate.target() over the $candidate hop.\n\t\t// $next_hops_fee_msat represents the fees paid for using all the channels *after* this one,\n\t\t// since that value has to be transferred over this channel.\n\t\t// Returns the contribution amount of $candidate if the channel caused an update to `targets`.\n\t\t( $candidate: expr, $next_hops_fee_msat: expr,\n\t\t\t$next_hops_value_contribution: expr, $next_hops_path_htlc_minimum_msat: expr,\n\t\t\t$next_hops_path_penalty_msat: expr, $next_hops_cltv_delta: expr, $next_hops_path_length: expr ) => { {\n\t\t\t// We \"return\" whether we updated the path at the end, and how much we can route via\n\t\t\t// this channel, via this:\n\t\t\tlet mut hop_contribution_amt_msat = None;\n\n\t\t\t#[cfg(all(not(ldk_bench), any(test, fuzzing)))]\n\t\t\tif let Some(counter) = $candidate.target_node_counter() {\n\t\t\t\t// Once we are adding paths backwards from a given target, we've selected the best\n\t\t\t\t// path from that target to the destination and it should no longer change. We thus\n\t\t\t\t// set the best-path selected flag and check that it doesn't change below.\n\t\t\t\tif let Some(node) = &mut dist[counter as usize] {\n\t\t\t\t\tnode.best_path_from_hop_selected = true;\n\t\t\t\t} else if counter != payee_node_counter {\n\t\t\t\t\tpanic!(\"No dist entry for target node counter {}\", counter);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Channels to self should not be used. This is more of belt-and-suspenders, because in\n\t\t\t// practice these cases should be caught earlier:\n\t\t\t// - for regular channels at channel announcement (TODO)\n\t\t\t// - for first and last hops early in get_route\n\t\t\tlet src_node_id = $candidate.source();\n\t\t\tif Some(src_node_id) != $candidate.target() {\n\t\t\t\tlet scid_opt = $candidate.short_channel_id();\n\t\t\t\tlet effective_capacity = $candidate.effective_capacity();\n\t\t\t\tlet htlc_maximum_msat = max_htlc_from_capacity(effective_capacity, channel_saturation_pow_half);\n\n\t\t\t\t// It is tricky to subtract $next_hops_fee_msat from available liquidity here.\n\t\t\t\t// It may be misleading because we might later choose to reduce the value transferred\n\t\t\t\t// over these channels, and the channel which was insufficient might become sufficient.\n\t\t\t\t// Worst case: we drop a good channel here because it can't cover the high following\n\t\t\t\t// fees caused by one expensive channel, but then this channel could have been used\n\t\t\t\t// if the amount being transferred over this path is lower.\n\t\t\t\t// We do this for now, but this is a subject for removal.\n\t\t\t\tif let Some(mut available_value_contribution_msat) = htlc_maximum_msat.checked_sub($next_hops_fee_msat) {\n\t\t\t\t\tlet cltv_expiry_delta = $candidate.cltv_expiry_delta();\n\t\t\t\t\tlet htlc_minimum_msat = $candidate.htlc_minimum_msat();\n\t\t\t\t\tlet used_liquidity_msat = used_liquidities\n\t\t\t\t\t\t.get(&$candidate.id())\n\t\t\t\t\t\t.map_or(0, |used_liquidity_msat| {\n\t\t\t\t\t\t\tavailable_value_contribution_msat = available_value_contribution_msat\n\t\t\t\t\t\t\t\t.saturating_sub(*used_liquidity_msat);\n\t\t\t\t\t\t\t*used_liquidity_msat\n\t\t\t\t\t\t});\n\n\t\t\t\t\t// Do not consider candidate hops that would exceed the maximum path length.\n\t\t\t\t\tlet path_length_to_node = $next_hops_path_length\n\t\t\t\t\t\t+ if $candidate.blinded_hint_idx().is_some() { 0 } else { 1 };\n\t\t\t\t\tlet exceeds_max_path_length = path_length_to_node > max_path_length;\n\n\t\t\t\t\t// Do not consider candidates that exceed the maximum total cltv expiry limit.\n\t\t\t\t\tlet hop_total_cltv_delta = ($next_hops_cltv_delta as u32)\n\t\t\t\t\t\t.saturating_add(cltv_expiry_delta);\n\t\t\t\t\tlet exceeds_cltv_delta_limit = hop_total_cltv_delta > max_total_cltv_expiry_delta as u32;\n\n\t\t\t\t\tlet value_contribution_msat = cmp::min(available_value_contribution_msat, $next_hops_value_contribution);\n\t\t\t\t\t// Verify the liquidity offered by this channel complies to the minimal contribution.\n\t\t\t\t\tlet contributes_sufficient_value = value_contribution_msat >= minimal_value_contribution_msat;\n\t\t\t\t\t// Includes paying fees for the use of the following channels.\n\t\t\t\t\tlet amount_to_transfer_over_msat: u64 = match value_contribution_msat.checked_add($next_hops_fee_msat) {\n\t\t\t\t\t\tSome(result) => result,\n\t\t\t\t\t\t// Can't overflow due to how the values were computed right above.\n\t\t\t\t\t\tNone => unreachable!(),\n\t\t\t\t\t};\n\t\t\t\t\t#[allow(unused_comparisons)] // $next_hops_path_htlc_minimum_msat is 0 in some calls so rustc complains\n\t\t\t\t\tlet over_path_minimum_msat = amount_to_transfer_over_msat >= htlc_minimum_msat &&\n\t\t\t\t\t\tamount_to_transfer_over_msat >= $next_hops_path_htlc_minimum_msat;\n\n\t\t\t\t\t#[allow(unused_comparisons)] // $next_hops_path_htlc_minimum_msat is 0 in some calls so rustc complains\n\t\t\t\t\tlet may_overpay_to_meet_path_minimum_msat =\n\t\t\t\t\t\t(amount_to_transfer_over_msat < htlc_minimum_msat &&\n\t\t\t\t\t\t  recommended_value_msat >= htlc_minimum_msat) ||\n\t\t\t\t\t\t(amount_to_transfer_over_msat < $next_hops_path_htlc_minimum_msat &&\n\t\t\t\t\t\t recommended_value_msat >= $next_hops_path_htlc_minimum_msat);\n\n\t\t\t\t\tlet payment_failed_on_this_channel = match scid_opt {\n\t\t\t\t\t\tSome(scid) => payment_params.previously_failed_channels.contains(&scid),\n\t\t\t\t\t\tNone => match $candidate.blinded_hint_idx() {\n\t\t\t\t\t\t\tSome(idx) => {\n\t\t\t\t\t\t\t\tpayment_params.previously_failed_blinded_path_idxs.contains(&(idx as u64))\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tNone => false,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\n\t\t\t\t\tlet (should_log_candidate, first_hop_details) = match $candidate {\n\t\t\t\t\t\tCandidateRouteHop::FirstHop(hop) => (true, Some(hop.details)),\n\t\t\t\t\t\tCandidateRouteHop::PrivateHop(_) => (true, None),\n\t\t\t\t\t\tCandidateRouteHop::Blinded(_) => (true, None),\n\t\t\t\t\t\tCandidateRouteHop::OneHopBlinded(_) => (true, None),\n\t\t\t\t\t\t_ => (false, None),\n\t\t\t\t\t};\n\n\t\t\t\t\t// If HTLC minimum is larger than the amount we're going to transfer, we shouldn't\n\t\t\t\t\t// bother considering this channel. If retrying with recommended_value_msat may\n\t\t\t\t\t// allow us to hit the HTLC minimum limit, set htlc_minimum_limit so that we go\n\t\t\t\t\t// around again with a higher amount.\n\t\t\t\t\tif !contributes_sufficient_value {\n\t\t\t\t\t\tif should_log_candidate {\n\t\t\t\t\t\t\tlog_trace!(logger, \"Ignoring {} due to insufficient value contribution (channel max {:?}).\",\n\t\t\t\t\t\t\t\tLoggedCandidateHop(&$candidate),\n\t\t\t\t\t\t\t\teffective_capacity);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnum_ignored_value_contribution += 1;\n\t\t\t\t\t} else if exceeds_max_path_length {\n\t\t\t\t\t\tif should_log_candidate {\n\t\t\t\t\t\t\tlog_trace!(logger, \"Ignoring {} due to exceeding maximum path length limit.\", LoggedCandidateHop(&$candidate));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnum_ignored_path_length_limit += 1;\n\t\t\t\t\t} else if exceeds_cltv_delta_limit {\n\t\t\t\t\t\tif should_log_candidate {\n\t\t\t\t\t\t\tlog_trace!(logger, \"Ignoring {} due to exceeding CLTV delta limit.\", LoggedCandidateHop(&$candidate));\n\n\t\t\t\t\t\t\tif let Some(_) = first_hop_details {\n\t\t\t\t\t\t\t\tlog_trace!(logger,\n\t\t\t\t\t\t\t\t\t\"First hop candidate cltv_expiry_delta: {}. Limit: {}\",\n\t\t\t\t\t\t\t\t\thop_total_cltv_delta,\n\t\t\t\t\t\t\t\t\tmax_total_cltv_expiry_delta,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnum_ignored_cltv_delta_limit += 1;\n\t\t\t\t\t} else if payment_failed_on_this_channel {\n\t\t\t\t\t\tif should_log_candidate {\n\t\t\t\t\t\t\tlog_trace!(logger, \"Ignoring {} due to a failed previous payment attempt.\", LoggedCandidateHop(&$candidate));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnum_ignored_previously_failed += 1;\n\t\t\t\t\t} else if may_overpay_to_meet_path_minimum_msat {\n\t\t\t\t\t\tif should_log_candidate {\n\t\t\t\t\t\t\tlog_trace!(logger,\n\t\t\t\t\t\t\t\t\"Ignoring {} to avoid overpaying to meet htlc_minimum_msat limit ({}).\",\n\t\t\t\t\t\t\t\tLoggedCandidateHop(&$candidate), $candidate.htlc_minimum_msat());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnum_ignored_avoid_overpayment += 1;\n\t\t\t\t\t\thit_minimum_limit = true;\n\t\t\t\t\t} else if over_path_minimum_msat {\n\t\t\t\t\t\t// Note that low contribution here (limited by available_liquidity_msat)\n\t\t\t\t\t\t// might violate htlc_minimum_msat on the hops which are next along the\n\t\t\t\t\t\t// payment path (upstream to the payee). To avoid that, we recompute\n\t\t\t\t\t\t// path fees knowing the final path contribution after constructing it.\n\t\t\t\t\t\tlet curr_min = cmp::max(\n\t\t\t\t\t\t\t$next_hops_path_htlc_minimum_msat, htlc_minimum_msat\n\t\t\t\t\t\t);\n\t\t\t\t\t\tlet src_node_counter = $candidate.src_node_counter();\n\t\t\t\t\t\tlet mut candidate_fees = $candidate.fees();\n\t\t\t\t\t\tif src_node_counter == payer_node_counter {\n\t\t\t\t\t\t\t// We do not charge ourselves a fee to use our own channels.\n\t\t\t\t\t\t\tcandidate_fees = RoutingFees {\n\t\t\t\t\t\t\t\tproportional_millionths: 0,\n\t\t\t\t\t\t\t\tbase_msat: 0,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet path_htlc_minimum_msat = compute_fees_saturating(curr_min, candidate_fees)\n\t\t\t\t\t\t\t.saturating_add(curr_min);\n\n\t\t\t\t\t\tlet dist_entry = &mut dist[src_node_counter as usize];\n\t\t\t\t\t\tlet old_entry = if let Some(hop) = dist_entry {\n\t\t\t\t\t\t\thop\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// If there was previously no known way to access the source node\n\t\t\t\t\t\t\t// (recall it goes payee-to-payer) of short_channel_id, first add a\n\t\t\t\t\t\t\t// semi-dummy record just to compute the fees to reach the source node.\n\t\t\t\t\t\t\t// This will affect our decision on selecting short_channel_id\n\t\t\t\t\t\t\t// as a way to reach the $candidate.target() node.\n\t\t\t\t\t\t\t*dist_entry = Some(PathBuildingHop {\n\t\t\t\t\t\t\t\tcandidate: $candidate.clone(),\n\t\t\t\t\t\t\t\tfee_msat: 0,\n\t\t\t\t\t\t\t\tnext_hops_fee_msat: u64::max_value(),\n\t\t\t\t\t\t\t\thop_use_fee_msat: u64::max_value(),\n\t\t\t\t\t\t\t\ttotal_fee_msat: u64::max_value(),\n\t\t\t\t\t\t\t\tpath_htlc_minimum_msat,\n\t\t\t\t\t\t\t\tpath_penalty_msat: u64::max_value(),\n\t\t\t\t\t\t\t\twas_processed: false,\n\t\t\t\t\t\t\t\tis_first_hop_target: false,\n\t\t\t\t\t\t\t\tis_last_hop_target: false,\n\t\t\t\t\t\t\t\t#[cfg(all(not(ldk_bench), any(test, fuzzing)))]\n\t\t\t\t\t\t\t\tbest_path_from_hop_selected: false,\n\t\t\t\t\t\t\t\tvalue_contribution_msat,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tdist_entry.as_mut().unwrap()\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t#[allow(unused_mut)] // We only use the mut in cfg(test)\n\t\t\t\t\t\tlet mut should_process = !old_entry.was_processed;\n\t\t\t\t\t\t#[cfg(all(not(ldk_bench), any(test, fuzzing)))]\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// In test/fuzzing builds, we do extra checks to make sure the skipping\n\t\t\t\t\t\t\t// of already-seen nodes only happens in cases we expect (see below).\n\t\t\t\t\t\t\tif !should_process { should_process = true; }\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif should_process {\n\t\t\t\t\t\t\tlet mut hop_use_fee_msat = 0;\n\t\t\t\t\t\t\tlet mut total_fee_msat: u64 = $next_hops_fee_msat;\n\n\t\t\t\t\t\t\t// Ignore hop_use_fee_msat for channel-from-us as we assume all channels-from-us\n\t\t\t\t\t\t\t// will have the same effective-fee\n\t\t\t\t\t\t\tif src_node_id != our_node_id {\n\t\t\t\t\t\t\t\t// Note that `u64::max_value` means we'll always fail the\n\t\t\t\t\t\t\t\t// `old_entry.total_fee_msat > total_fee_msat` check below\n\t\t\t\t\t\t\t\thop_use_fee_msat = compute_fees_saturating(amount_to_transfer_over_msat, candidate_fees);\n\t\t\t\t\t\t\t\ttotal_fee_msat = total_fee_msat.saturating_add(hop_use_fee_msat);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Ignore hops if augmenting the current path to them would put us over `max_total_routing_fee_msat`\n\t\t\t\t\t\t\tif total_fee_msat > max_total_routing_fee_msat {\n\t\t\t\t\t\t\t\tif should_log_candidate {\n\t\t\t\t\t\t\t\t\tlog_trace!(logger, \"Ignoring {} with fee {total_fee_msat} due to exceeding max total routing fee limit {max_total_routing_fee_msat}.\", LoggedCandidateHop(&$candidate));\n\n\t\t\t\t\t\t\t\t\tif let Some(_) = first_hop_details {\n\t\t\t\t\t\t\t\t\t\tlog_trace!(logger,\n\t\t\t\t\t\t\t\t\t\t\t\"First hop candidate routing fee: {}. Limit: {}\",\n\t\t\t\t\t\t\t\t\t\t\ttotal_fee_msat,\n\t\t\t\t\t\t\t\t\t\t\tmax_total_routing_fee_msat,\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnum_ignored_total_fee_limit += 1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlet channel_usage = ChannelUsage {\n\t\t\t\t\t\t\t\t\tamount_msat: amount_to_transfer_over_msat,\n\t\t\t\t\t\t\t\t\tinflight_htlc_msat: used_liquidity_msat,\n\t\t\t\t\t\t\t\t\teffective_capacity,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tlet channel_penalty_msat =\n\t\t\t\t\t\t\t\t\tscorer.channel_penalty_msat($candidate,\n\t\t\t\t\t\t\t\t\t\tchannel_usage,\n\t\t\t\t\t\t\t\t\t\tscore_params);\n\t\t\t\t\t\t\t\tlet path_penalty_msat = $next_hops_path_penalty_msat\n\t\t\t\t\t\t\t\t\t.saturating_add(channel_penalty_msat);\n\n\t\t\t\t\t\t\t\t// Update the way of reaching $candidate.source()\n\t\t\t\t\t\t\t\t// with the given short_channel_id (from $candidate.target()),\n\t\t\t\t\t\t\t\t// if this way is cheaper than the already known\n\t\t\t\t\t\t\t\t// (considering the cost to \"reach\" this channel from the route destination,\n\t\t\t\t\t\t\t\t// the cost of using this channel,\n\t\t\t\t\t\t\t\t// and the cost of routing to the source node of this channel).\n\t\t\t\t\t\t\t\t// Also, consider that htlc_minimum_msat_difference, because we might end up\n\t\t\t\t\t\t\t\t// paying it. Consider the following exploit:\n\t\t\t\t\t\t\t\t// we use 2 paths to transfer 1.5 BTC. One of them is 0-fee normal 1 BTC path,\n\t\t\t\t\t\t\t\t// and for the other one we picked a 1sat-fee path with htlc_minimum_msat of\n\t\t\t\t\t\t\t\t// 1 BTC. Now, since the latter is more expensive, we gonna try to cut it\n\t\t\t\t\t\t\t\t// by 0.5 BTC, but then match htlc_minimum_msat by paying a fee of 0.5 BTC\n\t\t\t\t\t\t\t\t// to this channel.\n\t\t\t\t\t\t\t\t// Ideally the scoring could be smarter (e.g. 0.5*htlc_minimum_msat here),\n\t\t\t\t\t\t\t\t// but it may require additional tracking - we don't want to double-count\n\t\t\t\t\t\t\t\t// the fees included in $next_hops_path_htlc_minimum_msat, but also\n\t\t\t\t\t\t\t\t// can't use something that may decrease on future hops.\n\t\t\t\t\t\t\t\tlet old_fee_cost = cmp::max(old_entry.total_fee_msat, old_entry.path_htlc_minimum_msat)\n\t\t\t\t\t\t\t\t\t.saturating_add(old_entry.path_penalty_msat);\n\t\t\t\t\t\t\t\tlet new_fee_cost = cmp::max(total_fee_msat, path_htlc_minimum_msat)\n\t\t\t\t\t\t\t\t\t.saturating_add(path_penalty_msat);\n\t\t\t\t\t\t\t\t// The actual score we use for our heap is the cost divided by how\n\t\t\t\t\t\t\t\t// much we are thinking of sending over this channel. This avoids\n\t\t\t\t\t\t\t\t// prioritizing channels that have a very low fee because we aren't\n\t\t\t\t\t\t\t\t// sending very much over them.\n\t\t\t\t\t\t\t\t// In order to avoid integer division precision loss, we simply\n\t\t\t\t\t\t\t\t// shift the costs up to the top half of a u128 and divide by the\n\t\t\t\t\t\t\t\t// value (which is, at max, just under a u64).\n\t\t\t\t\t\t\t\tlet old_cost = if old_fee_cost != u64::MAX && old_entry.value_contribution_msat != 0 {\n\t\t\t\t\t\t\t\t\t((old_fee_cost as u128) << 64) / old_entry.value_contribution_msat as u128\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tu128::MAX\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tlet new_cost = if new_fee_cost != u64::MAX {\n\t\t\t\t\t\t\t\t\t// value_contribution_msat is always >= 1, checked above via\n\t\t\t\t\t\t\t\t\t// `contributes_sufficient_value`.\n\t\t\t\t\t\t\t\t\t((new_fee_cost as u128) << 64) / value_contribution_msat as u128\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tu128::MAX\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tif !old_entry.was_processed && new_cost < old_cost {\n\t\t\t\t\t\t\t\t\t#[cfg(all(not(ldk_bench), any(test, fuzzing)))]\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tassert!(!old_entry.best_path_from_hop_selected);\n\t\t\t\t\t\t\t\t\t\tassert!(hop_total_cltv_delta <= u16::MAX as u32);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tlet new_graph_node = RouteGraphNode {\n\t\t\t\t\t\t\t\t\t\tnode_counter: src_node_counter,\n\t\t\t\t\t\t\t\t\t\tscore: new_cost,\n\t\t\t\t\t\t\t\t\t\ttotal_cltv_delta: hop_total_cltv_delta as u16,\n\t\t\t\t\t\t\t\t\t\tvalue_contribution_msat,\n\t\t\t\t\t\t\t\t\t\tpath_length_to_node,\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\ttargets.push(new_graph_node);\n\t\t\t\t\t\t\t\t\told_entry.next_hops_fee_msat = $next_hops_fee_msat;\n\t\t\t\t\t\t\t\t\told_entry.hop_use_fee_msat = hop_use_fee_msat;\n\t\t\t\t\t\t\t\t\told_entry.total_fee_msat = total_fee_msat;\n\t\t\t\t\t\t\t\t\told_entry.candidate = $candidate.clone();\n\t\t\t\t\t\t\t\t\told_entry.fee_msat = 0; // This value will be later filled with hop_use_fee_msat of the following channel\n\t\t\t\t\t\t\t\t\told_entry.path_htlc_minimum_msat = path_htlc_minimum_msat;\n\t\t\t\t\t\t\t\t\told_entry.path_penalty_msat = path_penalty_msat;\n\t\t\t\t\t\t\t\t\told_entry.value_contribution_msat = value_contribution_msat;\n\t\t\t\t\t\t\t\t\thop_contribution_amt_msat = Some(value_contribution_msat);\n\t\t\t\t\t\t\t\t} else if old_entry.was_processed && new_cost < old_cost {\n\t\t\t\t\t\t\t\t\t#[cfg(all(not(ldk_bench), any(test, fuzzing)))]\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t// If we're skipping processing a node which was previously\n\t\t\t\t\t\t\t\t\t\t// processed even though we found another path to it with a\n\t\t\t\t\t\t\t\t\t\t// cheaper fee, check that it was because the second path we\n\t\t\t\t\t\t\t\t\t\t// found (which we are processing now) has a lower value\n\t\t\t\t\t\t\t\t\t\t// contribution due to an HTLC minimum limit.\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t// e.g. take a graph with two paths from node 1 to node 2, one\n\t\t\t\t\t\t\t\t\t\t// through channel A, and one through channel B. Channel A and\n\t\t\t\t\t\t\t\t\t\t// B are both in the to-process heap, with their scores set by\n\t\t\t\t\t\t\t\t\t\t// a higher htlc_minimum than fee.\n\t\t\t\t\t\t\t\t\t\t// Channel A is processed first, and the channels onwards from\n\t\t\t\t\t\t\t\t\t\t// node 1 are added to the to-process heap. Thereafter, we pop\n\t\t\t\t\t\t\t\t\t\t// Channel B off of the heap, note that it has a much more\n\t\t\t\t\t\t\t\t\t\t// restrictive htlc_maximum_msat, and recalculate the fees for\n\t\t\t\t\t\t\t\t\t\t// all of node 1's channels using the new, reduced, amount.\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t// This would be bogus - we'd be selecting a higher-fee path\n\t\t\t\t\t\t\t\t\t\t// with a lower htlc_maximum_msat instead of the one we'd\n\t\t\t\t\t\t\t\t\t\t// already decided to use.\n\t\t\t\t\t\t\t\t\t\tdebug_assert!(path_htlc_minimum_msat < old_entry.path_htlc_minimum_msat);\n\t\t\t\t\t\t\t\t\t\tdebug_assert!(\n\t\t\t\t\t\t\t\t\t\t\tvalue_contribution_msat + path_penalty_msat <\n\t\t\t\t\t\t\t\t\t\t\told_entry.value_contribution_msat + old_entry.path_penalty_msat\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif should_log_candidate {\n\t\t\t\t\t\t\tlog_trace!(logger,\n\t\t\t\t\t\t\t\t\"Ignoring {} due to its htlc_minimum_msat limit.\",\n\t\t\t\t\t\t\t\tLoggedCandidateHop(&$candidate));\n\n\t\t\t\t\t\t\tif let Some(details) = first_hop_details {\n\t\t\t\t\t\t\t\tlog_trace!(logger,\n\t\t\t\t\t\t\t\t\t\"First hop candidate next_outbound_htlc_minimum_msat: {}\",\n\t\t\t\t\t\t\t\t\tdetails.next_outbound_htlc_minimum_msat,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnum_ignored_htlc_minimum_msat_limit += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\thop_contribution_amt_msat\n\t\t} }\n\t}\n\n\tlet default_node_features = default_node_features();\n\n\t// Find ways (channels with destination) to reach a given node and store them\n\t// in the corresponding data structures (routing graph etc).\n\t// $fee_to_target_msat represents how much it costs to reach to this node from the payee,\n\t// meaning how much will be paid in fees after this node (to the best of our knowledge).\n\t// This data can later be helpful to optimize routing (pay lower fees).\n\tmacro_rules! add_entries_to_cheapest_to_target_node {\n\t\t( $node_counter: expr, $node_id: expr, $next_hops_value_contribution: expr,\n\t\t  $next_hops_cltv_delta: expr, $next_hops_path_length: expr ) => {\n\t\t\tlet fee_to_target_msat;\n\t\t\tlet next_hops_path_htlc_minimum_msat;\n\t\t\tlet next_hops_path_penalty_msat;\n\t\t\tlet (is_first_hop_target, is_last_hop_target);\n\t\t\tlet skip_node = if let Some(elem) = &mut dist[$node_counter as usize] {\n\t\t\t\tlet was_processed = elem.was_processed;\n\t\t\t\telem.was_processed = true;\n\t\t\t\tfee_to_target_msat = elem.total_fee_msat;\n\t\t\t\tnext_hops_path_htlc_minimum_msat = elem.path_htlc_minimum_msat;\n\t\t\t\tnext_hops_path_penalty_msat = elem.path_penalty_msat;\n\t\t\t\tis_first_hop_target = elem.is_first_hop_target;\n\t\t\t\tis_last_hop_target = elem.is_last_hop_target;\n\t\t\t\twas_processed\n\t\t\t} else {\n\t\t\t\t// Entries are added to dist in add_entry!() when there is a channel from a node.\n\t\t\t\t// Because there are no channels from payee, it will not have a dist entry at this point.\n\t\t\t\t// If we're processing any other node, it is always be the result of a channel from it.\n\t\t\t\tdebug_assert_eq!($node_id, maybe_dummy_payee_node_id);\n\n\t\t\t\tfee_to_target_msat = 0;\n\t\t\t\tnext_hops_path_htlc_minimum_msat = 0;\n\t\t\t\tnext_hops_path_penalty_msat = 0;\n\t\t\t\tis_first_hop_target = false;\n\t\t\t\tis_last_hop_target = false;\n\t\t\t\tfalse\n\t\t\t};\n\n\t\t\tif !skip_node {\n\t\t\t\tif is_last_hop_target {\n\t\t\t\t\tif let Some(candidates) = last_hop_candidates.get(&$node_counter) {\n\t\t\t\t\t\tfor candidate in candidates {\n\t\t\t\t\t\t\tadd_entry!(candidate, fee_to_target_msat,\n\t\t\t\t\t\t\t\t$next_hops_value_contribution,\n\t\t\t\t\t\t\t\tnext_hops_path_htlc_minimum_msat, next_hops_path_penalty_msat,\n\t\t\t\t\t\t\t\t$next_hops_cltv_delta, $next_hops_path_length);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif is_first_hop_target {\n\t\t\t\t\tif let Some((first_channels, peer_node_counter)) = first_hop_targets.get(&$node_id) {\n\t\t\t\t\t\tfor details in first_channels {\n\t\t\t\t\t\t\tdebug_assert_eq!(*peer_node_counter, $node_counter);\n\t\t\t\t\t\t\tlet candidate = CandidateRouteHop::FirstHop(FirstHopCandidate {\n\t\t\t\t\t\t\t\tdetails, payer_node_id: &our_node_id, payer_node_counter,\n\t\t\t\t\t\t\t\ttarget_node_counter: $node_counter,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tadd_entry!(&candidate, fee_to_target_msat,\n\t\t\t\t\t\t\t\t$next_hops_value_contribution,\n\t\t\t\t\t\t\t\tnext_hops_path_htlc_minimum_msat, next_hops_path_penalty_msat,\n\t\t\t\t\t\t\t\t$next_hops_cltv_delta, $next_hops_path_length);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif let Some(node) = network_nodes.get(&$node_id) {\n\t\t\t\t\tlet features = if let Some(node_info) = node.announcement_info.as_ref() {\n\t\t\t\t\t\t&node_info.features()\n\t\t\t\t\t} else {\n\t\t\t\t\t\t&default_node_features\n\t\t\t\t\t};\n\n\t\t\t\t\tif !features.requires_unknown_bits() {\n\t\t\t\t\t\tfor chan_id in node.channels.iter() {\n\t\t\t\t\t\t\tlet chan = network_channels.get(chan_id).unwrap();\n\t\t\t\t\t\t\tif !chan.features.requires_unknown_bits() {\n\t\t\t\t\t\t\t\tif let Some((directed_channel, source)) = chan.as_directed_to(&$node_id) {\n\t\t\t\t\t\t\t\t\tif first_hops.is_none() || *source != our_node_id {\n\t\t\t\t\t\t\t\t\t\tif directed_channel.direction().enabled {\n\t\t\t\t\t\t\t\t\t\t\tlet candidate = CandidateRouteHop::PublicHop(PublicHopCandidate {\n\t\t\t\t\t\t\t\t\t\t\t\tinfo: directed_channel,\n\t\t\t\t\t\t\t\t\t\t\t\tshort_channel_id: *chan_id,\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\tadd_entry!(&candidate,\n\t\t\t\t\t\t\t\t\t\t\t\tfee_to_target_msat,\n\t\t\t\t\t\t\t\t\t\t\t\t$next_hops_value_contribution,\n\t\t\t\t\t\t\t\t\t\t\t\tnext_hops_path_htlc_minimum_msat,\n\t\t\t\t\t\t\t\t\t\t\t\tnext_hops_path_penalty_msat,\n\t\t\t\t\t\t\t\t\t\t\t\t$next_hops_cltv_delta, $next_hops_path_length);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tlet mut payment_paths = Vec::<PaymentPath>::new();\n\n\t// TODO: diversify by nodes (so that all paths aren't doomed if one node is offline).\n\t'paths_collection: loop {\n\t\t// For every new path, start from scratch, except for used_liquidities, which\n\t\t// helps to avoid reusing previously selected paths in future iterations.\n\t\ttargets.clear();\n\t\tfor e in dist.iter_mut() {\n\t\t\t*e = None;\n\t\t}\n\n\t\t// Step (2).\n\t\t// Add entries for first-hop and last-hop channel hints to `dist` and add the payee node as\n\t\t// the best entry via `add_entry`.\n\t\t// For first- and last-hop hints we need only add dummy entries in `dist` with the relevant\n\t\t// flags set. As we walk the graph in `add_entries_to_cheapest_to_target_node` we'll check\n\t\t// those flags and add the channels described by the hints.\n\t\t// We then either add the payee using `add_entries_to_cheapest_to_target_node` or add the\n\t\t// blinded paths to the payee using `add_entry`, filling `targets` and setting us up for\n\t\t// our graph walk.\n\t\tfor (_, (chans, peer_node_counter)) in first_hop_targets.iter() {\n\t\t\t// In order to avoid looking up whether each node is a first-hop target, we store a\n\t\t\t// dummy entry in dist for each first-hop target, allowing us to do this lookup for\n\t\t\t// free since we're already looking at the `was_processed` flag.\n\t\t\t//\n\t\t\t// Note that all the fields (except `is_{first,last}_hop_target`) will be overwritten\n\t\t\t// whenever we find a path to the target, so are left as dummies here.\n\t\t\tdist[*peer_node_counter as usize] = Some(PathBuildingHop {\n\t\t\t\tcandidate: CandidateRouteHop::FirstHop(FirstHopCandidate {\n\t\t\t\t\tdetails: &chans[0],\n\t\t\t\t\tpayer_node_id: &our_node_id,\n\t\t\t\t\ttarget_node_counter: u32::max_value(),\n\t\t\t\t\tpayer_node_counter: u32::max_value(),\n\t\t\t\t}),\n\t\t\t\tfee_msat: 0,\n\t\t\t\tnext_hops_fee_msat: u64::max_value(),\n\t\t\t\thop_use_fee_msat: u64::max_value(),\n\t\t\t\ttotal_fee_msat: u64::max_value(),\n\t\t\t\tpath_htlc_minimum_msat: u64::max_value(),\n\t\t\t\tpath_penalty_msat: u64::max_value(),\n\t\t\t\twas_processed: false,\n\t\t\t\tis_first_hop_target: true,\n\t\t\t\tis_last_hop_target: false,\n\t\t\t\tvalue_contribution_msat: 0,\n\t\t\t\t#[cfg(all(not(ldk_bench), any(test, fuzzing)))]\n\t\t\t\tbest_path_from_hop_selected: false,\n\t\t\t});\n\t\t}\n\t\tfor (target_node_counter, candidates) in last_hop_candidates.iter() {\n\t\t\t// In order to avoid looking up whether each node is a last-hop target, we store a\n\t\t\t// dummy entry in dist for each last-hop target, allowing us to do this lookup for\n\t\t\t// free since we're already looking at the `was_processed` flag.\n\t\t\t//\n\t\t\t// Note that all the fields (except `is_{first,last}_hop_target`) will be overwritten\n\t\t\t// whenever we find a path to the target, so are left as dummies here.\n\t\t\tdebug_assert!(!candidates.is_empty());\n\t\t\tif candidates.is_empty() { continue }\n\t\t\tlet entry = &mut dist[**target_node_counter as usize];\n\t\t\tif let Some(hop) = entry {\n\t\t\t\thop.is_last_hop_target = true;\n\t\t\t} else {\n\t\t\t\t*entry = Some(PathBuildingHop {\n\t\t\t\t\tcandidate: candidates[0].clone(),\n\t\t\t\t\tfee_msat: 0,\n\t\t\t\t\tnext_hops_fee_msat: u64::max_value(),\n\t\t\t\t\thop_use_fee_msat: u64::max_value(),\n\t\t\t\t\ttotal_fee_msat: u64::max_value(),\n\t\t\t\t\tpath_htlc_minimum_msat: u64::max_value(),\n\t\t\t\t\tpath_penalty_msat: u64::max_value(),\n\t\t\t\t\twas_processed: false,\n\t\t\t\t\tis_first_hop_target: false,\n\t\t\t\t\tis_last_hop_target: true,\n\t\t\t\t\tvalue_contribution_msat: 0,\n\t\t\t\t\t#[cfg(all(not(ldk_bench), any(test, fuzzing)))]\n\t\t\t\t\tbest_path_from_hop_selected: false,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\thit_minimum_limit = false;\n\n\t\tif let Some(payee) = payee_node_id_opt {\n\t\t\tif let Some(entry) = &mut dist[payee_node_counter as usize] {\n\t\t\t\t// If we built a dummy entry above we need to reset the values to represent 0 fee\n\t\t\t\t// from the target \"to the target\".\n\t\t\t\tentry.next_hops_fee_msat = 0;\n\t\t\t\tentry.hop_use_fee_msat = 0;\n\t\t\t\tentry.total_fee_msat = 0;\n\t\t\t\tentry.path_htlc_minimum_msat = 0;\n\t\t\t\tentry.path_penalty_msat = 0;\n\t\t\t\tentry.value_contribution_msat = path_value_msat;\n\t\t\t}\n\t\t\tadd_entries_to_cheapest_to_target_node!(\n\t\t\t\tpayee_node_counter, payee, path_value_msat, 0, 0\n\t\t\t);\n\t\t}\n\n\t\tdebug_assert_eq!(\n\t\t\tpayment_params.payee.blinded_route_hints().len(),\n\t\t\tintroduction_node_id_cache.len(),\n\t\t\t\"introduction_node_id_cache was built by iterating the blinded_route_hints, so they should be the same len\"\n\t\t);\n\t\tlet mut blind_intros_added = hash_map_with_capacity(payment_params.payee.blinded_route_hints().len());\n\t\tfor (hint_idx, hint) in payment_params.payee.blinded_route_hints().iter().enumerate() {\n\t\t\t// Only add the hops in this route to our candidate set if either\n\t\t\t// we have a direct channel to the first hop or the first hop is\n\t\t\t// in the regular network graph.\n\t\t\tlet source_node_opt = introduction_node_id_cache[hint_idx];\n\t\t\tlet (source_node_id, source_node_counter) = if let Some(v) = source_node_opt { v } else { continue };\n\t\t\tif our_node_id == *source_node_id { continue }\n\t\t\tlet candidate = if hint.blinded_hops().len() == 1 {\n\t\t\t\tCandidateRouteHop::OneHopBlinded(\n\t\t\t\t\tOneHopBlindedPathCandidate { source_node_counter, source_node_id, hint, hint_idx }\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tCandidateRouteHop::Blinded(BlindedPathCandidate { source_node_counter, source_node_id, hint, hint_idx })\n\t\t\t};\n\t\t\tif let Some(hop_used_msat) = add_entry!(&candidate,\n\t\t\t\t0, path_value_msat, 0, 0_u64, 0, 0)\n\t\t\t{\n\t\t\t\tblind_intros_added.insert(source_node_id, (hop_used_msat, candidate));\n\t\t\t} else { continue }\n\t\t}\n\t\t// If we added a blinded path from an introduction node to the destination, where the\n\t\t// introduction node is one of our direct peers, we need to scan our `first_channels`\n\t\t// to detect this. However, doing so immediately after calling `add_entry`, above, could\n\t\t// result in incorrect behavior if we, in a later loop iteration, update the fee from the\n\t\t// same introduction point to the destination (due to a different blinded path with the\n\t\t// same introduction point having a lower score).\n\t\t// Thus, we track the nodes that we added paths from in `blind_intros_added` and scan for\n\t\t// introduction points we have a channel with after processing all blinded paths.\n\t\tfor (source_node_id, (path_contribution_msat, candidate)) in blind_intros_added {\n\t\t\tif let Some((first_channels, peer_node_counter)) = first_hop_targets.get_mut(source_node_id) {\n\t\t\t\tsort_first_hop_channels(\n\t\t\t\t\tfirst_channels, &used_liquidities, recommended_value_msat, our_node_pubkey\n\t\t\t\t);\n\t\t\t\tfor details in first_channels {\n\t\t\t\t\tlet first_hop_candidate = CandidateRouteHop::FirstHop(FirstHopCandidate {\n\t\t\t\t\t\tdetails, payer_node_id: &our_node_id, payer_node_counter,\n\t\t\t\t\t\ttarget_node_counter: *peer_node_counter,\n\t\t\t\t\t});\n\t\t\t\t\tlet blinded_path_fee = match compute_fees(path_contribution_msat, candidate.fees()) {\n\t\t\t\t\t\tSome(fee) => fee,\n\t\t\t\t\t\tNone => continue\n\t\t\t\t\t};\n\t\t\t\t\tlet path_min = candidate.htlc_minimum_msat().saturating_add(\n\t\t\t\t\t\tcompute_fees_saturating(candidate.htlc_minimum_msat(), candidate.fees()));\n\t\t\t\t\tadd_entry!(&first_hop_candidate, blinded_path_fee, path_contribution_msat, path_min,\n\t\t\t\t\t\t0_u64, candidate.cltv_expiry_delta(), 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlog_trace!(logger, \"Starting main path collection loop with {} nodes pre-filled from first/last hops.\", targets.len());\n\n\t\t// At this point, targets are filled with the data from first and\n\t\t// last hops communicated by the caller, and the payment receiver.\n\t\tlet mut found_new_path = false;\n\n\t\t// Step (3).\n\t\t// If this loop terminates due the exhaustion of targets, two situations are possible:\n\t\t// - not enough outgoing liquidity:\n\t\t//   0 < already_collected_value_msat < final_value_msat\n\t\t// - enough outgoing liquidity:\n\t\t//   final_value_msat <= already_collected_value_msat < recommended_value_msat\n\t\t// Both these cases (and other cases except reaching recommended_value_msat) mean that\n\t\t// paths_collection will be stopped because found_new_path==false.\n\t\t// This is not necessarily a routing failure.\n\t\t'path_construction: while let Some(RouteGraphNode { node_counter, total_cltv_delta, mut value_contribution_msat, path_length_to_node, .. }) = targets.pop() {\n\n\t\t\t// Since we're going payee-to-payer, hitting our node as a target means we should stop\n\t\t\t// traversing the graph and arrange the path out of what we found.\n\t\t\tif node_counter == payer_node_counter {\n\t\t\t\tlet mut new_entry = dist[payer_node_counter as usize].take().unwrap();\n\t\t\t\tlet mut ordered_hops: Vec<(PathBuildingHop, NodeFeatures)> = vec!((new_entry.clone(), default_node_features.clone()));\n\n\t\t\t\t'path_walk: loop {\n\t\t\t\t\tlet mut features_set = false;\n\t\t\t\t\tlet candidate = &ordered_hops.last().unwrap().0.candidate;\n\t\t\t\t\tlet target = candidate.target().unwrap_or(maybe_dummy_payee_node_id);\n\t\t\t\t\tlet target_node_counter = candidate.target_node_counter();\n\t\t\t\t\tif let Some((first_channels, _)) = first_hop_targets.get(&target) {\n\t\t\t\t\t\tfor details in first_channels {\n\t\t\t\t\t\t\tif let CandidateRouteHop::FirstHop(FirstHopCandidate { details: last_hop_details, .. })\n\t\t\t\t\t\t\t\t= candidate\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif details.get_outbound_payment_scid() == last_hop_details.get_outbound_payment_scid() {\n\t\t\t\t\t\t\t\t\tordered_hops.last_mut().unwrap().1 = details.counterparty.features.to_context();\n\t\t\t\t\t\t\t\t\tfeatures_set = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif !features_set {\n\t\t\t\t\t\tif let Some(node) = network_nodes.get(&target) {\n\t\t\t\t\t\t\tif let Some(node_info) = node.announcement_info.as_ref() {\n\t\t\t\t\t\t\t\tordered_hops.last_mut().unwrap().1 = node_info.features().clone();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tordered_hops.last_mut().unwrap().1 = default_node_features.clone();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// We can fill in features for everything except hops which were\n\t\t\t\t\t\t\t// provided via the invoice we're paying. We could guess based on the\n\t\t\t\t\t\t\t// recipient's features but for now we simply avoid guessing at all.\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Means we successfully traversed from the payer to the payee, now\n\t\t\t\t\t// save this path for the payment route. Also, update the liquidity\n\t\t\t\t\t// remaining on the used hops, so that we take them into account\n\t\t\t\t\t// while looking for more paths.\n\t\t\t\t\tif target_node_counter.is_none() {\n\t\t\t\t\t\tbreak 'path_walk;\n\t\t\t\t\t}\n\t\t\t\t\tif target_node_counter == Some(payee_node_counter) { break 'path_walk; }\n\n\t\t\t\t\tnew_entry = match dist[target_node_counter.unwrap() as usize].take() {\n\t\t\t\t\t\tSome(payment_hop) => payment_hop,\n\t\t\t\t\t\t// We can't arrive at None because, if we ever add an entry to targets,\n\t\t\t\t\t\t// we also fill in the entry in dist (see add_entry!).\n\t\t\t\t\t\tNone => unreachable!(),\n\t\t\t\t\t};\n\t\t\t\t\t// We \"propagate\" the fees one hop backward (topologically) here,\n\t\t\t\t\t// so that fees paid for a HTLC forwarding on the current channel are\n\t\t\t\t\t// associated with the previous channel (where they will be subtracted).\n\t\t\t\t\tordered_hops.last_mut().unwrap().0.fee_msat = new_entry.hop_use_fee_msat;\n\t\t\t\t\tordered_hops.push((new_entry.clone(), default_node_features.clone()));\n\t\t\t\t}\n\t\t\t\tordered_hops.last_mut().unwrap().0.fee_msat = value_contribution_msat;\n\t\t\t\tordered_hops.last_mut().unwrap().0.hop_use_fee_msat = 0;\n\n\t\t\t\tlog_trace!(logger, \"Found a path back to us from the target with {} hops contributing up to {} msat: \\n {:#?}\",\n\t\t\t\t\tordered_hops.len(), value_contribution_msat, ordered_hops.iter().map(|h| &(h.0)).collect::<Vec<&PathBuildingHop>>());\n\n\t\t\t\tlet mut payment_path = PaymentPath {hops: ordered_hops};\n\n\t\t\t\t// We could have possibly constructed a slightly inconsistent path: since we reduce\n\t\t\t\t// value being transferred along the way, we could have violated htlc_minimum_msat\n\t\t\t\t// on some channels we already passed (assuming dest->source direction). Here, we\n\t\t\t\t// recompute the fees again, so that if that's the case, we match the currently\n\t\t\t\t// underpaid htlc_minimum_msat with fees.\n\t\t\t\tdebug_assert_eq!(payment_path.get_value_msat(), value_contribution_msat);\n\t\t\t\tlet max_path_contribution_msat = payment_path.compute_max_final_value_contribution(\n\t\t\t\t\t&used_liquidities, channel_saturation_pow_half\n\t\t\t\t);\n\t\t\t\tlet desired_value_contribution = cmp::min(max_path_contribution_msat, final_value_msat);\n\t\t\t\tvalue_contribution_msat = payment_path.update_value_and_recompute_fees(desired_value_contribution);\n\n\t\t\t\t// Since a path allows to transfer as much value as\n\t\t\t\t// the smallest channel it has (\"bottleneck\"), we should recompute\n\t\t\t\t// the fees so sender HTLC don't overpay fees when traversing\n\t\t\t\t// larger channels than the bottleneck. This may happen because\n\t\t\t\t// when we were selecting those channels we were not aware how much value\n\t\t\t\t// this path will transfer, and the relative fee for them\n\t\t\t\t// might have been computed considering a larger value.\n\t\t\t\t// Remember that we used these channels so that we don't rely\n\t\t\t\t// on the same liquidity in future paths.\n\t\t\t\tfor (hop, _) in payment_path.hops.iter() {\n\t\t\t\t\tlet spent_on_hop_msat = value_contribution_msat + hop.next_hops_fee_msat;\n\t\t\t\t\tlet used_liquidity_msat = used_liquidities\n\t\t\t\t\t\t.entry(hop.candidate.id())\n\t\t\t\t\t\t.and_modify(|used_liquidity_msat| *used_liquidity_msat += spent_on_hop_msat)\n\t\t\t\t\t\t.or_insert(spent_on_hop_msat);\n\t\t\t\t\tlet hop_capacity = hop.candidate.effective_capacity();\n\t\t\t\t\tlet hop_max_msat = max_htlc_from_capacity(hop_capacity, channel_saturation_pow_half);\n\t\t\t\t\tdebug_assert!(*used_liquidity_msat <= hop_max_msat);\n\t\t\t\t}\n\t\t\t\tif max_path_contribution_msat > value_contribution_msat {\n\t\t\t\t\t// If we weren't capped by hitting a liquidity limit on a channel in the path,\n\t\t\t\t\t// we'll probably end up picking the same path again on the next iteration.\n\t\t\t\t\t// Decrease the available liquidity of a hop in the middle of the path.\n\t\t\t\t\tlet victim_candidate = &payment_path.hops[(payment_path.hops.len()) / 2].0.candidate;\n\t\t\t\t\tlet exhausted = u64::max_value();\n\t\t\t\t\tlog_trace!(logger,\n\t\t\t\t\t\t\"Disabling route candidate {} for future path building iterations to avoid duplicates.\",\n\t\t\t\t\t\tLoggedCandidateHop(victim_candidate));\n\t\t\t\t\tif let Some(scid) = victim_candidate.short_channel_id() {\n\t\t\t\t\t\t*used_liquidities.entry(CandidateHopId::Clear((scid, false))).or_default() = exhausted;\n\t\t\t\t\t\t*used_liquidities.entry(CandidateHopId::Clear((scid, true))).or_default() = exhausted;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track the total amount all our collected paths allow to send so that we know\n\t\t\t\t// when to stop looking for more paths\n\t\t\t\talready_collected_value_msat += value_contribution_msat;\n\n\t\t\t\tpayment_paths.push(payment_path);\n\t\t\t\tfound_new_path = true;\n\t\t\t\tbreak 'path_construction;\n\t\t\t}\n\n\t\t\t// If we found a path back to the payee, we shouldn't try to process it again. This is\n\t\t\t// the equivalent of the `elem.was_processed` check in\n\t\t\t// add_entries_to_cheapest_to_target_node!() (see comment there for more info).\n\t\t\tif node_counter == payee_node_counter { continue 'path_construction; }\n\n\t\t\tlet node_id = if let Some(entry) = &dist[node_counter as usize] {\n\t\t\t\tentry.candidate.source()\n\t\t\t} else {\n\t\t\t\tdebug_assert!(false, \"Best nodes in the heap should have entries in dist\");\n\t\t\t\tcontinue 'path_construction;\n\t\t\t};\n\n\t\t\t// Otherwise, since the current target node is not us,\n\t\t\t// keep \"unrolling\" the payment graph from payee to payer by\n\t\t\t// finding a way to reach the current target from the payer side.\n\t\t\tadd_entries_to_cheapest_to_target_node!(\n\t\t\t\tnode_counter, node_id,\n\t\t\t\tvalue_contribution_msat,\n\t\t\t\ttotal_cltv_delta, path_length_to_node\n\t\t\t);\n\t\t}\n\n\t\tif !allow_mpp {\n\t\t\tif !found_new_path && channel_saturation_pow_half != 0 {\n\t\t\t\tchannel_saturation_pow_half = 0;\n\t\t\t\tcontinue 'paths_collection;\n\t\t\t}\n\t\t\t// If we don't support MPP, no use trying to gather more value ever.\n\t\t\tbreak 'paths_collection;\n\t\t}\n\n\t\t// Step (4).\n\t\t// Stop either when the recommended value is reached or if no new path was found in this\n\t\t// iteration.\n\t\t// In the latter case, making another path finding attempt won't help,\n\t\t// because we deterministically terminated the search due to low liquidity.\n\t\tif !found_new_path && channel_saturation_pow_half != 0 {\n\t\t\tchannel_saturation_pow_half = 0;\n\t\t} else if !found_new_path && hit_minimum_limit && already_collected_value_msat < final_value_msat && path_value_msat != recommended_value_msat {\n\t\t\tlog_trace!(logger, \"Failed to collect enough value, but running again to collect extra paths with a potentially higher limit.\");\n\t\t\tpath_value_msat = recommended_value_msat;\n\t\t} else if already_collected_value_msat >= recommended_value_msat || !found_new_path {\n\t\t\tlog_trace!(logger, \"Have now collected {} msat (seeking {} msat) in paths. Last path loop {} a new path.\",\n\t\t\t\talready_collected_value_msat, recommended_value_msat, if found_new_path { \"found\" } else { \"did not find\" });\n\t\t\tbreak 'paths_collection;\n\t\t} else if found_new_path && already_collected_value_msat == final_value_msat && payment_paths.len() == 1 {\n\t\t\t// Further, if this was our first walk of the graph, and we weren't limited by an\n\t\t\t// htlc_minimum_msat, return immediately because this path should suffice. If we were\n\t\t\t// limited by an htlc_minimum_msat value, find another path with a higher value,\n\t\t\t// potentially allowing us to pay fees to meet the htlc_minimum on the new path while\n\t\t\t// still keeping a lower total fee than this path.\n\t\t\tif !hit_minimum_limit {\n\t\t\t\tlog_trace!(logger, \"Collected exactly our payment amount on the first pass, without hitting an htlc_minimum_msat limit, exiting.\");\n\t\t\t\tbreak 'paths_collection;\n\t\t\t}\n\t\t\tlog_trace!(logger, \"Collected our payment amount on the first pass, but running again to collect extra paths with a potentially higher value to meet htlc_minimum_msat limit.\");\n\t\t\tpath_value_msat = recommended_value_msat;\n\t\t}\n\t}\n\n\tlet num_ignored_total = num_ignored_value_contribution + num_ignored_path_length_limit +\n\t\tnum_ignored_cltv_delta_limit + num_ignored_previously_failed +\n\t\tnum_ignored_avoid_overpayment + num_ignored_htlc_minimum_msat_limit +\n\t\tnum_ignored_total_fee_limit;\n\tif num_ignored_total > 0 {\n\t\tlog_trace!(logger,\n\t\t\t\"Ignored {} candidate hops due to insufficient value contribution, {} due to path length limit, {} due to CLTV delta limit, {} due to previous payment failure, {} due to htlc_minimum_msat limit, {} to avoid overpaying, {} due to maximum total fee limit. Total: {} ignored candidates.\",\n\t\t\tnum_ignored_value_contribution, num_ignored_path_length_limit,\n\t\t\tnum_ignored_cltv_delta_limit, num_ignored_previously_failed,\n\t\t\tnum_ignored_htlc_minimum_msat_limit, num_ignored_avoid_overpayment,\n\t\t\tnum_ignored_total_fee_limit, num_ignored_total);\n\t}\n\n\t// Step (5).\n\tif payment_paths.len() == 0 {\n\t\treturn Err(LightningError{err: \"Failed to find a path to the given destination\".to_owned(), action: ErrorAction::IgnoreError});\n\t}\n\n\tif already_collected_value_msat < final_value_msat {\n\t\treturn Err(LightningError{err: \"Failed to find a sufficient route to the given destination\".to_owned(), action: ErrorAction::IgnoreError});\n\t}\n\n\t// Step (6).\n\tlet mut selected_route = payment_paths;\n\n\tdebug_assert_eq!(selected_route.iter().map(|p| p.get_value_msat()).sum::<u64>(), already_collected_value_msat);\n\tlet mut overpaid_value_msat = already_collected_value_msat - final_value_msat;\n\n\t// First, sort by the cost-per-value of the path, dropping the paths that cost the most for\n\t// the value they contribute towards the payment amount.\n\t// We sort in descending order as we will remove from the front in `retain`, next.\n\tselected_route.sort_unstable_by(|a, b| b.get_cost_per_msat().cmp(&a.get_cost_per_msat()));\n\n\t// We should make sure that at least 1 path left.\n\tlet mut paths_left = selected_route.len();\n\tselected_route.retain(|path| {\n\t\tif paths_left == 1 {\n\t\t\treturn true\n\t\t}\n\t\tlet path_value_msat = path.get_value_msat();\n\t\tif path_value_msat <= overpaid_value_msat {\n\t\t\toverpaid_value_msat -= path_value_msat;\n\t\t\tpaths_left -= 1;\n\t\t\treturn false;\n\t\t}\n\t\ttrue\n\t});\n\tdebug_assert!(selected_route.len() > 0);\n\n\tif overpaid_value_msat != 0 {\n\t\t// Step (7).\n\t\t// Now, subtract the remaining overpaid value from the most-expensive path.\n\t\t// TODO: this could also be optimized by also sorting by feerate_per_sat_routed,\n\t\t// so that the sender pays less fees overall. And also htlc_minimum_msat.\n\t\tselected_route.sort_unstable_by(|a, b| {\n\t\t\tlet a_f = a.hops.iter().map(|hop| hop.0.candidate.fees().proportional_millionths as u64).sum::<u64>();\n\t\t\tlet b_f = b.hops.iter().map(|hop| hop.0.candidate.fees().proportional_millionths as u64).sum::<u64>();\n\t\t\ta_f.cmp(&b_f).then_with(|| b.get_cost_msat().cmp(&a.get_cost_msat()))\n\t\t});\n\t\tlet expensive_payment_path = selected_route.first_mut().unwrap();\n\n\t\t// We already dropped all the paths with value below `overpaid_value_msat` above, thus this\n\t\t// can't go negative.\n\t\tlet expensive_path_new_value_msat = expensive_payment_path.get_value_msat() - overpaid_value_msat;\n\t\texpensive_payment_path.update_value_and_recompute_fees(expensive_path_new_value_msat);\n\t}\n\n\t// Step (8).\n\t// Sort by the path itself and combine redundant paths.\n\t// Note that we sort by SCIDs alone as its simpler but when combining we have to ensure we\n\t// compare both SCIDs and NodeIds as individual nodes may use random aliases causing collisions\n\t// across nodes.\n\tselected_route.sort_unstable_by_key(|path| {\n\t\tlet mut key = [CandidateHopId::Clear((42, true)) ; MAX_PATH_LENGTH_ESTIMATE as usize];\n\t\tdebug_assert!(path.hops.len() <= key.len());\n\t\tfor (scid, key) in path.hops.iter() .map(|h| h.0.candidate.id()).zip(key.iter_mut()) {\n\t\t\t*key = scid;\n\t\t}\n\t\tkey\n\t});\n\tfor idx in 0..(selected_route.len() - 1) {\n\t\tif idx + 1 >= selected_route.len() { break; }\n\t\tif iter_equal(selected_route[idx    ].hops.iter().map(|h| (h.0.candidate.id(), h.0.candidate.target())),\n\t\t              selected_route[idx + 1].hops.iter().map(|h| (h.0.candidate.id(), h.0.candidate.target()))) {\n\t\t\tlet new_value = selected_route[idx].get_value_msat() + selected_route[idx + 1].get_value_msat();\n\t\t\tselected_route[idx].update_value_and_recompute_fees(new_value);\n\t\t\tselected_route.remove(idx + 1);\n\t\t}\n\t}\n\n\tlet mut paths = Vec::new();\n\tfor payment_path in selected_route {\n\t\tlet mut hops = Vec::with_capacity(payment_path.hops.len());\n\t\tfor (hop, node_features) in payment_path.hops.iter()\n\t\t\t.filter(|(h, _)| h.candidate.short_channel_id().is_some())\n\t\t{\n\t\t\tlet target = hop.candidate.target().expect(\"target is defined when short_channel_id is defined\");\n\t\t\tlet maybe_announced_channel = if let CandidateRouteHop::PublicHop(_) = hop.candidate {\n\t\t\t\t// If we sourced the hop from the graph we're sure the target node is announced.\n\t\t\t\ttrue\n\t\t\t} else if let CandidateRouteHop::FirstHop(first_hop) = &hop.candidate {\n\t\t\t\t// If this is a first hop we also know if it's announced.\n\t\t\t\tfirst_hop.details.is_announced\n\t\t\t} else {\n\t\t\t\t// If we sourced it any other way, we double-check the network graph to see if\n\t\t\t\t// there are announced channels between the endpoints. If so, the hop might be\n\t\t\t\t// referring to any of the announced channels, as its `short_channel_id` might be\n\t\t\t\t// an alias, in which case we don't take any chances here.\n\t\t\t\tnetwork_graph.node(&target).map_or(false, |hop_node|\n\t\t\t\t\thop_node.channels.iter().any(|scid| network_graph.channel(*scid)\n\t\t\t\t\t\t\t.map_or(false, |c| c.as_directed_from(&hop.candidate.source()).is_some()))\n\t\t\t\t)\n\t\t\t};\n\n\t\t\thops.push(RouteHop {\n\t\t\t\tpubkey: PublicKey::from_slice(target.as_slice()).map_err(|_| LightningError{err: format!(\"Public key {:?} is invalid\", &target), action: ErrorAction::IgnoreAndLog(Level::Trace)})?,\n\t\t\t\tnode_features: node_features.clone(),\n\t\t\t\tshort_channel_id: hop.candidate.short_channel_id().unwrap(),\n\t\t\t\tchannel_features: hop.candidate.features(),\n\t\t\t\tfee_msat: hop.fee_msat,\n\t\t\t\tcltv_expiry_delta: hop.candidate.cltv_expiry_delta(),\n\t\t\t\tmaybe_announced_channel,\n\t\t\t});\n\t\t}\n\t\tlet mut final_cltv_delta = final_cltv_expiry_delta;\n\t\tlet blinded_tail = payment_path.hops.last().and_then(|(h, _)| {\n\t\t\tif let Some(blinded_path) = h.candidate.blinded_path() {\n\t\t\t\tfinal_cltv_delta = h.candidate.cltv_expiry_delta();\n\t\t\t\tSome(BlindedTail {\n\t\t\t\t\thops: blinded_path.blinded_hops().to_vec(),\n\t\t\t\t\tblinding_point: blinded_path.blinding_point(),\n\t\t\t\t\texcess_final_cltv_expiry_delta: 0,\n\t\t\t\t\tfinal_value_msat: h.fee_msat,\n\t\t\t\t})\n\t\t\t} else { None }\n\t\t});\n\t\t// Propagate the cltv_expiry_delta one hop backwards since the delta from the current hop is\n\t\t// applicable for the previous hop.\n\t\thops.iter_mut().rev().fold(final_cltv_delta, |prev_cltv_expiry_delta, hop| {\n\t\t\tcore::mem::replace(&mut hop.cltv_expiry_delta, prev_cltv_expiry_delta)\n\t\t});\n\n\t\tpaths.push(Path { hops, blinded_tail });\n\t}\n\t// Make sure we would never create a route with more paths than we allow.\n\tdebug_assert!(paths.len() <= payment_params.max_path_count.into());\n\n\tif let Some(node_features) = payment_params.payee.node_features() {\n\t\tfor path in paths.iter_mut() {\n\t\t\tpath.hops.last_mut().unwrap().node_features = node_features.clone();\n\t\t}\n\t}\n\n\tlet route = Route { paths, route_params: Some(route_params.clone()) };\n\n\t// Make sure we would never create a route whose total fees exceed max_total_routing_fee_msat.\n\tif let Some(max_total_routing_fee_msat) = route_params.max_total_routing_fee_msat {\n\t\tif route.get_total_fees() > max_total_routing_fee_msat {\n\t\t\treturn Err(LightningError{err: format!(\"Failed to find route that adheres to the maximum total fee limit of {}msat\",\n\t\t\t\tmax_total_routing_fee_msat), action: ErrorAction::IgnoreError});\n\t\t}\n\t}\n\n\tlog_info!(logger, \"Got route: {}\", log_route!(route));\n\tOk(route)\n}"
}