{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `algorithm::radixn::RadixN::<T>::perform_fft_immut`",
    "file": "rustfft-6.4.0/src/algorithm/radixn.rs",
    "start_line": 167,
    "start_col": 5,
    "end_line": 248,
    "end_col": 6,
    "code_snippet": "fn perform_fft_immut(\n        &self,\n        input: &[Complex<T>],\n        output: &mut [Complex<T>],\n        scratch: &mut [Complex<T>],\n    ) {\n        if let Some(unroll_factor) = self.factors.first() {\n            // for performance, we really, really want to unroll the transpose, but we need to make sure the output length is divisible by the unroll amount\n            // choosing the first factor seems to reliably perform well\n            match unroll_factor.factor {\n                RadixFactor::Factor2 => {\n                    factor_transpose::<Complex<T>, 2>(self.base_len, input, output, &self.factors)\n                }\n                RadixFactor::Factor3 => {\n                    factor_transpose::<Complex<T>, 3>(self.base_len, input, output, &self.factors)\n                }\n                RadixFactor::Factor4 => {\n                    factor_transpose::<Complex<T>, 4>(self.base_len, input, output, &self.factors)\n                }\n                RadixFactor::Factor5 => {\n                    factor_transpose::<Complex<T>, 5>(self.base_len, input, output, &self.factors)\n                }\n                RadixFactor::Factor6 => {\n                    factor_transpose::<Complex<T>, 6>(self.base_len, input, output, &self.factors)\n                }\n                RadixFactor::Factor7 => {\n                    factor_transpose::<Complex<T>, 7>(self.base_len, input, output, &self.factors)\n                }\n            }\n        } else {\n            // no factors, so just pass data straight to our base\n            output.copy_from_slice(input);\n        }\n\n        // Base-level FFTs\n        self.base_fft.process_with_scratch(output, scratch);\n\n        let mut cross_fft_len = self.base_len;\n        let mut layer_twiddles: &[Complex<T>] = &self.twiddles;\n\n        for factor in self.butterflies.iter() {\n            let cross_fft_columns = cross_fft_len;\n            cross_fft_len *= factor.radix();\n\n            match factor {\n                InternalRadixFactor::Factor2(butterfly2) => {\n                    for data in output.chunks_exact_mut(cross_fft_len) {\n                        unsafe { butterfly_2(data, layer_twiddles, cross_fft_columns, butterfly2) }\n                    }\n                }\n                InternalRadixFactor::Factor3(butterfly3) => {\n                    for data in output.chunks_exact_mut(cross_fft_len) {\n                        unsafe { butterfly_3(data, layer_twiddles, cross_fft_columns, butterfly3) }\n                    }\n                }\n                InternalRadixFactor::Factor4(butterfly4) => {\n                    for data in output.chunks_exact_mut(cross_fft_len) {\n                        unsafe { butterfly_4(data, layer_twiddles, cross_fft_columns, butterfly4) }\n                    }\n                }\n                InternalRadixFactor::Factor5(butterfly5) => {\n                    for data in output.chunks_exact_mut(cross_fft_len) {\n                        unsafe { butterfly_5(data, layer_twiddles, cross_fft_columns, butterfly5) }\n                    }\n                }\n                InternalRadixFactor::Factor6(butterfly6) => {\n                    for data in output.chunks_exact_mut(cross_fft_len) {\n                        unsafe { butterfly_6(data, layer_twiddles, cross_fft_columns, butterfly6) }\n                    }\n                }\n                InternalRadixFactor::Factor7(butterfly7) => {\n                    for data in output.chunks_exact_mut(cross_fft_len) {\n                        unsafe { butterfly_7(data, layer_twiddles, cross_fft_columns, butterfly7) }\n                    }\n                }\n            }\n\n            // skip past all the twiddle factors used in this layer\n            let twiddle_offset = cross_fft_columns * (factor.radix() - 1);\n            layer_twiddles = &layer_twiddles[twiddle_offset..];\n        }\n    }"
}