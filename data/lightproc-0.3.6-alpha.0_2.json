{
    "level": "Warning",
    "analyzer": "UnsafeDestructor",
    "op_type": null,
    "description": "unsafe block detected in drop",
    "file": "lightproc-0.3.6-alpha.0/src/proc_handle.rs",
    "start_line": 187,
    "start_col": 1,
    "end_line": 187,
    "end_col": 31,
    "code_snippet": "impl<R> Drop for ProcHandle<R> {\n    fn drop(&mut self) {\n        let ptr = self.raw_proc.as_ptr();\n        let pdata = ptr as *const ProcData;\n\n        // A place where the output will be stored in case it needs to be dropped.\n        let mut output = None;\n\n        unsafe {\n            // Optimistically assume the `ProcHandle` is being dropped just after creating the\n            // proc. This is a common case so if the handle is not used, the overhead of it is only\n            // one compare-exchange operation.\n            if let Err(mut state) = (*pdata).state.compare_exchange_weak(\n                SCHEDULED | HANDLE | REFERENCE,\n                SCHEDULED | REFERENCE,\n                Ordering::AcqRel,\n                Ordering::Acquire,\n            ) {\n                loop {\n                    // If the proc has been completed but not yet closed, that means its output\n                    // must be dropped.\n                    if state & COMPLETED != 0 && state & CLOSED == 0 {\n                        // Mark the proc as closed in order to grab its output.\n                        match (*pdata).state.compare_exchange_weak(\n                            state,\n                            state | CLOSED,\n                            Ordering::AcqRel,\n                            Ordering::Acquire,\n                        ) {\n                            Ok(_) => {\n                                // Read the output.\n                                output = Some((((*pdata).vtable.get_output)(ptr) as *mut R).read());\n\n                                // Update the state variable because we're continuing the loop.\n                                state |= CLOSED;\n                            }\n                            Err(s) => state = s,\n                        }\n                    } else {\n                        // If this is the last reference to the proc and it's not closed, then\n                        // close it and schedule one more time so that its future gets dropped by\n                        // the executor.\n                        let new = if state & (!(REFERENCE - 1) | CLOSED) == 0 {\n                            SCHEDULED | CLOSED | REFERENCE\n                        } else {\n                            state & !HANDLE\n                        };\n\n                        // Unset the handle flag.\n                        match (*pdata).state.compare_exchange_weak(\n                            state,\n                            new,\n                            Ordering::AcqRel,\n                            Ordering::Acquire,\n                        ) {\n                            Ok(_) => {\n                                // If this is the last reference to the proc, we need to either\n                                // schedule dropping its future or destroy it.\n                                if state & !(REFERENCE - 1) == 0 {\n                                    if state & CLOSED == 0 {\n                                        ((*pdata).vtable.schedule)(ptr);\n                                    } else {\n                                        ((*pdata).vtable.destroy)(ptr);\n                                    }\n                                }\n\n                                break;\n                            }\n                            Err(s) => state = s,\n                        }\n                    }\n                }\n            }\n        }\n\n        // Drop the output if it was taken out of the proc.\n        drop(output);\n    }\n}"
}