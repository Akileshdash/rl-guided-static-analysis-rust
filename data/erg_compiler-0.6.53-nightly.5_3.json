{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `context::unify::Unifier::<'_, '_, '_, L>::sub_unify`",
    "file": "erg_compiler-0.6.53-nightly.5/context/unify.rs",
    "start_line": 1053,
    "start_col": 5,
    "end_line": 1967,
    "end_col": 6,
    "code_snippet": "fn sub_unify(&self, maybe_sub: &Type, maybe_super: &Type) -> TyCheckResult<()> {\n        log!(info \"trying {}sub_unify:\\nmaybe_sub: {maybe_sub}\\nmaybe_super: {maybe_super}\", self.undoable.map_or(\"\", |_| \"undoable_\"));\n        set_recursion_limit!(\n            panic,\n            \"recursion limit exceed: sub_unify({maybe_sub}, {maybe_super})\"\n        );\n        // In this case, there is no new information to be gained\n        if maybe_sub == &Type::Never\n            || maybe_super == &Type::Obj\n            || maybe_super.addr_eq(maybe_sub)\n            || (maybe_sub.has_no_unbound_var()\n                && maybe_super.has_no_unbound_var()\n                && maybe_sub == maybe_super)\n        {\n            log!(info \"no-op:\\nmaybe_sub: {maybe_sub}\\nmaybe_super: {maybe_super}\");\n            return Ok(());\n        }\n        // API definition was failed and inspection is useless after this\n        if maybe_sub == &Type::Failure || maybe_super == &Type::Failure {\n            log!(info \"no-op:\\nmaybe_sub: {maybe_sub}\\nmaybe_super: {maybe_super}\");\n            return Ok(());\n        }\n        self.occur(maybe_sub, maybe_super)\n            .inspect_err(|_e| log!(err \"occur error: {maybe_sub} / {maybe_super}\"))?;\n        let maybe_sub_is_sub = self.ctx.subtype_of(maybe_sub, maybe_super);\n        if !maybe_sub_is_sub {\n            log!(err \"{maybe_sub} !<: {maybe_super}\");\n            return Err(TyCheckErrors::from(TyCheckError::type_mismatch_error(\n                self.ctx.cfg.input.clone(),\n                line!() as usize,\n                self.loc.loc(),\n                self.ctx.caused_by(),\n                self.param_name.as_ref().unwrap_or(&Str::ever(\"_\")),\n                None,\n                maybe_super,\n                maybe_sub,\n                self.ctx.get_candidates(maybe_sub),\n                self.ctx\n                    .get_simple_type_mismatch_hint(maybe_super, maybe_sub),\n            )));\n        } else if maybe_sub.has_no_unbound_var() && maybe_super.has_no_unbound_var() {\n            log!(info \"no-op:\\nmaybe_sub: {maybe_sub}\\nmaybe_super: {maybe_super}\");\n            return Ok(());\n        }\n        match (maybe_sub, maybe_super) {\n            (FreeVar(sub_fv), _) if sub_fv.is_linked() => {\n                self.sub_unify(&sub_fv.unwrap_linked(), maybe_super)?;\n            }\n            (_, FreeVar(super_fv)) if super_fv.is_linked() => {\n                self.sub_unify(maybe_sub, &super_fv.unwrap_linked())?;\n            }\n            // lfv's sup can be shrunk (take min), rfv's sub can be expanded (take union)\n            // lfv\u306esup\u306f\u7e2e\u5c0f\u53ef\u80fd(min\u3092\u53d6\u308b)\u3001rfv\u306esub\u306f\u62e1\u5927\u53ef\u80fd(union\u3092\u53d6\u308b)\n            // sub_unify(?T[0](:> Never, <: Int), ?U[1](:> Never, <: Nat)): (/* ?U[1] --> ?T[0](:> Never, <: Nat))\n            // sub_unify(?T[1](:> Never, <: Nat), ?U[0](:> Never, <: Int)): (/* ?T[1] --> ?U[0](:> Never, <: Nat))\n            // sub_unify(?T[0](:> Never, <: Str), ?U[1](:> Never, <: Int)): (?T[0](:> Never, <: Str and Int) --> Error!)\n            // sub_unify(?T[0](:> Int, <: Add()), ?U[1](:> Never, <: Mul())): (?T[0](:> Int, <: Add() and Mul()))\n            // sub_unify(?T[0](:> Str, <: Obj), ?U[1](:> Int, <: Obj)): (/* ?U[1] --> ?T[0](:> Str or Int) */)\n            (FreeVar(sub_fv), FreeVar(super_fv))\n                if sub_fv.constraint_is_sandwiched() && super_fv.constraint_is_sandwiched() =>\n            {\n                if !self.change_generalized\n                    && (sub_fv.is_generalized() || super_fv.is_generalized())\n                {\n                    log!(info \"generalized:\\nmaybe_sub: {maybe_sub}\\nmaybe_super: {maybe_super}\");\n                    return Ok(());\n                }\n                let (lsub, lsup) = sub_fv.get_subsup().unwrap();\n                let (rsub, rsup) = super_fv.get_subsup().unwrap();\n                // sub: ?T(:> ?U)\n                // sup: ?U\n                // => ?T == ?U\n                if &lsub == maybe_super {\n                    maybe_sub.link(maybe_super, self.undoable);\n                    return Ok(());\n                } else if &rsup == maybe_sub {\n                    maybe_super.link(maybe_sub, self.undoable);\n                    return Ok(());\n                }\n                // ?T(<: Add(?T))\n                // ?U(:> {1, 2}, <: Add(?U)) ==> {1, 2}\n                super_fv.dummy_link();\n                sub_fv.dummy_link();\n                if lsub.qual_name() == rsub.qual_name() {\n                    for (lps, rps) in lsub.typarams().iter().zip(rsub.typarams().iter()) {\n                        self.sub_unify_tp(lps, rps, None, false).inspect_err(|_e| {\n                            super_fv.undo();\n                            sub_fv.undo();\n                        })?;\n                    }\n                }\n                // lsup: Add(?X(:> Int)), rsup: Add(?Y(:> Nat))\n                //   => lsup: Add(?X(:> Int)), rsup: Add((?X(:> Int)))\n                if lsup.qual_name() == rsup.qual_name() {\n                    for (lps, rps) in lsup.typarams().iter().zip(rsup.typarams().iter()) {\n                        self.sub_unify_tp(lps, rps, None, false).inspect_err(|_e| {\n                            super_fv.undo();\n                            sub_fv.undo();\n                        })?;\n                    }\n                }\n                super_fv.undo();\n                sub_fv.undo();\n                let sup_intersec = self.ctx.intersection(&lsup, &rsup);\n                if sup_intersec == Type::Never {\n                    return Err(TyCheckErrors::from(TyCheckError::subtyping_error(\n                        self.ctx.cfg.input.clone(),\n                        line!() as usize,\n                        maybe_sub,\n                        maybe_super,\n                        self.loc.loc(),\n                        self.ctx.caused_by(),\n                    )));\n                }\n                let sub_union = self.ctx.union(&lsub, &rsub);\n                if lsub.union_size().max(rsub.union_size()) < sub_union.union_size() {\n                    let (l, r) = sub_union.union_pair().unwrap_or((lsub, rsub.clone()));\n                    let unified = self.unify(&l, &r);\n                    if unified.is_none() {\n                        let maybe_sub = self.ctx.readable_type(maybe_sub.clone());\n                        let union = self.ctx.readable_type(sub_union);\n                        return Err(TyCheckErrors::from(TyCheckError::implicit_widening_error(\n                            self.ctx.cfg.input.clone(),\n                            line!() as usize,\n                            self.loc.loc(),\n                            self.ctx.caused_by(),\n                            &maybe_sub,\n                            &union,\n                        )));\n                    }\n                }\n                // e.g. intersec == Int, rsup == Add(?T)\n                //   => ?T(:> Int)\n                if !(sup_intersec.is_recursive() && rsup.is_recursive()) {\n                    self.sub_unify(&sup_intersec, &rsup)?;\n                }\n                self.sub_unify(&rsub, &sub_union)?;\n                // self.sub_unify(&intersec, &lsup, loc, param_name)?;\n                // self.sub_unify(&lsub, &union, loc, param_name)?;\n                match sub_fv\n                    .level()\n                    .unwrap_or(GENERIC_LEVEL)\n                    .cmp(&super_fv.level().unwrap_or(GENERIC_LEVEL))\n                {\n                    std::cmp::Ordering::Less => {\n                        if super_fv.level().unwrap_or(GENERIC_LEVEL) == GENERIC_LEVEL {\n                            maybe_super.update_tyvar(sub_union, sup_intersec, self.undoable, false);\n                            maybe_sub.link(maybe_super, self.undoable);\n                        } else {\n                            maybe_sub.update_tyvar(sub_union, sup_intersec, self.undoable, false);\n                            maybe_super.link(maybe_sub, self.undoable);\n                        }\n                    }\n                    std::cmp::Ordering::Greater => {\n                        if sub_fv.level().unwrap_or(GENERIC_LEVEL) == GENERIC_LEVEL {\n                            maybe_sub.update_tyvar(sub_union, sup_intersec, self.undoable, false);\n                            maybe_super.link(maybe_sub, self.undoable);\n                        } else {\n                            maybe_super.update_tyvar(sub_union, sup_intersec, self.undoable, false);\n                            maybe_sub.link(maybe_super, self.undoable);\n                        }\n                    }\n                    std::cmp::Ordering::Equal => {\n                        // choose named one\n                        if super_fv.is_named_unbound() {\n                            maybe_super.update_tyvar(sub_union, sup_intersec, self.undoable, false);\n                            maybe_sub.link(maybe_super, self.undoable);\n                        } else {\n                            maybe_sub.update_tyvar(sub_union, sup_intersec, self.undoable, false);\n                            maybe_super.link(maybe_sub, self.undoable);\n                        }\n                    }\n                }\n            }\n            (FreeVar(sub_fv), FreeVar(super_fv))\n                if sub_fv.constraint_is_sandwiched() && super_fv.constraint_is_typeof() =>\n            {\n                if !self.change_generalized\n                    && (sub_fv.is_generalized() || super_fv.is_generalized())\n                {\n                    log!(info \"generalized:\\nmaybe_sub: {maybe_sub}\\nmaybe_sup: {maybe_super}\");\n                    return Ok(());\n                }\n                let (lsub, lsup) = sub_fv.get_subsup().unwrap();\n                // sub: ?T(:> ?U(: {Str, Int}))\n                // sup: ?U(: {Str, Int})\n                // => ?T == ?U\n                if &lsub == maybe_super {\n                    maybe_sub.link(maybe_super, self.undoable);\n                    return Ok(());\n                }\n                let rty = super_fv.get_type().unwrap();\n                let Some(rtys) = rty.refinement_values() else {\n                    todo!(\"{rty}\");\n                };\n                // sub: ?T(:> Nat)\n                // sup: ?U(: {Str, Int})\n                // => ?T(:> Nat, <: Int)\n                for tp in rtys {\n                    let Ok(ty) = self.ctx.convert_tp_into_type(tp.clone()) else {\n                        todo!(\"{tp}\");\n                    };\n                    if self.ctx.subtype_of(&lsub, &ty) {\n                        let intersec = self.ctx.intersection(&lsup, &ty);\n                        maybe_sub.update_super(intersec, self.undoable, true);\n                        return Ok(());\n                    }\n                }\n                // REVIEW: unreachable?\n            }\n            (\n                Bounded {\n                    sub: lsub,\n                    sup: lsuper,\n                },\n                FreeVar(super_fv),\n            ) if super_fv.constraint_is_sandwiched() => {\n                if !self.change_generalized && super_fv.is_generalized() {\n                    log!(info \"generalized:\\nmaybe_sub: {maybe_sub}\\nmaybe_super: {maybe_super}\");\n                    return Ok(());\n                }\n                let (rsub, rsuper) = super_fv.get_subsup().unwrap();\n                // ?T(<: Add(?T))\n                // ?U(:> {1, 2}, <: Add(?U)) ==> {1, 2}\n                super_fv.dummy_link();\n                if lsub.qual_name() == rsub.qual_name() {\n                    for (lps, rps) in lsub.typarams().iter().zip(rsub.typarams().iter()) {\n                        self.sub_unify_tp(lps, rps, None, false)\n                            .inspect_err(|_e| super_fv.undo())?;\n                    }\n                }\n                // lsup: Add(?X(:> Int)), rsup: Add(?Y(:> Nat))\n                //   => lsup: Add(?X(:> Int)), rsup: Add((?X(:> Int)))\n                if lsuper.qual_name() == rsuper.qual_name() {\n                    for (lps, rps) in lsuper.typarams().iter().zip(rsuper.typarams().iter()) {\n                        self.sub_unify_tp(lps, rps, None, false)\n                            .inspect_err(|_e| super_fv.undo())?;\n                    }\n                }\n                super_fv.undo();\n                let intersec = self.ctx.intersection(lsuper, &rsuper);\n                if intersec == Type::Never {\n                    return Err(TyCheckErrors::from(TyCheckError::subtyping_error(\n                        self.ctx.cfg.input.clone(),\n                        line!() as usize,\n                        maybe_sub,\n                        maybe_super,\n                        self.loc.loc(),\n                        self.ctx.caused_by(),\n                    )));\n                }\n                let union = self.ctx.union(lsub, &rsub);\n                if lsub.union_size().max(rsub.union_size()) < union.union_size() {\n                    let (l, r) = union.union_pair().unwrap_or((*lsub.clone(), rsub.clone()));\n                    let unified = self.unify(&l, &r);\n                    if unified.is_none() {\n                        let maybe_sub = self.ctx.readable_type(maybe_sub.clone());\n                        let union = self.ctx.readable_type(union);\n                        return Err(TyCheckErrors::from(TyCheckError::implicit_widening_error(\n                            self.ctx.cfg.input.clone(),\n                            line!() as usize,\n                            self.loc.loc(),\n                            self.ctx.caused_by(),\n                            &maybe_sub,\n                            &union,\n                        )));\n                    }\n                }\n                // e.g. intersec == Int, rsup == Add(?T)\n                //   => ?T(:> Int)\n                self.sub_unify(&intersec, &rsuper)?;\n                self.sub_unify(&rsub, &union)?;\n                // self.sub_unify(&intersec, &lsup, loc, param_name)?;\n                // self.sub_unify(&lsub, &union, loc, param_name)?;\n                maybe_super.update_tyvar(union, intersec, self.undoable, false);\n            }\n            // TODO: Preferentially compare same-structure types (e.g. K(?T) <: K(?U))\n            (And(ltys, _), And(rtys, _)) => {\n                let mut ltys_ = ltys.clone();\n                let mut rtys_ = rtys.clone();\n                // Show and EqHash and T <: Eq and Show and Ord\n                // => EqHash and T <: Eq and Ord\n                for lty in ltys.iter() {\n                    if let Some(idx) = rtys_.iter().position(|r| r == lty) {\n                        rtys_.remove(idx);\n                        let idx = ltys_.iter().position(|l| l == lty).unwrap();\n                        ltys_.remove(idx);\n                    }\n                }\n                // EqHash and T <: Eq and Ord\n                for lty in ltys_.iter() {\n                    // lty: EqHash\n                    // rty: Eq, Ord\n                    for rty in rtys_.iter() {\n                        if self.ctx.subtype_of(lty, rty) {\n                            self.sub_unify(lty, rty)?;\n                            continue;\n                        }\n                    }\n                }\n            }\n            // TODO: Preferentially compare same-structure types (e.g. K(?T) <: K(?U))\n            // Nat or Str or NoneType <: NoneType or ?T or Int\n            // => Str <: ?T\n            // (Int or ?T) <: (?U or Int)\n            // OK: (Int <: Int); (?T <: ?U)\n            // NG: (Int <: ?U); (?T <: Int)\n            (Or(ltys), Or(rtys)) => {\n                let mut ltys_ = ltys.clone();\n                let mut rtys_ = rtys.clone();\n                // Nat or T or Str <: Str or Int or NoneType\n                // => Nat or T <: Int or NoneType\n                for lty in ltys {\n                    if rtys_.linear_remove(lty) {\n                        ltys_.linear_remove(lty);\n                    }\n                }\n                // Nat or T <: Int or NoneType\n                for lty in ltys_.iter() {\n                    // lty: Nat\n                    // rty: Int, NoneType\n                    for rty in rtys_.iter() {\n                        if self.ctx.subtype_of(lty, rty) {\n                            self.sub_unify(lty, rty)?;\n                            continue;\n                        }\n                    }\n                }\n            }\n            // NG: Nat <: ?T or Int ==> Nat or Int (?T = Nat)\n            // OK: Nat <: ?T or Int ==> ?T or Int\n            (sub, Or(tys))\n                if !sub.is_unbound_var()\n                    && tys\n                        .iter()\n                        .any(|ty| !ty.is_unbound_var() && self.ctx.subtype_of(sub, ty)) => {}\n            // e.g. Structural({ .method = (self: T) -> Int })/T\n            (Structural(sub), FreeVar(sup_fv))\n                if sup_fv.is_unbound() && sub.contains_tvar(sup_fv) => {}\n            (_, FreeVar(sup_fv)) if !self.change_generalized && sup_fv.is_generalized() => {}\n            (_, FreeVar(super_fv)) if super_fv.is_unbound() => {\n                // * sub_unify(Nat, ?E(<: Eq(?E)))\n                // sub !<: l => OK (sub will widen)\n                // sup !:> l => Error\n                // * sub_unify(Str,   ?T(:> _,     <: Int)): (/* Error */)\n                // * sub_unify(Ratio, ?T(:> _,     <: Int)): (/* Error */)\n                // sub = max(l, sub) if max exists\n                // * sub_unify(Nat,   ?T(:> Int,   <: _)): (/* OK */)\n                // * sub_unify(Int,   ?T(:> Nat,   <: Obj)): (?T(:> Int, <: Obj))\n                // * sub_unify(Nat,   ?T(:> Never, <: Add(?R))): (?T(:> Nat, <: Add(?R))\n                // sub = union(l, sub) if max does not exist\n                // * sub_unify(Str,   ?T(:> Int,   <: Obj)): (?T(:> Str or Int, <: Obj))\n                // * sub_unify({0},   ?T(:> {1},   <: Nat)): (?T(:> {0, 1}, <: Nat))\n                // * sub_unify(Bool,  ?T(<: Bool or Y)): (?T == Bool)\n                // * sub_unify(Float, ?T(<: Structural{ .imag = ?U })) ==> ?U == Float\n                // * sub_unify(K(Int, 1), ?T(:> K(?A, ?N))) ==> ?A(:> Int), ?N == 1\n                if let Type::Refinement(refine) = maybe_sub {\n                    if refine.t.addr_eq(maybe_super) {\n                        return Ok(());\n                    }\n                }\n                if let Some((sub, mut supe)) = super_fv.get_subsup() {\n                    if !supe.is_recursive() {\n                        self.sub_unify(maybe_sub, &supe)?;\n                    }\n                    let mut new_sub = self.ctx.union(maybe_sub, &sub);\n                    if !sub.is_recursive()\n                        && maybe_sub.qual_name() == sub.qual_name()\n                        && new_sub.has_unbound_var()\n                    {\n                        let list = UndoableLinkedList::new();\n                        if self\n                            .ctx\n                            .undoable_sub_unify(maybe_sub, &sub, &(), &list, None)\n                            .is_ok()\n                            && !maybe_sub.is_recursive()\n                            && !sub.is_recursive()\n                        {\n                            drop(list);\n                            self.sub_unify(maybe_sub, &sub)?;\n                        }\n                    }\n                    // Expanding to an Or-type is prohibited by default\n                    // This increases the quality of error reporting\n                    // (Try commenting out this part and run tests/should_err/subtyping.er to see the error report changes on lines 29-30)\n                    if maybe_sub.union_size().max(sub.union_size()) < new_sub.union_size()\n                        && new_sub.ors().iter().any(|t| !t.is_unbound_var())\n                    {\n                        let (l, r) = new_sub.union_pair().unwrap_or((maybe_sub.clone(), sub));\n                        let unified = self.unify(&l, &r);\n                        if let Some(unified) = unified {\n                            log!(\"unify({l}, {r}) == {unified}\");\n                            new_sub = unified;\n                        } else {\n                            let maybe_sub = self.ctx.readable_type(maybe_sub.clone());\n                            let new_sub = self.ctx.readable_type(new_sub);\n                            return Err(TyCheckErrors::from(\n                                TyCheckError::implicit_widening_error(\n                                    self.ctx.cfg.input.clone(),\n                                    line!() as usize,\n                                    self.loc.loc(),\n                                    self.ctx.caused_by(),\n                                    &maybe_sub,\n                                    &new_sub,\n                                ),\n                            ));\n                        }\n                    }\n                    if supe.contains_union(&new_sub) {\n                        maybe_super.link(&new_sub, self.undoable); // Bool <: ?T <: Bool or Y ==> ?T == Bool\n                    } else {\n                        maybe_super.update_tyvar(\n                            new_sub,\n                            mem::take(&mut supe),\n                            self.undoable,\n                            true,\n                        );\n                    }\n                }\n                // sub_unify(Nat, ?T(: Type)): (/* ?T(:> Nat) */)\n                else if let Some(ty) = super_fv.get_type() {\n                    if self.ctx.supertype_of(&Type, &ty) {\n                        let constr = Constraint::new_supertype_of(maybe_sub.clone());\n                        maybe_super.update_constraint(constr, self.undoable, true);\n                    } else {\n                        // ?T: GenericDict\n                        // todo!(\"{maybe_sub} <: {maybe_sup}\")\n                    }\n                }\n            }\n            (FreeVar(sub_fv), Structural(struct_sup)) if sub_fv.is_unbound() => {\n                let Some((sub, sup)) = sub_fv.get_subsup() else {\n                    log!(err \"{sub_fv} is not a type variable\");\n                    return Ok(());\n                };\n                let sub_fields = self.ctx.fields(maybe_sub);\n                for (sup_field, sup_ty) in self.ctx.fields(struct_sup) {\n                    sub_fv.dummy_link();\n                    if let Some((_, sub_ty)) = sub_fields.get_key_value(&sup_field) {\n                        self.sub_unify(sub_ty, &sup_ty)\n                            .inspect_err(|_e| sub_fv.undo())?;\n                    } else if !self.ctx.subtype_of(&sub, &Never) {\n                        sub_fv.undo();\n                        let sub_hash = get_hash(maybe_sub);\n                        maybe_sub.coerce(self.undoable);\n                        if get_hash(maybe_sub) != sub_hash {\n                            return self.sub_unify(maybe_sub, maybe_super);\n                        }\n                    } else {\n                        // e.g. ?T / Structural({ .method = (self: ?T) -> Int })\n                        let constr = Constraint::new_sandwiched(\n                            sub.clone(),\n                            self.ctx.intersection(&sup, maybe_super),\n                        );\n                        sub_fv.undo();\n                        maybe_sub.update_constraint(constr, None, false);\n                    }\n                }\n            }\n            (FreeVar(sub_fv), Ref(sup)) if sub_fv.is_unbound() => {\n                self.sub_unify(maybe_sub, sup)?;\n            }\n            (FreeVar(sub_fv), _) if !self.change_generalized && sub_fv.is_generalized() => {}\n            (FreeVar(sub_fv), _) if sub_fv.is_unbound() => {\n                // sub !<: r => Error\n                // * sub_unify(?T(:> Int,   <: _), Nat): (/* Error */)\n                // * sub_unify(?T(:> Nat,   <: _), Str): (/* Error */)\n                // sup !:> r => Error\n                // * sub_unify(?T(:> _, <: Str), Int): (/* Error */)\n                // * sub_unify(?T(:> _, <: Int), Nat): (/* Error */)\n                // sub <: r, sup :> r => sup = min(sup, r) if min exists\n                // * sub_unify(?T(:> Never, <: Nat), Int): (/* OK */)\n                // * sub_unify(?T(:> Nat,   <: Obj), Int): (?T(:> Nat,   <: Int))\n                // sup = intersection(sup, r) if min does not exist\n                // * sub_unify(?T(<: {1}), {0}): (* ?T == Never *)\n                // * sub_unify(?T(<: Eq and Ord), Show): (?T(<: Eq and Ord and Show))\n                // * sub_unify(?T(:> [Int; 4]), [Int, _]): (* ?T == [Int; 4] *)\n                if let Some((mut sub, supe)) = sub_fv.get_subsup() {\n                    if supe.is_structural() {\n                        return Ok(());\n                    }\n                    let sub = mem::take(&mut sub);\n                    // min(L, R) != L and R\n                    let new_super = if let Some(new_sup) = self.ctx.min(&supe, maybe_super).either()\n                    {\n                        new_sup.clone()\n                    } else {\n                        self.ctx.intersection(&supe, maybe_super)\n                    };\n                    if !maybe_sub.is_recursive() && (&sub != maybe_sub || &new_super != maybe_super)\n                    {\n                        self.sub_unify(&sub, &new_super)?;\n                    }\n                    // ?T(:> Int, <: Int) ==> ?T == Int\n                    // ?T(:> List(Int, 3), <: List(?T, ?N)) ==> ?T == List(Int, 3)\n                    // ?T(:> List(Int, 3), <: Indexable(?K, ?V)) ==> ?T(:> List(Int, 3), <: Indexable(0..2, Int))\n                    if !sub.is_refinement()\n                        && new_super.qual_name() == sub.qual_name()\n                        && !new_super.is_unbound_var()\n                        && !sub.is_unbound_var()\n                    {\n                        maybe_sub.link(&sub, self.undoable);\n                    } else {\n                        maybe_sub.update_tyvar(sub, new_super, self.undoable, true);\n                    }\n                }\n                // sub_unify(?T(: Type), Int): (?T(<: Int))\n                else if let Some(ty) = sub_fv.get_type() {\n                    if self.ctx.supertype_of(&Type, &ty) {\n                        let constr = Constraint::new_subtype_of(maybe_super.clone());\n                        maybe_sub.update_constraint(constr, self.undoable, true);\n                    } else {\n                        // ?T: GenericDict\n                        // todo!(\"{maybe_sub} <: {maybe_sup}\")\n                    }\n                }\n            }\n            (Record(sub_rec), Record(super_rec)) => {\n                for (k, l) in sub_rec.iter() {\n                    if let Some(r) = super_rec.get(k) {\n                        self.sub_unify(l, r)?;\n                    } else {\n                        return Err(TyCheckErrors::from(TyCheckError::subtyping_error(\n                            self.ctx.cfg.input.clone(),\n                            line!() as usize,\n                            maybe_sub,\n                            maybe_super,\n                            self.loc.loc(),\n                            self.ctx.caused_by(),\n                        )));\n                    }\n                }\n            }\n            (NamedTuple(sub_tup), NamedTuple(super_tup)) => {\n                for ((_, lt), (_, rt)) in sub_tup.iter().zip(super_tup.iter()) {\n                    self.sub_unify(lt, rt)?;\n                }\n            }\n            (Subr(sub_subr), Subr(super_subr)) => {\n                // (Int, *Int) -> ... <: (T, U, V) -> ...\n                if let Some(sub_var) = sub_subr.var_params.as_deref() {\n                    sub_subr\n                        .non_default_params\n                        .iter()\n                        .chain(repeat(sub_var))\n                        .zip(super_subr.non_default_params.iter())\n                        .try_for_each(|(sub, sup)| {\n                            // contravariant\n                            self.sub_unify(sup.typ(), sub.typ())\n                        })?;\n                } else {\n                    // (self: Self, Int) -> ... <: T -> ...\n                    let sub_params = if !super_subr.is_method() && sub_subr.is_method() {\n                        sub_subr\n                            .non_default_params\n                            .iter()\n                            .skip(1)\n                            .chain(&sub_subr.default_params)\n                    } else {\n                        #[allow(clippy::iter_skip_zero)]\n                        sub_subr\n                            .non_default_params\n                            .iter()\n                            .skip(0)\n                            .chain(&sub_subr.default_params)\n                    };\n                    sub_params\n                        .zip(super_subr.non_default_params.iter())\n                        .try_for_each(|(sub, sup)| {\n                            // contravariant\n                            self.sub_unify(sup.typ(), sub.typ())\n                        })?;\n                }\n                sub_subr\n                    .var_params\n                    .iter()\n                    .zip(super_subr.var_params.iter())\n                    .try_for_each(|(sub, sup)| {\n                        // contravariant\n                        self.sub_unify(sup.typ(), sub.typ())\n                    })?;\n                for super_pt in super_subr.default_params.iter() {\n                    if let Some(sub_pt) = sub_subr\n                        .default_params\n                        .iter()\n                        .find(|sub_pt| sub_pt.name() == super_pt.name())\n                    {\n                        // contravariant\n                        self.sub_unify(super_pt.typ(), sub_pt.typ())?;\n                    } else if let Some(sub_pt) = sub_subr.kw_var_params.as_ref() {\n                        self.sub_unify(super_pt.typ(), sub_pt.typ())?;\n                    } else {\n                        let param_name = super_pt.name().map_or(\"_\", |s| &s[..]);\n                        let similar_param = erg_common::levenshtein::get_similar_name(\n                            super_subr\n                                .default_params\n                                .iter()\n                                .map(|pt| pt.name().map_or(\"_\", |s| &s[..])),\n                            param_name,\n                        );\n                        return Err(TyCheckErrors::from(\n                            TyCheckError::default_param_not_found_error(\n                                self.ctx.cfg.input.clone(),\n                                line!() as usize,\n                                self.loc.loc(),\n                                self.ctx.caused_by(),\n                                param_name,\n                                similar_param,\n                            ),\n                        ));\n                    }\n                }\n                // covariant\n                self.sub_unify(&sub_subr.return_t, &super_subr.return_t)?;\n            }\n            (Quantified(sub_subr), Subr(super_subr)) => {\n                let Ok(sub_subr) = <&SubrType>::try_from(sub_subr.as_ref()) else {\n                    unreachable!()\n                };\n                sub_subr\n                    .non_default_params\n                    .iter()\n                    .zip(super_subr.non_default_params.iter())\n                    .try_for_each(|(sub, sup)| {\n                        if !self.change_generalized && sub.typ().is_generalized() {\n                            Ok(())\n                        }\n                        // contravariant\n                        else {\n                            self.sub_unify(sup.typ(), sub.typ())\n                        }\n                    })?;\n                for super_pt in super_subr.default_params.iter() {\n                    if let Some(sub_pt) = sub_subr\n                        .default_params\n                        .iter()\n                        .find(|sub_pt| sub_pt.name() == super_pt.name())\n                    {\n                        if !self.change_generalized && sub_pt.typ().is_generalized() {\n                            continue;\n                        }\n                        // contravariant\n                        self.sub_unify(super_pt.typ(), sub_pt.typ())?;\n                    } else if let Some(sub_pt) = sub_subr.kw_var_params.as_ref() {\n                        self.sub_unify(super_pt.typ(), sub_pt.typ())?;\n                    } else {\n                        todo!(\"{maybe_sub} <: {maybe_super}\")\n                    }\n                }\n                if !sub_subr.return_t.is_generalized() {\n                    // covariant\n                    self.sub_unify(&sub_subr.return_t, &super_subr.return_t)?;\n                }\n            }\n            (Subr(sub_subr), Quantified(super_subr)) => {\n                let Ok(super_subr) = <&SubrType>::try_from(super_subr.as_ref()) else {\n                    unreachable!()\n                };\n                sub_subr\n                    .non_default_params\n                    .iter()\n                    .zip(super_subr.non_default_params.iter())\n                    .try_for_each(|(sub, sup)| {\n                        // contravariant\n                        if !self.change_generalized && sup.typ().is_generalized() {\n                            Ok(())\n                        } else {\n                            self.sub_unify(sup.typ(), sub.typ())\n                        }\n                    })?;\n                for super_pt in super_subr.default_params.iter() {\n                    if let Some(sub_pt) = sub_subr\n                        .default_params\n                        .iter()\n                        .find(|sub_pt| sub_pt.name() == super_pt.name())\n                    {\n                        // contravariant\n                        if !self.change_generalized && super_pt.typ().is_generalized() {\n                            continue;\n                        }\n                        self.sub_unify(super_pt.typ(), sub_pt.typ())?;\n                    } else if let Some(sub_pt) = sub_subr.kw_var_params.as_ref() {\n                        self.sub_unify(super_pt.typ(), sub_pt.typ())?;\n                    } else {\n                        todo!(\"{maybe_sub} <: {maybe_super}\")\n                    }\n                }\n                if !super_subr.return_t.is_generalized() {\n                    // covariant\n                    self.sub_unify(&sub_subr.return_t, &super_subr.return_t)?;\n                }\n            }\n            (\n                Poly {\n                    name: ln,\n                    params: lps,\n                },\n                Poly {\n                    name: rn,\n                    params: rps,\n                },\n            ) => {\n                // e.g. Set(?T) <: Eq(Set(?T))\n                //      List(Str) <: Iterable(Str)\n                //      Zip(T, U) <: Iterable(Tuple([T, U]))\n                if ln != rn {\n                    self.nominal_sub_unify(maybe_sub, maybe_super)?;\n                } else {\n                    for (l_maybe_sub, r_maybe_sup) in lps.iter().zip(rps.iter()) {\n                        self.sub_unify_tp(l_maybe_sub, r_maybe_sup, None, false)?;\n                    }\n                }\n            }\n            (Structural(sub), Structural(sup)) => {\n                self.sub_unify(sub, sup)?;\n            }\n            (Guard(sub), Guard(sup)) => {\n                self.sub_unify(&sub.to, &sup.to)?;\n            }\n            (sub, Structural(supe)) => {\n                let sub_fields = self.ctx.fields(sub);\n                for (sup_field, sup_ty) in self.ctx.fields(supe) {\n                    if let Some((_, sub_ty)) = sub_fields.get_key_value(&sup_field) {\n                        self.sub_unify(sub_ty, &sup_ty)?;\n                    } else {\n                        return Err(TyCheckErrors::from(TyCheckError::no_attr_error(\n                            self.ctx.cfg.input.clone(),\n                            line!() as usize,\n                            self.loc.loc(),\n                            self.ctx.caused_by(),\n                            sub,\n                            &sup_field.symbol,\n                            self.ctx.get_no_attr_hint(sub, &sup_field.symbol),\n                        )));\n                    }\n                }\n            }\n            // (X or Y) <: Z is valid when X <: Z and Y <: Z\n            (Or(tys), _) => {\n                for ty in tys {\n                    self.sub_unify(ty, maybe_super)?;\n                }\n            }\n            // X <: (Y and Z) is valid when X <: Y and X <: Z\n            (_, And(tys, _)) => {\n                for ty in tys {\n                    self.sub_unify(maybe_sub, ty)?;\n                }\n            }\n            // (X and Y) <: Z is valid when X <: Z or Y <: Z\n            (And(tys, _), _) => {\n                for ty in tys {\n                    if self.ctx.subtype_of(ty, maybe_super) {\n                        return self.sub_unify(ty, maybe_super);\n                    }\n                }\n                self.sub_unify(tys.iter().next().unwrap(), maybe_super)?;\n            }\n            // X <: (Y or Z) is valid when X <: Y or X <: Z\n            (_, Or(tys)) => {\n                for ty in tys {\n                    if self.ctx.subtype_of(maybe_sub, ty) {\n                        return self.sub_unify(maybe_sub, ty);\n                    }\n                }\n                self.sub_unify(maybe_sub, tys.iter().next().unwrap())?;\n            }\n            (Ref(sub), Ref(supe)) => {\n                self.sub_unify(sub, supe)?;\n            }\n            (_, Ref(supe)) => {\n                self.sub_unify(maybe_sub, supe)?;\n            }\n            (RefMut { before: sub, .. }, RefMut { before: supe, .. }) => {\n                self.sub_unify(sub, supe)?;\n            }\n            (_, RefMut { before, .. }) => {\n                self.sub_unify(maybe_sub, before)?;\n            }\n            (_, Proj { lhs, rhs }) => {\n                if let Ok(evaled) =\n                    self.ctx\n                        .eval_proj(*lhs.clone(), rhs.clone(), self.ctx.level, self.loc)\n                {\n                    if maybe_super != &evaled {\n                        self.sub_unify(maybe_sub, &evaled)?;\n                    } else {\n                        let mut compatible = vec![];\n                        for (imp, cand) in self.ctx.get_proj_impl_candidates(lhs, rhs) {\n                            if self.ctx.subtype_of(&maybe_sub.derefine(), &cand) {\n                                compatible.push((imp, cand));\n                            }\n                        }\n                        if let Some((imp, _)) = self.ctx.min_by_type(compatible) {\n                            self.sub_unify(&imp.sub_type, lhs)?;\n                            self.sub_unify(lhs, &imp.sub_type)?;\n                        }\n                    }\n                }\n            }\n            (Proj { lhs, rhs }, _) => {\n                if let Ok(evaled) =\n                    self.ctx\n                        .eval_proj(*lhs.clone(), rhs.clone(), self.ctx.level, self.loc)\n                {\n                    if maybe_sub != &evaled {\n                        self.sub_unify(&evaled, maybe_super)?;\n                    } else if self.ctx.is_class(maybe_super)\n                        && lhs.get_super().is_some_and(|sup| sup.is_monomorphized())\n                    {\n                        let mut compatible = vec![];\n                        for (imp, cand) in self.ctx.get_proj_impl_candidates(lhs, rhs) {\n                            if self.ctx.subtype_of(&cand, maybe_super) {\n                                compatible.push((imp, cand));\n                            }\n                        }\n                        if let Some((imp, _)) = self.ctx.max_by_type(compatible) {\n                            self.sub_unify(lhs, &imp.sub_type)?;\n                        }\n                    }\n                }\n            }\n            (\n                _,\n                ProjCall {\n                    lhs,\n                    attr_name,\n                    args,\n                },\n            ) => {\n                if let Some(evaled) = self\n                    .ctx\n                    .eval_proj_call(*lhs.clone(), attr_name.clone(), args.clone(), self.loc)\n                    .ok()\n                    .and_then(|tp| self.ctx.convert_tp_into_type(tp).ok())\n                {\n                    if maybe_super != &evaled {\n                        self.sub_unify(maybe_sub, &evaled)?;\n                    }\n                }\n            }\n            (\n                ProjCall {\n                    lhs,\n                    attr_name,\n                    args,\n                },\n                _,\n            ) => {\n                if let Some(evaled) = self\n                    .ctx\n                    .eval_proj_call(*lhs.clone(), attr_name.clone(), args.clone(), self.loc)\n                    .ok()\n                    .and_then(|tp| self.ctx.convert_tp_into_type(tp).ok())\n                {\n                    if maybe_sub != &evaled {\n                        self.sub_unify(&evaled, maybe_super)?;\n                    }\n                }\n            }\n            // TODO: Judgment for any number of preds\n            (Refinement(sub), Refinement(supe)) => {\n                // {I: Int or Str | I == 0} <: {I: Int}\n                if self.ctx.subtype_of(&sub.t, &supe.t) {\n                    self.sub_unify(&sub.t, &supe.t)?;\n                }\n                if supe.pred.as_ref() == &Predicate::TRUE {\n                    self.sub_unify(&sub.t, &supe.t)?;\n                    return Ok(());\n                }\n                self.sub_unify_pred(&sub.pred, &supe.pred)?;\n            }\n            // {Int} <: Obj -> Int\n            (Refinement(_), Subr(_) | Quantified(_))\n                if maybe_sub.is_singleton_refinement_type() => {}\n            // {I: Int | I >= 1} <: Nat == {I: Int | I >= 0}\n            (Refinement(_), sup) => {\n                let sup = sup.clone().into_refinement();\n                self.sub_unify(maybe_sub, &Type::Refinement(sup))?;\n            }\n            (sub, Refinement(_)) => {\n                if let Some(sub) = sub.to_singleton() {\n                    self.sub_unify(&Type::Refinement(sub), maybe_super)?;\n                } else {\n                    let sub = sub.clone().into_refinement();\n                    self.sub_unify(&Type::Refinement(sub), maybe_super)?;\n                }\n            }\n            (Subr(_) | Record(_), Type) => {}\n            (Guard(_), _) | (_, Guard(_)) => {}\n            // REVIEW: correct?\n            (Poly { name, .. }, Type) if &name[..] == \"List\" || &name[..] == \"Tuple\" => {}\n            (Poly { .. }, _) => {\n                if maybe_sub.has_no_qvar() && maybe_super.has_no_qvar() {\n                    return Ok(());\n                }\n                self.nominal_sub_unify(maybe_sub, maybe_super)?;\n            }\n            (_, Poly { .. }) => {\n                self.nominal_sub_unify(maybe_sub, maybe_super)?;\n            }\n            (Subr(_), Mono(name)) if &name[..] == \"Subroutine\" => {}\n            _ => {\n                return type_feature_error!(\n                    self.ctx,\n                    self.loc.loc(),\n                    &format!(\n                        \"{maybe_sub} can be a subtype of {maybe_super}, but failed to semi-unify\"\n                    )\n                )\n            }\n        }\n        log!(info \"sub_unified:\\nmaybe_sub: {maybe_sub}\\nmaybe_sup: {maybe_super}\");\n        Ok(())\n    }"
}