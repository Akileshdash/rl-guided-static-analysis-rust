{
    "level": "Warning",
    "analyzer": "UnsafeDestructor",
    "op_type": null,
    "description": "unsafe block detected in drop",
    "file": "futures-util-0.3.31/src/stream/futures_unordered/mod.rs",
    "start_line": 575,
    "start_col": 1,
    "end_line": 575,
    "end_col": 41,
    "code_snippet": "impl<Fut> Drop for FuturesUnordered<Fut> {\n    fn drop(&mut self) {\n        // Before the strong reference to the queue is dropped we need all\n        // futures to be dropped. See note at the bottom of this method.\n        //\n        // If there is a panic before this completes, we leak the queue.\n        struct LeakQueueOnDrop<'a, Fut>(&'a mut FuturesUnordered<Fut>);\n        impl<Fut> Drop for LeakQueueOnDrop<'_, Fut> {\n            fn drop(&mut self) {\n                mem::forget(Arc::clone(&self.0.ready_to_run_queue));\n            }\n        }\n        let guard = LeakQueueOnDrop(self);\n        // When a `FuturesUnordered` is dropped we want to drop all futures\n        // associated with it. At the same time though there may be tons of\n        // wakers flying around which contain `Task<Fut>` references\n        // inside them. We'll let those naturally get deallocated.\n        while !guard.0.head_all.get_mut().is_null() {\n            let head = *guard.0.head_all.get_mut();\n            let task = unsafe { guard.0.unlink(head) };\n            guard.0.release_task(task);\n        }\n        mem::forget(guard); // safe to release strong reference to queue\n\n        // Note that at this point we could still have a bunch of tasks in the\n        // ready to run queue. None of those tasks, however, have futures\n        // associated with them so they're safe to destroy on any thread. At\n        // this point the `FuturesUnordered` struct, the owner of the one strong\n        // reference to the ready to run queue will drop the strong reference.\n        // At that point whichever thread releases the strong refcount last (be\n        // it this thread or some other thread as part of an `upgrade`) will\n        // clear out the ready to run queue and free all remaining tasks.\n        //\n        // While that freeing operation isn't guaranteed to happen here, it's\n        // guaranteed to happen \"promptly\" as no more \"blocking work\" will\n        // happen while there's a strong refcount held.\n    }\n}"
}