{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `conversions::sse::lut4_to_3_q0_15::TransformLut4To3SseQ0_15::<T, U, LAYOUT, GRID_SIZE, BIT_DEPTH, BINS, BARYCENTRIC_BINS>::transform_chunk`",
    "file": "moxcms-0.7.3/src/conversions/sse/lut4_to_3_q0_15.rs",
    "start_line": 75,
    "start_col": 5,
    "end_line": 150,
    "end_col": 6,
    "code_snippet": "unsafe fn transform_chunk<'b, Interpolator: SseMdInterpolationQ0_15<'b, GRID_SIZE>>(\n        &'b self,\n        src: &[T],\n        dst: &mut [T],\n    ) {\n        unsafe {\n            let cn = Layout::from(LAYOUT);\n            let channels = cn.channels();\n            let grid_size = GRID_SIZE as i32;\n            let grid_size3 = grid_size * grid_size * grid_size;\n\n            let f_value_scale = _mm_set1_ps(1. / ((1 << 14i32) - 1) as f32);\n            let max_value = ((1u32 << BIT_DEPTH) - 1).as_();\n            let v_max_scale = if T::FINITE {\n                _mm_set1_epi16(((1i32 << BIT_DEPTH) - 1) as i16)\n            } else {\n                _mm_set1_epi16(((1i32 << 14i32) - 1) as i16)\n            };\n\n            for (src, dst) in src.chunks_exact(4).zip(dst.chunks_exact_mut(channels)) {\n                let c = <() as LutBarycentricReduction<T, U>>::reduce::<BIT_DEPTH, BARYCENTRIC_BINS>(\n                    src[0],\n                );\n                let m = <() as LutBarycentricReduction<T, U>>::reduce::<BIT_DEPTH, BARYCENTRIC_BINS>(\n                    src[1],\n                );\n                let y = <() as LutBarycentricReduction<T, U>>::reduce::<BIT_DEPTH, BARYCENTRIC_BINS>(\n                    src[2],\n                );\n                let k = <() as LutBarycentricReduction<T, U>>::reduce::<BIT_DEPTH, BARYCENTRIC_BINS>(\n                    src[3],\n                );\n\n                let k_weights = self.weights[k.as_()];\n\n                let w: i32 = k_weights.x;\n                let w_n: i32 = k_weights.x_n;\n                const Q: i16 = ((1i32 << 15) - 1) as i16;\n                let t: i16 = k_weights.w;\n                let t_n: i16 = Q - t;\n\n                let table1 = &self.lut[(w * grid_size3) as usize..];\n                let table2 = &self.lut[(w_n * grid_size3) as usize..];\n\n                let tetrahedral1 = Interpolator::new(table1);\n                let tetrahedral2 = Interpolator::new(table2);\n                let a0 = tetrahedral1.inter3_sse(c, m, y, &self.weights).v;\n                let b0 = tetrahedral2.inter3_sse(c, m, y, &self.weights).v;\n\n                let hp = _mm_mulhrs_epi16(_mm_set1_epi16(t_n), a0);\n                let v = _mm_add_epi16(hp, _mm_mulhrs_epi16(b0, _mm_set1_epi16(t)));\n\n                if T::FINITE {\n                    let mut o = _mm_max_epi16(v, _mm_setzero_si128());\n                    o = _mm_min_epi16(o, v_max_scale);\n\n                    let x = _mm_extract_epi16::<0>(o);\n                    let y = _mm_extract_epi16::<1>(o);\n                    let z = _mm_extract_epi16::<2>(o);\n\n                    dst[cn.r_i()] = (x as u32).as_();\n                    dst[cn.g_i()] = (y as u32).as_();\n                    dst[cn.b_i()] = (z as u32).as_();\n                } else {\n                    let mut r = _mm_cvtepi32_ps(_mm_cvtepi16_epi32(v));\n                    r = _mm_mul_ps(r, f_value_scale);\n                    dst[cn.r_i()] = f32::from_bits(_mm_extract_ps::<0>(r) as u32).as_();\n                    dst[cn.g_i()] = f32::from_bits(_mm_extract_ps::<1>(r) as u32).as_();\n                    dst[cn.b_i()] = f32::from_bits(_mm_extract_ps::<2>(r) as u32).as_();\n                }\n                if channels == 4 {\n                    dst[cn.a_i()] = max_value;\n                }\n            }\n        }\n    }"
}