{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `slice::sort::merge`",
    "file": "par-iter-2.0.0/src/slice/sort.rs",
    "start_line": 1022,
    "start_col": 1,
    "end_line": 1121,
    "end_col": 2,
    "code_snippet": "unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &F)\nwhere\n    F: Fn(&T, &T) -> bool,\n{\n    let len = v.len();\n    let v = v.as_mut_ptr();\n\n    // SAFETY: mid and len must be in-bounds of v.\n    let (v_mid, v_end) = unsafe { (v.add(mid), v.add(len)) };\n\n    // The merge process first copies the shorter run into `buf`. Then it traces the\n    // newly copied run and the longer run forwards (or backwards), comparing\n    // their next unconsumed elements and copying the lesser (or greater) one\n    // into `v`.\n    //\n    // As soon as the shorter run is fully consumed, the process is done. If the\n    // longer run gets consumed first, then we must copy whatever is left of the\n    // shorter run into the remaining hole in `v`.\n    //\n    // Intermediate state of the process is always tracked by `hole`, which serves\n    // two purposes:\n    // 1. Protects integrity of `v` from panics in `is_less`.\n    // 2. Fills the remaining hole in `v` if the longer run gets consumed first.\n    //\n    // Panic safety:\n    //\n    // If `is_less` panics at any point during the process, `hole` will get dropped\n    // and fill the hole in `v` with the unconsumed range in `buf`, thus\n    // ensuring that `v` still holds every object it initially held exactly\n    // once.\n    let mut hole;\n\n    if mid <= len - mid {\n        // The left run is shorter.\n\n        // SAFETY: buf must have enough capacity for `v[..mid]`.\n        unsafe {\n            ptr::copy_nonoverlapping(v, buf, mid);\n            hole = MergeHole {\n                start: buf,\n                end: buf.add(mid),\n                dest: v,\n            };\n        }\n\n        // Initially, these pointers point to the beginnings of their arrays.\n        let left = &mut hole.start;\n        let mut right = v_mid;\n        let out = &mut hole.dest;\n\n        while *left < hole.end && right < v_end {\n            // Consume the lesser side.\n            // If equal, prefer the left run to maintain stability.\n\n            // SAFETY: left and right must be valid and part of v same for out.\n            unsafe {\n                let is_l = is_less(&*right, &**left);\n                let to_copy = if is_l { right } else { *left };\n                ptr::copy_nonoverlapping(to_copy, *out, 1);\n                *out = out.add(1);\n                right = right.add(is_l as usize);\n                *left = left.add(!is_l as usize);\n            }\n        }\n    } else {\n        // The right run is shorter.\n\n        // SAFETY: buf must have enough capacity for `v[mid..]`.\n        unsafe {\n            ptr::copy_nonoverlapping(v_mid, buf, len - mid);\n            hole = MergeHole {\n                start: buf,\n                end: buf.add(len - mid),\n                dest: v_mid,\n            };\n        }\n\n        // Initially, these pointers point past the ends of their arrays.\n        let left = &mut hole.dest;\n        let right = &mut hole.end;\n        let mut out = v_end;\n\n        while v < *left && buf < *right {\n            // Consume the greater side.\n            // If equal, prefer the right run to maintain stability.\n\n            // SAFETY: left and right must be valid and part of v same for out.\n            unsafe {\n                let is_l = is_less(&*right.sub(1), &*left.sub(1));\n                *left = left.sub(is_l as usize);\n                *right = right.sub(!is_l as usize);\n                let to_copy = if is_l { *left } else { *right };\n                out = out.sub(1);\n                ptr::copy_nonoverlapping(to_copy, out, 1);\n            }\n        }\n    }\n    // Finally, `hole` gets dropped. If the shorter run was not fully consumed,\n    // whatever remains of it will now be copied into the hole in `v`.\n}"
}