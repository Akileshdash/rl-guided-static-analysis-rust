{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `context::unify::Unifier::<'_, '_, '_, L>::sub_unify_tp`",
    "file": "erg_compiler-0.6.53-nightly.5/context/unify.rs",
    "start_line": 462,
    "start_col": 5,
    "end_line": 838,
    "end_col": 6,
    "code_snippet": "fn sub_unify_tp(\n        &self,\n        maybe_sub: &TyParam,\n        maybe_sup: &TyParam,\n        _variance: Option<Variance>,\n        allow_divergence: bool,\n    ) -> TyCheckResult<()> {\n        if maybe_sub.has_no_unbound_var()\n            && maybe_sup.has_no_unbound_var()\n            && maybe_sub == maybe_sup\n        {\n            return Ok(());\n        }\n        match (maybe_sub, maybe_sup) {\n            (TyParam::Type(sub), TyParam::Type(sup)) => self.sub_unify(sub, sup),\n            (TyParam::Value(ValueObj::Type(sub)), TyParam::Type(sup)) => {\n                self.sub_unify(sub.typ(), sup)\n            }\n            (TyParam::Type(sub), TyParam::Value(ValueObj::Type(sup))) => {\n                self.sub_unify(sub, sup.typ())\n            }\n            (TyParam::Value(sub), TyParam::Value(sup)) => self.sub_unify_value(sub, sup),\n            (TyParam::FreeVar(sub_fv), TyParam::FreeVar(sup_fv))\n                if sub_fv.is_unbound() && sup_fv.is_unbound() =>\n            {\n                if sub_fv.level().unwrap() > sup_fv.level().unwrap() {\n                    if !sub_fv.is_generalized() {\n                        maybe_sub.link(maybe_sup, self.undoable);\n                    }\n                } else if !sup_fv.is_generalized() {\n                    maybe_sup.link(maybe_sub, self.undoable);\n                }\n                Ok(())\n            }\n            (TyParam::FreeVar(sub_fv), _)\n                if !self.change_generalized && sub_fv.is_generalized() =>\n            {\n                Ok(())\n            }\n            (TyParam::FreeVar(sub_fv), sup_tp) => {\n                if let Some(l) = sub_fv.get_linked() {\n                    return self.sub_unify_tp(&l, sup_tp, _variance, allow_divergence);\n                }\n                // sub_fv\u3092\u53c2\u7167\u3057\u306a\u3044\u3088\u3046clone\u3059\u308b(\u3042\u3068\u3067borrow_mut\u3059\u308b\u305f\u3081)\n                let Some(fv_t) = sub_fv.constraint().unwrap().get_type().cloned() else {\n                    return Err(TyCheckErrors::from(TyCheckError::feature_error(\n                        self.ctx.cfg.input.clone(),\n                        line!() as usize,\n                        self.loc.loc(),\n                        &format!(\"unifying {sub_fv} and {sup_tp}\"),\n                        self.ctx.caused_by(),\n                    )));\n                };\n                let tp_t = self.ctx.get_tp_t(sup_tp)?;\n                if self.ctx.supertype_of(&fv_t, &tp_t) {\n                    // \u5916\u90e8\u672a\u9023\u643a\u578b\u5909\u6570\u306e\u5834\u5408\u3001link\u3057\u306a\u3044\u3067\u5236\u7d04\u3092\u5f31\u3081\u308b\u3060\u3051\u306b\u3059\u308b(see compiler/inference.md)\n                    if sub_fv.level() < Some(self.ctx.level) {\n                        let new_constraint = Constraint::new_subtype_of(tp_t);\n                        if self\n                            .ctx\n                            .is_sub_constraint_of(&sub_fv.constraint().unwrap(), &new_constraint)\n                            || sub_fv.constraint().unwrap().get_type() == Some(&Type)\n                        {\n                            maybe_sub.update_constraint(new_constraint, self.undoable, false);\n                        }\n                    } else {\n                        maybe_sub.link(sup_tp, self.undoable);\n                    }\n                    Ok(())\n                } else if allow_divergence\n                    && (self.ctx.eq_tp(sup_tp, &TyParam::value(Inf))\n                        || self.ctx.eq_tp(sup_tp, &TyParam::value(NegInf)))\n                    && self.ctx.subtype_of(&fv_t, &mono(\"Num\"))\n                {\n                    maybe_sub.link(sup_tp, self.undoable);\n                    Ok(())\n                } else {\n                    Err(TyCheckErrors::from(TyCheckError::feature_error(\n                        self.ctx.cfg.input.clone(),\n                        line!() as usize,\n                        self.loc.loc(),\n                        &format!(\"unifying {sub_fv} and {sup_tp}\"),\n                        self.ctx.caused_by(),\n                    )))\n                }\n            }\n            (_, TyParam::FreeVar(sup_fv))\n                if !self.change_generalized && sup_fv.is_generalized() =>\n            {\n                Ok(())\n            }\n            (sub_tp, TyParam::FreeVar(sup_fv)) => {\n                match &*sup_fv.borrow() {\n                    FreeKind::Linked(l) | FreeKind::UndoableLinked { t: l, .. } => {\n                        return self.sub_unify_tp(l, sub_tp, _variance, allow_divergence);\n                    }\n                    FreeKind::Unbound { .. } | FreeKind::NamedUnbound { .. } => {}\n                } // &fv is dropped\n                  // fv\u3092\u53c2\u7167\u3057\u306a\u3044\u3088\u3046\u306bclone\u3059\u308b(\u3042\u3068\u3067borrow_mut\u3059\u308b\u305f\u3081)\n                let Some(fv_t) = sup_fv.constraint().unwrap().get_type().cloned() else {\n                    return Err(TyCheckErrors::from(TyCheckError::feature_error(\n                        self.ctx.cfg.input.clone(),\n                        line!() as usize,\n                        self.loc.loc(),\n                        &format!(\"unifying {sub_tp} and {sup_fv}\"),\n                        self.ctx.caused_by(),\n                    )));\n                };\n                let tp_t = self.ctx.get_tp_t(sub_tp)?;\n                if self.ctx.supertype_of(&fv_t, &tp_t) {\n                    // \u5916\u90e8\u672a\u9023\u643a\u578b\u5909\u6570\u306e\u5834\u5408\u3001link\u3057\u306a\u3044\u3067\u5236\u7d04\u3092\u5f31\u3081\u308b\u3060\u3051\u306b\u3059\u308b(see compiler/inference.md)\n                    if sup_fv.level() < Some(self.ctx.level) {\n                        let new_constraint = Constraint::new_subtype_of(tp_t);\n                        if self\n                            .ctx\n                            .is_sub_constraint_of(&sup_fv.constraint().unwrap(), &new_constraint)\n                            || sup_fv.constraint().unwrap().get_type() == Some(&Type)\n                        {\n                            maybe_sup.update_constraint(new_constraint, self.undoable, false);\n                        }\n                    } else {\n                        maybe_sup.link(sub_tp, self.undoable);\n                    }\n                    // self.sub_unify(&tp_t, &fv_t)\n                    Ok(())\n                } else if allow_divergence\n                    && (self.ctx.eq_tp(sub_tp, &TyParam::value(Inf))\n                        || self.ctx.eq_tp(sub_tp, &TyParam::value(NegInf)))\n                    && self.ctx.subtype_of(&fv_t, &mono(\"Num\"))\n                {\n                    maybe_sup.link(sub_tp, self.undoable);\n                    // self.sub_unify(&tp_t, &fv_t)\n                    Ok(())\n                } else {\n                    Err(TyCheckErrors::from(TyCheckError::feature_error(\n                        self.ctx.cfg.input.clone(),\n                        line!() as usize,\n                        self.loc.loc(),\n                        &format!(\"unifying {sub_tp} and {sup_fv}\"),\n                        self.ctx.caused_by(),\n                    )))\n                }\n            }\n            (TyParam::UnaryOp { op: lop, val: lval }, TyParam::UnaryOp { op: rop, val: rval })\n                if lop == rop =>\n            {\n                self.sub_unify_tp(lval, rval, _variance, allow_divergence)\n            }\n            (\n                TyParam::BinOp { op: lop, lhs, rhs },\n                TyParam::BinOp {\n                    op: rop,\n                    lhs: lhs2,\n                    rhs: rhs2,\n                },\n            ) if lop == rop => {\n                self.sub_unify_tp(lhs, lhs2, _variance, allow_divergence)?;\n                self.sub_unify_tp(rhs, rhs2, _variance, allow_divergence)\n            }\n            (sub, TyParam::Erased(t)) => {\n                let sub_t = self.ctx.get_tp_t(sub)?;\n                if self.ctx.subtype_of(&sub_t, t) {\n                    Ok(())\n                } else {\n                    Err(TyCheckErrors::from(TyCheckError::subtyping_error(\n                        self.ctx.cfg.input.clone(),\n                        line!() as usize,\n                        &sub_t,\n                        t,\n                        self.loc.loc(),\n                        self.ctx.caused_by(),\n                    )))\n                }\n            }\n            (TyParam::Erased(t), TyParam::Type(sup)) => {\n                if self.ctx.subtype_of(t, &Type::Type) {\n                    Ok(())\n                } else {\n                    Err(TyCheckErrors::from(TyCheckError::subtyping_error(\n                        self.ctx.cfg.input.clone(),\n                        line!() as usize,\n                        t,\n                        sup,\n                        self.loc.loc(),\n                        self.ctx.caused_by(),\n                    )))\n                }\n            }\n            (sub, TyParam::Type(sup)) => {\n                let l = self.ctx.convert_tp_into_type(sub.clone()).map_err(|_| {\n                    TyCheckError::tp_to_type_error(\n                        self.ctx.cfg.input.clone(),\n                        line!() as usize,\n                        sub,\n                        self.loc.loc(),\n                        self.ctx.caused_by(),\n                    )\n                })?;\n                self.sub_unify(&l, sup)?;\n                Ok(())\n            }\n            (TyParam::Erased(t), sup) => {\n                let sup_t = self.ctx.get_tp_t(sup)?;\n                if self.ctx.subtype_of(t, &sup_t) {\n                    Ok(())\n                } else {\n                    Err(TyCheckErrors::from(TyCheckError::subtyping_error(\n                        self.ctx.cfg.input.clone(),\n                        line!() as usize,\n                        t,\n                        &sup_t,\n                        self.loc.loc(),\n                        self.ctx.caused_by(),\n                    )))\n                }\n            }\n            (TyParam::Type(sub), sup) => {\n                let r = self.ctx.convert_tp_into_type(sup.clone()).map_err(|_| {\n                    TyCheckError::tp_to_type_error(\n                        self.ctx.cfg.input.clone(),\n                        line!() as usize,\n                        sup,\n                        self.loc.loc(),\n                        self.ctx.caused_by(),\n                    )\n                })?;\n                self.sub_unify(sub, &r)?;\n                Ok(())\n            }\n            (TyParam::List(sub), TyParam::List(sup))\n            | (TyParam::Tuple(sub), TyParam::Tuple(sup)) => {\n                for (l, r) in sub.iter().zip(sup.iter()) {\n                    self.sub_unify_tp(l, r, _variance, allow_divergence)?;\n                }\n                Ok(())\n            }\n            (TyParam::Dict(sub), TyParam::Dict(sup)) => {\n                if sub.len() == 1 && sup.len() == 1 {\n                    let sub_key = sub.keys().next().unwrap();\n                    let sup_key = sup.keys().next().unwrap();\n                    // contravariant\n                    self.sub_unify_tp(sup_key, sub_key, _variance, allow_divergence)?;\n                    let sub_value = sub.values().next().unwrap();\n                    let sup_value = sup.values().next().unwrap();\n                    self.sub_unify_tp(sub_value, sup_value, _variance, allow_divergence)?;\n                    return Ok(());\n                }\n                for (sub_k, sub_v) in sub.iter() {\n                    if let Some(sup_v) = sup\n                        .linear_get(sub_k)\n                        .or_else(|| sub_tpdict_get(sup, sub_k, self.ctx))\n                    {\n                        // self.sub_unify_tp(sub_k, sup_k, _variance, loc, allow_divergence)?;\n                        self.sub_unify_tp(sub_v, sup_v, _variance, allow_divergence)?;\n                    } else {\n                        log!(err \"{sup} does not have key {sub_k}\");\n                        // TODO:\n                        return Err(TyCheckErrors::from(TyCheckError::feature_error(\n                            self.ctx.cfg.input.clone(),\n                            line!() as usize,\n                            self.loc.loc(),\n                            &format!(\"unifying {sub} and {sup}\"),\n                            self.ctx.caused_by(),\n                        )));\n                    }\n                }\n                Ok(())\n            }\n            (TyParam::Record(sub), TyParam::Record(sup)) => {\n                for (sub_k, sub_v) in sub.iter() {\n                    if let Some(sup_v) = sup.get(sub_k) {\n                        self.sub_unify_tp(sub_v, sup_v, _variance, allow_divergence)?;\n                    } else {\n                        log!(err \"{sup} does not have field {sub_k}\");\n                        return Err(TyCheckErrors::from(TyCheckError::feature_error(\n                            self.ctx.cfg.input.clone(),\n                            line!() as usize,\n                            self.loc.loc(),\n                            &format!(\"unifying {sub} and {sup}\"),\n                            self.ctx.caused_by(),\n                        )));\n                    }\n                }\n                Ok(())\n            }\n            (\n                TyParam::ProjCall { obj, attr, args },\n                TyParam::ProjCall {\n                    obj: o2,\n                    attr: a2,\n                    args: args2,\n                },\n            ) => {\n                if attr == a2 {\n                    self.sub_unify_tp(obj, o2, _variance, allow_divergence)?;\n                    for (l, r) in args.iter().zip(args2.iter()) {\n                        self.sub_unify_tp(l, r, _variance, allow_divergence)?;\n                    }\n                    Ok(())\n                } else {\n                    if DEBUG_MODE {\n                        todo!()\n                    }\n                    Ok(())\n                }\n            }\n            (\n                TyParam::App {\n                    name: ln,\n                    args: largs,\n                },\n                TyParam::App {\n                    name: rn,\n                    args: rargs,\n                },\n            ) if ln == rn => {\n                for (l, r) in largs.iter().zip(rargs.iter()) {\n                    self.sub_unify_tp(l, r, _variance, allow_divergence)?;\n                }\n                Ok(())\n            }\n            (TyParam::Lambda(sub_l), TyParam::Lambda(sup_l)) => {\n                for (sup_nd, sub_nd) in sup_l.nd_params.iter().zip(sub_l.nd_params.iter()) {\n                    self.sub_unify(sub_nd.typ(), sup_nd.typ())?;\n                }\n                if let Some((sup_var, sub_var)) =\n                    sup_l.var_params.as_ref().zip(sub_l.var_params.as_ref())\n                {\n                    self.sub_unify(sub_var.typ(), sup_var.typ())?;\n                }\n                for (sup_d, sub_d) in sup_l.d_params.iter().zip(sub_l.d_params.iter()) {\n                    self.sub_unify(sub_d.typ(), sup_d.typ())?;\n                }\n                if let Some((sup_kw_var, sub_kw_var)) = sup_l\n                    .kw_var_params\n                    .as_ref()\n                    .zip(sub_l.kw_var_params.as_ref())\n                {\n                    self.sub_unify(sub_kw_var.typ(), sup_kw_var.typ())?;\n                }\n                for (sub_expr, sup_expr) in sub_l.body.iter().zip(sup_l.body.iter()) {\n                    self.sub_unify_tp(sub_expr, sup_expr, _variance, allow_divergence)?;\n                }\n                Ok(())\n            }\n            (l, TyParam::Value(sup)) => {\n                let sup = match Context::convert_value_into_tp(sup.clone()) {\n                    Ok(r) => r,\n                    Err(tp) => {\n                        return type_feature_error!(\n                            self.ctx,\n                            self.loc.loc(),\n                            &format!(\"unifying {l} and {tp}\")\n                        )\n                    }\n                };\n                self.sub_unify_tp(maybe_sub, &sup, _variance, allow_divergence)\n            }\n            (TyParam::Value(sub), r) => {\n                let sub = match Context::convert_value_into_tp(sub.clone()) {\n                    Ok(l) => l,\n                    Err(tp) => {\n                        return type_feature_error!(\n                            self.ctx,\n                            self.loc.loc(),\n                            &format!(\"unifying {tp} and {r}\")\n                        )\n                    }\n                };\n                self.sub_unify_tp(&sub, maybe_sup, _variance, allow_divergence)\n            }\n            (l, r) => {\n                log!(err \"{l} / {r}\");\n                type_feature_error!(self.ctx, self.loc.loc(), &format!(\"unifying {l} and {r}\"))\n            }\n        }\n    }"
}