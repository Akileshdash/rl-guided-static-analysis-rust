{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `gemm::kernels::simd_generic::simd_gemv_transposed`",
    "file": "rten-0.20.0/src/gemm/kernels/simd_generic.rs",
    "start_line": 106,
    "start_col": 1,
    "end_line": 170,
    "end_col": 2,
    "code_snippet": "fn simd_gemv_transposed<I: Isa>(\n    isa: I,\n    mut out: MatVecOutput<f32>,\n    a: &[f32],\n    b: Matrix,\n    alpha: f32,\n) {\n    assert_eq!(b.row_stride(), 1);\n    assert_eq!(a.len(), b.rows());\n    assert_eq!(out.data.len(), b.cols());\n\n    let ops = isa.f32();\n    let b_ptr = b.storage().as_ptr();\n    let b_col_stride = b.col_stride();\n\n    const COL_TILE: usize = 8;\n\n    let mut col_tiles = range_chunks_exact(0..b.cols(), COL_TILE);\n    for col_tile in col_tiles.by_ref() {\n        let mut acc = [ops.zero(); COL_TILE];\n\n        let mut depth_tiles = range_chunks_exact(0..a.len(), ops.len());\n        for depth_tile in depth_tiles.by_ref() {\n            let a_tile = unsafe { ops.load_ptr(a.as_ptr().add(depth_tile.start)) };\n            for i in 0..COL_TILE {\n                let b_col_ptr = unsafe { b_ptr.add((col_tile.start + i) * b_col_stride) };\n                let b_tile = unsafe { ops.load_ptr(b_col_ptr.add(depth_tile.start)) };\n                acc[i] = ops.mul_add(a_tile, b_tile, acc[i]);\n            }\n        }\n\n        let mut acc: [f32; COL_TILE] = std::array::from_fn(|i| ops.sum(acc[i]));\n        for k in depth_tiles.remainder() {\n            let ak = unsafe { *a.get_unchecked(k) };\n            for i in 0..COL_TILE {\n                let b_col_ptr = unsafe { b_ptr.add((col_tile.start + i) * b_col_stride) };\n                let bk = unsafe { *b_col_ptr.add(k) };\n                acc[i] = ak.mul_add(bk, acc[i]);\n            }\n        }\n\n        if out.beta == 0. {\n            for i in 0..COL_TILE {\n                out.data[col_tile.start + i].write(alpha * acc[i]);\n            }\n        } else {\n            for i in 0..COL_TILE {\n                // Safety: Output is initialized when `beta` is non-zero.\n                let out_val = alpha * acc[i]\n                    + out.beta * unsafe { out.data[col_tile.start + i].assume_init() };\n                out.data[col_tile.start + i].write(out_val);\n            }\n        }\n    }\n\n    let last_col_tile = col_tiles.remainder();\n    if !last_col_tile.is_empty() {\n        simd_gemv_fallback(\n            out.slice_mut(last_col_tile.clone()),\n            a,\n            b.slice((.., last_col_tile)),\n            alpha,\n        );\n    }\n}"
}