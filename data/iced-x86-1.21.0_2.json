{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `formatter::fast::SpecializedFormatter::<TraitOptions>::format_number`",
    "file": "iced-x86-1.21.0/src/formatter/fast.rs",
    "start_line": 1560,
    "start_col": 2,
    "end_line": 1678,
    "end_col": 3,
    "code_snippet": "fn format_number(&self, dst: &mut Vec<u8>, mut dst_next_p: *mut u8, value: u64) -> *mut u8 {\n\t\tmacro_rules! format_number_impl {\n\t\t\t($dst:ident, $dst_next_p:ident, $value:ident, $uppercase_hex:literal, $use_hex_prefix:literal) => {{\n\t\t\t\tif $use_hex_prefix {\n\t\t\t\t\tconst FAST_STR: FastString4 = mk_const_fast_str!(FastString4, \"\\x020x  \");\n\t\t\t\t\twrite_fast_str!($dst, $dst_next_p, FastString4, FAST_STR);\n\t\t\t\t}\n\n\t\t\t\tif $value < 0x10 {\n\t\t\t\t\tif $use_hex_prefix {\n\t\t\t\t\t\tlet hex_table = if $uppercase_hex { b\"0123456789ABCDEF\" } else { b\"0123456789abcdef\" };\n\t\t\t\t\t\t// SAFETY: 0<=$value<=0xF and hex_table.len() == 0x10\n\t\t\t\t\t\tlet c = unsafe { *hex_table.get_unchecked($value as usize) };\n\t\t\t\t\t\twrite_fast_ascii_char!($dst, $dst_next_p, c, true);\n\n\t\t\t\t\t\t$dst_next_p\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 1 (possible '0' prefix) + 1 (hex digit) + 1 ('h' suffix)\n\t\t\t\t\t\tverify_output_has_enough_bytes_left!($dst, $dst_next_p, 1 + 1 + 1);\n\t\t\t\t\t\tif $value > 9 {\n\t\t\t\t\t\t\twrite_fast_ascii_char_lit!($dst, $dst_next_p, '0', false);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet hex_table = if $uppercase_hex { b\"0123456789ABCDEF\" } else { b\"0123456789abcdef\" };\n\t\t\t\t\t\t// SAFETY: 0<=$value<=0xF and hex_table.len() == 0x10\n\t\t\t\t\t\tlet c = unsafe { *hex_table.get_unchecked($value as usize) };\n\t\t\t\t\t\twrite_fast_ascii_char!($dst, $dst_next_p, c, false);\n\t\t\t\t\t\twrite_fast_ascii_char_lit!($dst, $dst_next_p, 'h', false);\n\n\t\t\t\t\t\t$dst_next_p\n\t\t\t\t\t}\n\t\t\t\t} else if $value < 0x100 {\n\t\t\t\t\tif $use_hex_prefix {\n\t\t\t\t\t\tlet lower_or_value = if $uppercase_hex { 0 } else { 0x2020_2020 };\n\t\t\t\t\t\twrite_fast_hex2_rw_4bytes!($dst, $dst_next_p, $value, lower_or_value, true);\n\n\t\t\t\t\t\t$dst_next_p\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 1 (possible '0' prefix) + 2 (hex digits) + 2 since\n\t\t\t\t\t\t// write_fast_hex2_rw_4bytes!() reads/writes 4 bytes and not 2.\n\t\t\t\t\t\t// '+2' also includes the 'h' suffix.\n\t\t\t\t\t\tverify_output_has_enough_bytes_left!($dst, $dst_next_p, 1 + 2 + 2);\n\t\t\t\t\t\tif $value > 0x9F {\n\t\t\t\t\t\t\twrite_fast_ascii_char_lit!($dst, $dst_next_p, '0', false);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet lower_or_value = if $uppercase_hex { 0 } else { 0x2020_2020 };\n\t\t\t\t\t\twrite_fast_hex2_rw_4bytes!($dst, $dst_next_p, $value, lower_or_value, false);\n\t\t\t\t\t\twrite_fast_ascii_char_lit!($dst, $dst_next_p, 'h', false);\n\n\t\t\t\t\t\t$dst_next_p\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet mut rshift = ((64 - u64::leading_zeros($value) + 3) & !3) as usize;\n\n\t\t\t\t\t// The first '1' is an optional '0' prefix.\n\t\t\t\t\t// `rshift / 4` == number of hex digits to copy. The last `+ 2` is the extra padding needed\n\t\t\t\t\t// since the write_fast_hex2_rw_4bytes!() macro reads and writes 4 bytes (2 hex digits + 2 bytes padding).\n\t\t\t\t\t// '+2' also includes the 'h' suffix.\n\t\t\t\t\tverify_output_has_enough_bytes_left!($dst, $dst_next_p, 1 + rshift / 4 + 2);\n\n\t\t\t\t\tif !$use_hex_prefix && (($value >> (rshift - 4)) & 0xF) > 9 {\n\t\t\t\t\t\twrite_fast_ascii_char_lit!($dst, $dst_next_p, '0', false);\n\t\t\t\t\t}\n\n\t\t\t\t\t// If odd number of hex digits\n\t\t\t\t\tif (rshift & 4) != 0 {\n\t\t\t\t\t\trshift -= 4;\n\t\t\t\t\t\tlet hex_table = if $uppercase_hex { b\"0123456789ABCDEF\" } else { b\"0123456789abcdef\" };\n\t\t\t\t\t\tlet digit = (($value >> rshift) & 0xF) as usize;\n\t\t\t\t\t\t// SAFETY: 0<=digit<=0xF and hex_table.len() == 0x10\n\t\t\t\t\t\tlet c = unsafe { *hex_table.get_unchecked(digit) };\n\t\t\t\t\t\twrite_fast_ascii_char!($dst, $dst_next_p, c, false);\n\t\t\t\t\t}\n\n\t\t\t\t\t// If we're here, $value >= 0x100 so rshift >= 8\n\t\t\t\t\tdebug_assert!(rshift >= 8);\n\t\t\t\t\tlet lower_or_value = if $uppercase_hex { 0 } else { 0x2020_2020 };\n\t\t\t\t\tloop {\n\t\t\t\t\t\trshift -= 8;\n\t\t\t\t\t\tlet digits2 = (($value >> rshift) & 0xFF) as usize;\n\t\t\t\t\t\twrite_fast_hex2_rw_4bytes!($dst, $dst_next_p, digits2, lower_or_value, false);\n\n\t\t\t\t\t\tif rshift == 0 {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif !$use_hex_prefix {\n\t\t\t\t\t\t// We've verified that `dst` had `1 + rshift / 4 + 2` bytes left (see above).\n\t\t\t\t\t\t// The last `+2` is the padding that needed to be there. That's where\n\t\t\t\t\t\t// this 'h' gets written so we don't need to verify the vec len here\n\t\t\t\t\t\t// because it has at least 2 more bytes left.\n\t\t\t\t\t\twrite_fast_ascii_char_lit!($dst, $dst_next_p, 'h', false);\n\t\t\t\t\t}\n\n\t\t\t\t\t$dst_next_p\n\t\t\t\t}\n\t\t\t}};\n\t\t}\n\n\t\tif TraitOptions::uppercase_hex(&self.d.options) {\n\t\t\tif TraitOptions::use_hex_prefix(&self.d.options) {\n\t\t\t\t// 0x12AB\n\t\t\t\tformat_number_impl!(dst, dst_next_p, value, true, true)\n\t\t\t} else {\n\t\t\t\t// 12ABh\n\t\t\t\tformat_number_impl!(dst, dst_next_p, value, true, false)\n\t\t\t}\n\t\t} else {\n\t\t\tif TraitOptions::use_hex_prefix(&self.d.options) {\n\t\t\t\t// 0x12ab\n\t\t\t\tformat_number_impl!(dst, dst_next_p, value, false, true)\n\t\t\t} else {\n\t\t\t\t// 12abh\n\t\t\t\tformat_number_impl!(dst, dst_next_p, value, false, false)\n\t\t\t}\n\t\t}\n\t}"
}