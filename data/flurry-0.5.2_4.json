{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `map::HashMap::<K, V, S>::put`",
    "file": "flurry-0.5.2/src/map.rs",
    "start_line": 1665,
    "start_col": 5,
    "end_line": 1969,
    "end_col": 6,
    "code_snippet": "fn put<'g>(\n        &'g self,\n        mut key: K,\n        value: V,\n        no_replacement: bool,\n        guard: &'g Guard<'_>,\n    ) -> PutResult<'g, V> {\n        let hash = self.hash(&key);\n        let mut table = self.table.load(Ordering::SeqCst, guard);\n        let mut bin_count;\n        let value = Shared::boxed(value, &self.collector);\n        let mut old_val = None;\n        loop {\n            // safety: see argument below for !is_null case\n            if table.is_null() || unsafe { table.deref() }.is_empty() {\n                table = self.init_table(guard);\n                continue;\n            }\n\n            // safety: table is a valid pointer.\n            //\n            // we are in one of three cases:\n            //\n            //  1. if table is the one we read before the loop, then we read it while holding the\n            //     guard, so it won't be dropped until after we drop that guard b/c this thread must\n            //     have been included in the reference count of a retirement.\n            //\n            //  2. if table is read by init_table, we did so while holding a guard, so the\n            //     argument is as for point 1. or, we allocated the table while holding a guard,\n            //     so the earliest it can be deallocated is after we drop our guard.\n            //\n            //  3. if table is set by a Moved node (below) through help_transfer, it will _either_\n            //     keep using `table` (which is fine by 1. and 2.), or use the `next_table` raw\n            //     pointer from inside the Moved. to see that if a Moved(t) is _read_, then t must\n            //     still be valid, see the safety comment on Table.next_table.\n            let t = unsafe { table.deref() };\n\n            let bini = t.bini(hash);\n            let mut bin = t.bin(bini, guard);\n            if bin.is_null() {\n                // fast path -- bin is empty so stick us at the front\n                let node =\n                    Shared::boxed(BinEntry::Node(Node::new(hash, key, value)), &self.collector);\n                match t.cas_bin(bini, bin, node, guard) {\n                    Ok(_old_null_ptr) => {\n                        self.add_count(1, Some(0), guard);\n                        // safety: we have not moved the node's value since we placed it into\n                        // its `Atomic` in the very beginning of the method, so the ref is still\n                        // valid. since the value is not currently marked as garbage, and since\n                        // `value` was loaded under a guard, the returned reference will remain valid\n                        // for the guard's lifetime.\n                        return PutResult::Inserted {\n                            new: unsafe { value.deref() },\n                        };\n                    }\n                    Err(changed) => {\n                        assert!(!changed.current.is_null());\n                        bin = changed.current;\n                        let BinEntry::Node(node) = unsafe { changed.new.into_box() }.value else {\n                            unreachable!(\"we declared node and it is a BinEntry::Node\");\n                        };\n                        key = node.key;\n                    }\n                }\n            }\n\n            // slow path -- bin is non-empty\n            //\n            // safety: bin is a valid pointer.\n            //\n            // there are three cases when a bin pointer is invalidated:\n            //\n            //  1. if the table was resized, bin is a move entry, and the resize has completed. in\n            //     that case, the table (and all its heads) have already been retired.\n            //  2. if the table is being resized, bin may be swapped with a move entry. the old bin\n            //     will only be retired after that happens.\n            //  3. when elements are inserted into or removed from the map, bin may be changed into\n            //     or from a TreeBin from or into a regular, linear bin. the old bin will be\n            //     retired only once that happens.\n            //\n            // in all cases, we held the guard when we got the reference to the bin. if any such\n            // swap happened, it must have happened _after_ we read. since we did the read while\n            // the current thread was marked as active, we must be included in the reference count,\n            // and the drop must happen _after_ we decrement the count (i.e drop our guard).\n            match **unsafe { bin.deref() } {\n                BinEntry::Moved => {\n                    table = self.help_transfer(table, guard);\n                    continue;\n                }\n                BinEntry::Node(ref head)\n                    if no_replacement && head.hash == hash && head.key == key =>\n                {\n                    // fast path if replacement is disallowed and first bin matches\n                    let v = head.value.load(Ordering::SeqCst, guard);\n                    // safety (for v): since the value is present now, and we've held a guard from\n                    // the beginning of the search, the value cannot be dropped after we drop our guard.\n                    // safety (for value): since we never inserted the value in the tree, `value`\n                    // is the last remaining pointer to the initial value.\n                    return PutResult::Exists {\n                        current: unsafe { v.deref() },\n                        not_inserted: unsafe { value.into_box() },\n                    };\n                }\n                BinEntry::Node(ref head) => {\n                    // bin is non-empty, need to link into it, so we must take the lock\n                    let head_lock = head.lock.lock();\n\n                    // need to check that this is _still_ the head\n                    let current_head = t.bin(bini, guard);\n                    if current_head != bin {\n                        // nope -- try again from the start\n                        continue;\n                    }\n\n                    // yes, it is still the head, so we can now \"own\" the bin\n                    // note that there can still be readers in the bin!\n\n                    // TODO: ReservationNode\n\n                    bin_count = 1;\n                    let mut p = bin;\n\n                    old_val = loop {\n                        // safety: we loaded the bin while holding a guard, so any retirements\n                        // must have seen us as active. the bin and its nodes cannot be dropped\n                        // until at least after we drop our guard.\n                        let n = unsafe { p.deref() }.as_node().unwrap();\n                        if n.hash == hash && n.key == key {\n                            // the key already exists in the map!\n                            let current_value = n.value.load(Ordering::SeqCst, guard);\n\n                            // safety: since the value is present now, and we've held a guard from\n                            // the beginning of the search, the value cannot be dropped until after\n                            // we drop our guard.\n                            let current_value = unsafe { current_value.deref() };\n\n                            if no_replacement {\n                                // the key is not absent, so don't update because of\n                                // `no_replacement`, we don't use the new value, so we need to clean\n                                // it up and return it back to the caller\n                                // safety: we own value and did not share it\n                                return PutResult::Exists {\n                                    current: current_value,\n                                    not_inserted: unsafe { value.into_box() },\n                                };\n                            } else {\n                                // update the value in the existing node\n                                let now_garbage = n.value.swap(value, Ordering::SeqCst, guard);\n                                // NOTE: now_garbage == current_value\n\n                                // safety: need to guarantee that now_garbage is no longer\n                                // reachable. more specifically, no thread that executes _after_\n                                // this line can ever get a reference to now_garbage.\n                                //\n                                // here are the possible cases:\n                                //\n                                //  - another thread already has a reference to now_garbage.\n                                //    they must have read it before the call to swap while\n                                //    marked as active (holding a guard), and are included in\n                                //    the reference count. therefore t won't be freed until _after_\n                                //    it decrements the reference count, which can only happen\n                                //    when that thread drops its guard, and with it, any reference\n                                //    to the value.\n                                //  - another thread is about to get a reference to this value.\n                                //    they execute _after_ the swap, and therefore do _not_ get a\n                                //    reference to now_garbage (they get `value` instead). there are\n                                //    no other ways to get to a value except through its Node's\n                                //    `value` field (which is what we swapped), so freeing\n                                //    now_garbage is fine.\n                                unsafe { guard.retire_shared(now_garbage) };\n                            }\n                            break Some(current_value);\n                        }\n\n                        // TODO: This Ordering can probably be relaxed due to the Mutex\n                        let next = n.next.load(Ordering::SeqCst, guard);\n                        if next.is_null() {\n                            // we're at the end of the bin -- stick the node here!\n                            let node = Shared::boxed(\n                                BinEntry::Node(Node::new(hash, key, value)),\n                                &self.collector,\n                            );\n                            n.next.store(node, Ordering::SeqCst);\n                            break None;\n                        }\n                        p = next;\n\n                        bin_count += 1;\n                    };\n                    drop(head_lock);\n                }\n                // NOTE: BinEntry::Tree(ref tree_bin) if no_replacement && head.hash == h && &head.key == key\n                // cannot occur as in the Java code, TreeBins have a special, indicator hash value\n                BinEntry::Tree(ref tree_bin) => {\n                    // bin is non-empty, need to link into it, so we must take the lock\n                    let head_lock = tree_bin.lock.lock();\n\n                    // need to check that this is _still_ the correct bin\n                    let current_head = t.bin(bini, guard);\n                    if current_head != bin {\n                        // nope -- try again from the start\n                        continue;\n                    }\n\n                    // yes, it is still the head, so we can now \"own\" the bin\n                    // note that there can still be readers in the bin!\n\n                    // we don't actually count bins, just set this low enough\n                    // that we don't try to treeify the bin later\n                    bin_count = 2;\n                    let p = tree_bin.find_or_put_tree_val(hash, key, value, guard, &self.collector);\n                    if p.is_null() {\n                        // no TreeNode was returned, so the key did not previously exist in the\n                        // TreeBin. This means it was successfully put there by the call above\n                        // and we are done.\n                        break;\n                    }\n                    // safety: the TreeBin was read under our guard, at which point the tree\n                    // structure was valid. Since our guard marks the current thread as active,\n                    // the TreeNodes remain valid for at least as long as we hold onto the\n                    // guard.\n                    // Structurally, TreeNodes always point to TreeNodes, so this is sound.\n                    let tree_node = unsafe { TreeNode::get_tree_node(p) };\n                    old_val = {\n                        let current_value = tree_node.node.value.load(Ordering::SeqCst, guard);\n                        // safety: since the value is present now, and we've held a guard from\n                        // the beginning of the search, the value cannot be dropped until after\n                        // we drop our guard.\n                        let current_value = unsafe { current_value.deref() };\n                        if no_replacement {\n                            // the key is not absent, so don't update because of\n                            // `no_replacement`, we don't use the new value, so we need to clean\n                            // it up and return it back to the caller\n                            // safety: we own value and did not share it\n                            return PutResult::Exists {\n                                current: current_value,\n                                not_inserted: unsafe { value.into_box() },\n                            };\n                        } else {\n                            let now_garbage =\n                                tree_node.node.value.swap(value, Ordering::SeqCst, guard);\n                            // NOTE: now_garbage == current_value\n\n                            // safety: need to guarantee that now_garbage is no longer\n                            // reachable. more specifically, no thread that executes _after_\n                            // this line can ever get a reference to now_garbage.\n                            //\n                            // here are the possible cases:\n                            //\n                            //  - another thread already has a reference to now_garbage.\n                            //    they must have read it before the call to swap while\n                            //    marked as active (holding a guard), and are included in\n                            //    the reference count. therefore t won't be freed until _after_\n                            //    it decrements the reference count, which can only happen\n                            //    when that thread drops its guard, and with it, any reference\n                            //    to the value.\n                            //  - another thread is about to get a reference to this value.\n                            //    they execute _after_ the swap, and therefore do _not_ get a\n                            //    reference to now_garbage (they get `value` instead). there are\n                            //    no other ways to get to a value except through its Node's\n                            //    `value` field (which is what we swapped), so freeing\n                            //    now_garbage is fine.\n                            unsafe { guard.retire_shared(now_garbage) };\n                        }\n                        Some(current_value)\n                    };\n                    drop(head_lock);\n                }\n                BinEntry::TreeNode(_) => unreachable!(\n                    \"The head of a bin cannot be a TreeNode directly without BinEntry::Tree\"\n                ),\n            }\n            // NOTE: the Java code checks `bin_count` here because they also\n            // reach this point if the bin changed while obtaining the lock.\n            // However, our code doesn't (it uses continue) and `bin_count`\n            // _cannot_ be 0 at this point.\n            debug_assert_ne!(bin_count, 0);\n            if bin_count >= TREEIFY_THRESHOLD {\n                self.treeify_bin(t, bini, guard);\n            }\n            if let Some(old_val) = old_val {\n                return PutResult::Replaced {\n                    old: old_val,\n                    // safety: we have not moved the node's value since we placed it into\n                    // its `Atomic` in the very beginning of the method, so the ref is still\n                    // valid. since the value is not currently marked as garbage, and since\n                    // `value` was loaded under a guard, the returned reference will remain valid\n                    // for the guard's lifetime.\n                    new: unsafe { value.deref() },\n                };\n            }\n            break;\n        }\n        // increment count, since we only get here if we did not return an old (updated) value\n        debug_assert!(old_val.is_none());\n        self.add_count(1, Some(bin_count), guard);\n        PutResult::Inserted {\n            // safety: we have not moved the node's value since we placed it into\n            // its `Atomic` in the very beginning of the method, so the ref is still\n            // valid. since the value is not currently marked as garbage, and since\n            // `value` was loaded under a guard, the returned reference will remain valid\n            // for the guard's lifetime.\n            new: unsafe { value.deref() },\n        }\n    }"
}