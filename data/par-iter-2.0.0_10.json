{
    "level": "Warning",
    "analyzer": "UnsafeDataflow",
    "op_type": "ReadFlow",
    "description": "Potential unsafe dataflow issue in `slice::sort::insert_head`",
    "file": "par-iter-2.0.0/src/slice/sort.rs",
    "start_line": 109,
    "start_col": 1,
    "end_line": 167,
    "end_col": 2,
    "code_snippet": "unsafe fn insert_head<T, F>(v: &mut [T], is_less: &F)\nwhere\n    F: Fn(&T, &T) -> bool,\n{\n    debug_assert!(v.len() >= 2);\n\n    // SAFETY: caller must ensure v is at least len 2.\n    unsafe {\n        if is_less(v.get_unchecked(1), v.get_unchecked(0)) {\n            let arr_ptr = v.as_mut_ptr();\n\n            // There are three ways to implement insertion here:\n            //\n            // 1. Swap adjacent elements until the first one gets to its final destination.\n            //    However, this way we copy data around more than is necessary. If elements\n            //    are big structures (costly to copy), this method will be slow.\n            //\n            // 2. Iterate until the right place for the first element is found. Then shift\n            //    the elements succeeding it to make room for it and finally place it into\n            //    the remaining hole. This is a good method.\n            //\n            // 3. Copy the first element into a temporary variable. Iterate until the right\n            //    place for it is found. As we go along, copy every traversed element into\n            //    the slot preceding it. Finally, copy data from the temporary variable into\n            //    the remaining hole. This method is very good. Benchmarks demonstrated\n            //    slightly better performance than with the 2nd method.\n            //\n            // All methods were benchmarked, and the 3rd showed best results. So we chose\n            // that one.\n            let tmp = mem::ManuallyDrop::new(ptr::read(arr_ptr));\n\n            // Intermediate state of the insertion process is always tracked by `hole`,\n            // which serves two purposes:\n            // 1. Protects integrity of `v` from panics in `is_less`.\n            // 2. Fills the remaining hole in `v` in the end.\n            //\n            // Panic safety:\n            //\n            // If `is_less` panics at any point during the process, `hole` will get dropped\n            // and fill the hole in `v` with `tmp`, thus ensuring that `v` still\n            // holds every object it initially held exactly once.\n            let mut hole = InsertionHole {\n                src: &*tmp,\n                dest: arr_ptr.add(1),\n            };\n            ptr::copy_nonoverlapping(arr_ptr.add(1), arr_ptr.add(0), 1);\n\n            for i in 2..v.len() {\n                if !is_less(v.get_unchecked(i), &*tmp) {\n                    break;\n                }\n                ptr::copy_nonoverlapping(arr_ptr.add(i), arr_ptr.add(i - 1), 1);\n                hole.dest = arr_ptr.add(i);\n            }\n            // `hole` gets dropped and thus copies `tmp` into the remaining hole\n            // in `v`.\n        }\n    }\n}"
}