{
    "level": "Warning",
    "analyzer": "UnsafeDataflow",
    "op_type": "WriteFlow",
    "description": "Potential unsafe dataflow issue in `SmallVec::<A>::insert_many`",
    "file": "smallvec-1.15.1/src/lib.rs",
    "start_line": 1395,
    "start_col": 5,
    "end_line": 1477,
    "end_col": 6,
    "code_snippet": "pub fn insert_many<I: IntoIterator<Item = A::Item>>(&mut self, index: usize, iterable: I) {\n        let mut iter = iterable.into_iter();\n        if index == self.len() {\n            return self.extend(iter);\n        }\n\n        let (lower_size_bound, _) = iter.size_hint();\n        assert!(lower_size_bound <= core::isize::MAX as usize); // Ensure offset is indexable\n        assert!(index + lower_size_bound >= index); // Protect against overflow\n\n        let mut num_added = 0;\n        let old_len = self.len();\n        assert!(index <= old_len);\n\n        unsafe {\n            // Reserve space for `lower_size_bound` elements.\n            self.reserve(lower_size_bound);\n            let start = self.as_mut_ptr();\n            let ptr = start.add(index);\n\n            // Move the trailing elements.\n            ptr::copy(ptr, ptr.add(lower_size_bound), old_len - index);\n\n            // In case the iterator panics, don't double-drop the items we just copied above.\n            self.set_len(0);\n            let mut guard = DropOnPanic {\n                start,\n                skip: index..(index + lower_size_bound),\n                len: old_len + lower_size_bound,\n            };\n\n            // The set_len above invalidates the previous pointers, so we must re-create them.\n            let start = self.as_mut_ptr();\n            let ptr = start.add(index);\n\n            while num_added < lower_size_bound {\n                let element = match iter.next() {\n                    Some(x) => x,\n                    None => break,\n                };\n                let cur = ptr.add(num_added);\n                ptr::write(cur, element);\n                guard.skip.start += 1;\n                num_added += 1;\n            }\n\n            if num_added < lower_size_bound {\n                // Iterator provided fewer elements than the hint. Move the tail backward.\n                ptr::copy(\n                    ptr.add(lower_size_bound),\n                    ptr.add(num_added),\n                    old_len - index,\n                );\n            }\n            // There are no more duplicate or uninitialized slots, so the guard is not needed.\n            self.set_len(old_len + num_added);\n            mem::forget(guard);\n        }\n\n        // Insert any remaining elements one-by-one.\n        for element in iter {\n            self.insert(index + num_added, element);\n            num_added += 1;\n        }\n\n        struct DropOnPanic<T> {\n            start: *mut T,\n            skip: Range<usize>, // Space we copied-out-of, but haven't written-to yet.\n            len: usize,\n        }\n\n        impl<T> Drop for DropOnPanic<T> {\n            fn drop(&mut self) {\n                for i in 0..self.len {\n                    if !self.skip.contains(&i) {\n                        unsafe {\n                            ptr::drop_in_place(self.start.add(i));\n                        }\n                    }\n                }\n            }\n        }\n    }"
}