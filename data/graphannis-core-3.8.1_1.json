{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `graph::Graph::<CT>::apply_update_in_memory`",
    "file": "graphannis-core-3.8.1/src/graph/mod.rs",
    "start_line": 398,
    "start_col": 5,
    "end_line": 648,
    "end_col": 6,
    "code_snippet": "fn apply_update_in_memory<F>(\n        &mut self,\n        u: &mut GraphUpdate,\n        update_statistics: bool,\n        progress_callback: F,\n    ) -> Result<()>\n    where\n        F: Fn(&str),\n    {\n        let all_components = self.get_all_components(None, None);\n\n        let mut update_graph_index = ComponentType::init_update_graph_index(self)?;\n        // Cache the expensive mapping of node names to IDs\n        let cache_size = NonZeroUsize::new(1_000).ok_or(GraphAnnisCoreError::ZeroCacheSize)?;\n        let mut node_id_cache = CLruCache::new(cache_size);\n        // Iterate once over all changes in the same order as the updates have been added\n        let total_nr_updates = u.len()?;\n        progress_callback(&format!(\"applying {} atomic updates\", total_nr_updates));\n        for (nr_updates, update_event) in u.iter()?.enumerate() {\n            let (id, change) = update_event?;\n            trace!(\"applying event {:?}\", &change);\n            ComponentType::before_update_event(&change, self, &mut update_graph_index)?;\n            match &change {\n                UpdateEvent::AddNode {\n                    node_name,\n                    node_type,\n                } => {\n                    // only add node if it does not exist yet\n                    if !self.node_annos.has_node_name(node_name)? {\n                        let new_node_id: NodeID =\n                            if let Some(id) = self.node_annos.get_largest_item()? {\n                                id + 1\n                            } else {\n                                0\n                            };\n\n                        let new_anno_name = Annotation {\n                            key: NODE_NAME_KEY.as_ref().clone(),\n                            val: node_name.into(),\n                        };\n                        let new_anno_type = Annotation {\n                            key: NODE_TYPE_KEY.as_ref().clone(),\n                            val: node_type.into(),\n                        };\n\n                        // add the new node (with minimum labels)\n                        self.node_annos.insert(new_node_id, new_anno_name)?;\n                        self.node_annos.insert(new_node_id, new_anno_type)?;\n\n                        // update the internal cache\n                        node_id_cache.put(node_name.clone(), Some(new_node_id));\n                    }\n                }\n                UpdateEvent::DeleteNode { node_name } => {\n                    if let Some(existing_node_id) = self.get_cached_node_id_from_name(\n                        Cow::Borrowed(node_name),\n                        &mut node_id_cache,\n                    )? {\n                        // delete all annotations\n                        self.node_annos.remove_item(&existing_node_id)?;\n\n                        // delete all edges pointing to this node either as source or target\n                        for c in all_components.iter() {\n                            if let Ok(gs) = self.get_or_create_writable(c) {\n                                gs.delete_node(existing_node_id)?;\n                            }\n                        }\n\n                        // update the internal cache\n                        node_id_cache.put(node_name.clone(), None);\n                    }\n                }\n                UpdateEvent::AddNodeLabel {\n                    node_name,\n                    anno_ns,\n                    anno_name,\n                    anno_value,\n                } => {\n                    if let Some(existing_node_id) = self.get_cached_node_id_from_name(\n                        Cow::Borrowed(node_name),\n                        &mut node_id_cache,\n                    )? {\n                        let anno = Annotation {\n                            key: AnnoKey {\n                                ns: anno_ns.into(),\n                                name: anno_name.into(),\n                            },\n                            val: anno_value.into(),\n                        };\n                        self.node_annos.insert(existing_node_id, anno)?;\n                    }\n                }\n                UpdateEvent::DeleteNodeLabel {\n                    node_name,\n                    anno_ns,\n                    anno_name,\n                } => {\n                    if let Some(existing_node_id) = self.get_cached_node_id_from_name(\n                        Cow::Borrowed(node_name),\n                        &mut node_id_cache,\n                    )? {\n                        let key = AnnoKey {\n                            ns: anno_ns.into(),\n                            name: anno_name.into(),\n                        };\n                        self.node_annos\n                            .remove_annotation_for_item(&existing_node_id, &key)?;\n                    }\n                }\n                UpdateEvent::AddEdge {\n                    source_node,\n                    target_node,\n                    layer,\n                    component_type,\n                    component_name,\n                } => {\n                    let source = self.get_cached_node_id_from_name(\n                        Cow::Borrowed(source_node),\n                        &mut node_id_cache,\n                    )?;\n                    let target = self.get_cached_node_id_from_name(\n                        Cow::Borrowed(target_node),\n                        &mut node_id_cache,\n                    )?;\n                    // only add edge if both nodes already exist\n                    if let (Some(source), Some(target)) = (source, target) {\n                        if let Ok(ctype) = CT::from_str(component_type) {\n                            let c = Component::new(ctype, layer.into(), component_name.into());\n                            let gs = self.get_or_create_writable(&c)?;\n                            gs.add_edge(Edge { source, target })?;\n                        }\n                    }\n                }\n                UpdateEvent::DeleteEdge {\n                    source_node,\n                    target_node,\n                    layer,\n                    component_type,\n                    component_name,\n                } => {\n                    let source = self.get_cached_node_id_from_name(\n                        Cow::Borrowed(source_node),\n                        &mut node_id_cache,\n                    )?;\n                    let target = self.get_cached_node_id_from_name(\n                        Cow::Borrowed(target_node),\n                        &mut node_id_cache,\n                    )?;\n                    if let (Some(source), Some(target)) = (source, target) {\n                        if let Ok(ctype) = CT::from_str(component_type) {\n                            let c = Component::new(ctype, layer.into(), component_name.into());\n\n                            let gs = self.get_or_create_writable(&c)?;\n                            gs.delete_edge(&Edge { source, target })?;\n                        }\n                    }\n                }\n                UpdateEvent::AddEdgeLabel {\n                    source_node,\n                    target_node,\n                    layer,\n                    component_type,\n                    component_name,\n                    anno_ns,\n                    anno_name,\n                    anno_value,\n                } => {\n                    let source = self.get_cached_node_id_from_name(\n                        Cow::Borrowed(source_node),\n                        &mut node_id_cache,\n                    )?;\n                    let target = self.get_cached_node_id_from_name(\n                        Cow::Borrowed(target_node),\n                        &mut node_id_cache,\n                    )?;\n                    if let (Some(source), Some(target)) = (source, target) {\n                        if let Ok(ctype) = CT::from_str(component_type) {\n                            let c = Component::new(ctype, layer.into(), component_name.into());\n                            let gs = self.get_or_create_writable(&c)?;\n                            // only add label if the edge already exists\n                            let e = Edge { source, target };\n                            if gs.is_connected(source, target, 1, Included(1))? {\n                                let anno = Annotation {\n                                    key: AnnoKey {\n                                        ns: anno_ns.into(),\n                                        name: anno_name.into(),\n                                    },\n                                    val: anno_value.into(),\n                                };\n                                gs.add_edge_annotation(e, anno)?;\n                            }\n                        }\n                    }\n                }\n                UpdateEvent::DeleteEdgeLabel {\n                    source_node,\n                    target_node,\n                    layer,\n                    component_type,\n                    component_name,\n                    anno_ns,\n                    anno_name,\n                } => {\n                    let source = self.get_cached_node_id_from_name(\n                        Cow::Borrowed(source_node),\n                        &mut node_id_cache,\n                    )?;\n                    let target = self.get_cached_node_id_from_name(\n                        Cow::Borrowed(target_node),\n                        &mut node_id_cache,\n                    )?;\n                    if let (Some(source), Some(target)) = (source, target) {\n                        if let Ok(ctype) = CT::from_str(component_type) {\n                            let c = Component::new(ctype, layer.into(), component_name.into());\n                            let gs = self.get_or_create_writable(&c)?;\n                            // only add label if the edge already exists\n                            let e = Edge { source, target };\n                            if gs.is_connected(source, target, 1, Included(1))? {\n                                let key = AnnoKey {\n                                    ns: anno_ns.into(),\n                                    name: anno_name.into(),\n                                };\n                                gs.delete_edge_annotation(&e, &key)?;\n                            }\n                        }\n                    }\n                }\n            } // end match update entry type\n            ComponentType::after_update_event(change, self, &mut update_graph_index)?;\n            self.current_change_id = id;\n\n            if nr_updates > 0 && nr_updates % 100_000 == 0 {\n                // Get progress in percentage\n                let progress = ((nr_updates as f64) / (total_nr_updates as f64)) * 100.0;\n                progress_callback(&format!(\n                    \"applied {:.2}% of the atomic updates ({}/{})\",\n                    progress, nr_updates, total_nr_updates,\n                ));\n            }\n        } // end for each consistent update entry\n\n        if update_statistics {\n            progress_callback(\"calculating all statistics\");\n            self.calculate_all_statistics()?;\n        }\n\n        progress_callback(\"extending graph with model-specific index\");\n        ComponentType::apply_update_graph_index(update_graph_index, self)?;\n\n        Ok(())\n    }"
}