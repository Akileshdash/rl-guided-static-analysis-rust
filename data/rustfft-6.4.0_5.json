{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `avx::avx_bluesteins::BluesteinsAvx::<A, T>::perform_fft_immut`",
    "file": "rustfft-6.4.0/src/avx/avx_bluesteins.rs",
    "start_line": 314,
    "start_col": 5,
    "end_line": 367,
    "end_col": 6,
    "code_snippet": "fn perform_fft_immut(\n        &self,\n        input: &[Complex<T>],\n        output: &mut [Complex<T>],\n        scratch: &mut [Complex<T>],\n    ) {\n        let (inner_input, inner_scratch) = scratch\n            .split_at_mut(self.inner_fft_multiplier.len() * A::VectorType::COMPLEX_PER_VECTOR);\n\n        // do the necessary setup for bluestein's algorithm: copy the data to the inner buffers, apply some twiddle factors, zero out the rest of the inner buffer\n        unsafe {\n            // Specialization workaround: See the comments in FftPlannerAvx::new() for why these calls to array_utils::workaround_transmute are necessary\n            let transmuted_input: &[Complex<A>] = array_utils::workaround_transmute(input);\n            let transmuted_inner_input: &mut [Complex<A>] =\n                array_utils::workaround_transmute_mut(inner_input);\n\n            self.prepare_bluesteins(transmuted_input, transmuted_inner_input)\n        }\n\n        // run our inner forward FFT\n        self.common_data\n            .inner_fft\n            .process_with_scratch(inner_input, inner_scratch);\n\n        // Multiply our inner FFT output by our precomputed data. Then, conjugate the result to set up for an inverse FFT.\n        // We can conjugate the result of multiplication by conjugating both inputs. We pre-conjugated the multiplier array,\n        // so we just need to conjugate inner_input, which the pairwise_complex_multiply_conjugated function will handle\n        unsafe {\n            // Specialization workaround: See the comments in FftPlannerAvx::new() for why these calls to array_utils::workaround_transmute are necessary\n            let transmuted_inner_input: &mut [Complex<A>] =\n                array_utils::workaround_transmute_mut(inner_input);\n\n            Self::pairwise_complex_multiply_conjugated(\n                transmuted_inner_input,\n                &self.inner_fft_multiplier,\n            )\n        };\n\n        // inverse FFT. we're computing a forward but we're massaging it into an inverse by conjugating the inputs and outputs\n        self.common_data\n            .inner_fft\n            .process_with_scratch(inner_input, inner_scratch);\n\n        // finalize the result\n        unsafe {\n            // Specialization workaround: See the comments in FftPlannerAvx::new() for why these calls to array_utils::workaround_transmute are necessary\n            let transmuted_output: &mut [Complex<A>] =\n                array_utils::workaround_transmute_mut(output);\n            let transmuted_inner_input: &mut [Complex<A>] =\n                array_utils::workaround_transmute_mut(inner_input);\n\n            self.finalize_bluesteins(transmuted_inner_input, transmuted_output)\n        }\n    }"
}