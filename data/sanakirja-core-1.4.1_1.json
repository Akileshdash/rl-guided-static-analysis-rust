{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `btree::page_unsized::rebalance::rebalance_right`",
    "file": "sanakirja-core-1.4.1/src/btree/page_unsized/rebalance.rs",
    "start_line": 172,
    "start_col": 1,
    "end_line": 331,
    "end_col": 2,
    "code_snippet": "pub(crate) unsafe fn rebalance_right<\n    'a,\n    T: AllocPage,\n    K: ?Sized,\n    V: ?Sized,\n    P: BTreeMutPage<K, V, Cursor = super::PageCursor>,\n>(\n    txn: &mut T,\n    m: Concat<'a, K, V, P>,\n) -> Result<Op<'a, T, K, V>, T::Error> {\n    assert!(!m.mod_is_left);\n    // Take the last element of the left page.\n    let lc = P::cursor_last(&m.other);\n    let (k0, v0, r0) = P::current(txn, m.other.as_page(), &lc).unwrap();\n\n    let mut freed_ = [0, 0];\n\n    // Perform the modification on the modified page.\n    let new_right = if let Some((k, v)) = m.modified.ins {\n        let is_dirty = m.modified.page.is_dirty();\n        let new_right = if let Put::Ok(Ok { page, freed }) = P::put(\n            txn,\n            m.modified.page,\n            m.modified.mutable,\n            m.modified.skip_first,\n            &m.modified.c1,\n            k,\n            v,\n            m.modified.ins2,\n            m.modified.l,\n            m.modified.r,\n        )? {\n            if freed > 0 {\n                freed_[0] = if is_dirty { freed | 1 } else { freed };\n            }\n            page\n        } else {\n            unreachable!()\n        };\n        // Add the middle element of the concatenation as the first\n        // element of the right page. We know the right page is\n        // mutable, since we just modified it (hence the\n        // `assert_eq!(freed, 0)`.\n\n        // First element of the right page (after potential\n        // modification by `put` above).\n        let rc = P::cursor_first(&new_right.0);\n        let rl = P::left_child(new_right.0.as_page(), &rc);\n        if let Put::Ok(Ok { freed, page }) = P::put(\n            txn,\n            new_right.0,\n            true,\n            false,\n            &rc,\n            m.mid.0,\n            m.mid.1,\n            None,\n            r0,\n            rl,\n        )? {\n            debug_assert_eq!(freed, 0);\n            page\n        } else {\n            unreachable!()\n        }\n    } else if m.modified.skip_first {\n        let is_dirty = m.modified.page.is_dirty();\n        let (page, freed) = P::del(\n            txn,\n            m.modified.page,\n            m.modified.mutable,\n            &m.modified.c1,\n            m.modified.l,\n        )?;\n        if freed > 0 {\n            freed_[0] = if is_dirty { freed | 1 } else { freed };\n        }\n        // Add the middle element of the concatenation as the first\n        // element of the right page. We know the right page is\n        // mutable, since we just modified it. Moreover, if it is\n        // compacted by the `put` below, we know that the `del` didn't\n        // free anything, hence we can reuse the slot 0..\n\n        // First element of the right page (after potential\n        // modification by `del` above).\n        let rc = P::cursor_first(&page.0);\n        let rl = P::left_child(page.0.as_page(), &rc);\n        if let Put::Ok(Ok { freed, page }) = P::put(\n            txn, page.0, true, false, &rc, m.mid.0, m.mid.1, None, r0, rl,\n        )? {\n            if freed > 0 {\n                freed_[0] = if is_dirty { freed | 1 } else { freed };\n            }\n            page\n        } else {\n            unreachable!()\n        }\n    } else {\n        let is_dirty = m.modified.page.is_dirty();\n        let rc = P::cursor_first(&m.modified.page);\n        let rl = P::left_child(m.modified.page.as_page(), &rc);\n        if let Put::Ok(Ok { freed, page }) = P::put(\n            txn,\n            m.modified.page,\n            m.modified.mutable,\n            false,\n            &rc,\n            m.mid.0,\n            m.mid.1,\n            None,\n            r0,\n            rl,\n        )? {\n            // Update the left and right offsets. We know that at\n            // least one of them is 0, but it can be either one (or\n            // both), depending on what happened on the page below.\n            //\n            // Since we inserted an entry at the beginning of the\n            // page, we need to add 1 to the index given by\n            // `m.modified.c1.cur`.\n            if m.modified.l > 0 {\n                assert_eq!(m.modified.r, 0);\n                unsafe {\n                    let off = (page.0.data.add(HDR) as *mut u64).offset(m.modified.c1.cur);\n                    *off = (m.modified.l | (u64::from_le(*off) & 0xfff)).to_le();\n                }\n            } else if m.modified.r > 0 {\n                unsafe {\n                    let off = (page.0.data.add(HDR) as *mut u64).offset(m.modified.c1.cur + 1);\n                    *off = (m.modified.r | (u64::from_le(*off) & 0xfff)).to_le();\n                }\n            }\n            if freed > 0 {\n                freed_[0] = if is_dirty { freed | 1 } else { freed };\n            }\n            page\n        } else {\n            unreachable!()\n        }\n    };\n\n    // As explained in the general comment on this function, this\n    // entry isn't erased by the deletion in `m.other` below, so we\n    // can safely extend its lifetime.\n    let k = unsafe { core::mem::transmute(k0) };\n    let v = unsafe { core::mem::transmute(v0) };\n\n    let is_dirty = m.other.is_dirty();\n    let (new_left, freed) = P::del(txn, m.other, m.other_is_mutable, &lc, 0)?;\n    if freed > 0 {\n        freed_[1] = if is_dirty { freed | 1 } else { freed }\n    }\n    Ok(Op::Rebalanced {\n        l: new_left.0.offset,\n        r: new_right.0.offset,\n        k,\n        v,\n        freed: freed_,\n    })\n}"
}