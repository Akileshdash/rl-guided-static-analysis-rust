{
    "level": "Warning",
    "analyzer": "UnsafeDestructor",
    "op_type": null,
    "description": "unsafe block detected in drop",
    "file": "wgpu-core-26.0.1/src/device/queue.rs",
    "start_line": 155,
    "start_col": 1,
    "end_line": 155,
    "end_col": 20,
    "code_snippet": "impl Drop for Queue {\n    fn drop(&mut self) {\n        resource_log!(\"Drop {}\", self.error_ident());\n\n        let last_successful_submission_index = self\n            .device\n            .last_successful_submission_index\n            .load(Ordering::Acquire);\n\n        let fence = self.device.fence.read();\n\n        // Try waiting on the last submission using the following sequence of timeouts\n        let timeouts_in_ms = [100, 200, 400, 800, 1600, 3200];\n\n        for (i, timeout_ms) in timeouts_in_ms.into_iter().enumerate() {\n            let is_last_iter = i == timeouts_in_ms.len() - 1;\n\n            api_log!(\n                \"Waiting on last submission. try: {}/{}. timeout: {}ms\",\n                i + 1,\n                timeouts_in_ms.len(),\n                timeout_ms\n            );\n\n            let wait_res = unsafe {\n                self.device.raw().wait(\n                    fence.as_ref(),\n                    last_successful_submission_index,\n                    #[cfg(not(target_arch = \"wasm32\"))]\n                    timeout_ms,\n                    #[cfg(target_arch = \"wasm32\")]\n                    0, // WebKit and Chromium don't support a non-0 timeout\n                )\n            };\n            // Note: If we don't panic below we are in UB land (destroying resources while they are still in use by the GPU).\n            match wait_res {\n                Ok(true) => break,\n                Ok(false) => {\n                    // It's fine that we timed out on WebGL; GL objects can be deleted early as they\n                    // will be kept around by the driver if GPU work hasn't finished.\n                    // Moreover, the way we emulate read mappings on WebGL allows us to execute map_buffer earlier than on other\n                    // backends since getBufferSubData is synchronous with respect to the other previously enqueued GL commands.\n                    // Relying on this behavior breaks the clean abstraction wgpu-hal tries to maintain and\n                    // we should find ways to improve this. See https://github.com/gfx-rs/wgpu/issues/6538.\n                    #[cfg(target_arch = \"wasm32\")]\n                    {\n                        break;\n                    }\n                    #[cfg(not(target_arch = \"wasm32\"))]\n                    {\n                        if is_last_iter {\n                            panic!(\n                                \"We timed out while waiting on the last successful submission to complete!\"\n                            );\n                        }\n                    }\n                }\n                Err(e) => match e {\n                    hal::DeviceError::OutOfMemory => {\n                        if is_last_iter {\n                            panic!(\n                                \"We ran into an OOM error while waiting on the last successful submission to complete!\"\n                            );\n                        }\n                    }\n                    hal::DeviceError::Lost => {\n                        self.device.handle_hal_error(e); // will lose the device\n                        break;\n                    }\n                    hal::DeviceError::Unexpected => {\n                        panic!(\n                            \"We ran into an unexpected error while waiting on the last successful submission to complete!\"\n                        );\n                    }\n                },\n            }\n        }\n        drop(fence);\n\n        let snatch_guard = self.device.snatchable_lock.read();\n        let (submission_closures, mapping_closures, blas_compact_ready_closures, queue_empty) =\n            self.maintain(last_successful_submission_index, &snatch_guard);\n        drop(snatch_guard);\n\n        assert!(queue_empty);\n\n        let closures = crate::device::UserClosures {\n            mappings: mapping_closures,\n            blas_compact_ready: blas_compact_ready_closures,\n            submissions: submission_closures,\n            device_lost_invocations: SmallVec::new(),\n        };\n\n        closures.fire();\n    }\n}"
}