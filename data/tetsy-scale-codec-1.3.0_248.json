{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<[T] as codec::Encode>::encode_to`",
    "file": "tetsy-scale-codec-1.3.0/src/codec.rs",
    "start_line": 691,
    "start_col": 2,
    "end_line": 720,
    "end_col": 3,
    "code_snippet": "fn encode_to<W: Output>(&self, dest: &mut W) {\n\t\tcompact_encode_len_to(dest, self.len()).expect(\"Compact encodes length\");\n\n\t\tmacro_rules! encode_to {\n\t\t\t( u8, $self:ident, $dest:ident ) => {{\n\t\t\t\tlet typed = unsafe { mem::transmute::<&[T], &[u8]>($self) };\n\t\t\t\t$dest.write(&typed)\n\t\t\t}};\n\t\t\t( i8, $self:ident, $dest:ident ) => {{\n\t\t\t\t// `i8` has the same size as `u8`. We can just convert it here and write to the\n\t\t\t\t// dest buffer directly.\n\t\t\t\tlet typed = unsafe { mem::transmute::<&[T], &[u8]>($self) };\n\t\t\t\t$dest.write(&typed)\n\t\t\t}};\n\t\t\t( $ty:ty, $self:ident, $dest:ident ) => {{\n\t\t\t\tlet typed = unsafe { mem::transmute::<&[T], &[$ty]>($self) };\n\t\t\t\t$dest.write(<[$ty] as AsByteSlice<$ty>>::as_byte_slice(typed))\n\t\t\t}};\n\t\t}\n\n\t\twith_type_info! {\n\t\t\t<T as Encode>::TYPE_INFO,\n\t\t\tencode_to(self, dest),\n\t\t\t{\n\t\t\t\tfor item in self {\n\t\t\t\t\titem.encode_to(dest);\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t}"
}