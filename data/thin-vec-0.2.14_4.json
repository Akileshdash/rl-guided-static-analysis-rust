{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<Splice<'_, I> as std::ops::Drop>::drop`",
    "file": "thin-vec-0.2.14/src/lib.rs",
    "start_line": 2558,
    "start_col": 5,
    "end_line": 2600,
    "end_col": 6,
    "code_snippet": "fn drop(&mut self) {\n        // Ensure we've fully drained out the range\n        self.drain.by_ref().for_each(drop);\n\n        unsafe {\n            // If there's no tail elements, then the inner ThinVec is already\n            // correct and we can just extend it like normal.\n            if self.drain.tail == 0 {\n                (*self.drain.vec).extend(self.replace_with.by_ref());\n                return;\n            }\n\n            // First fill the range left by drain().\n            if !self.drain.fill(&mut self.replace_with) {\n                return;\n            }\n\n            // There may be more elements. Use the lower bound as an estimate.\n            let (lower_bound, _upper_bound) = self.replace_with.size_hint();\n            if lower_bound > 0 {\n                self.drain.move_tail(lower_bound);\n                if !self.drain.fill(&mut self.replace_with) {\n                    return;\n                }\n            }\n\n            // Collect any remaining elements.\n            // This is a zero-length vector which does not allocate if `lower_bound` was exact.\n            let mut collected = self\n                .replace_with\n                .by_ref()\n                .collect::<Vec<I::Item>>()\n                .into_iter();\n            // Now we have an exact count.\n            if collected.len() > 0 {\n                self.drain.move_tail(collected.len());\n                let filled = self.drain.fill(&mut collected);\n                debug_assert!(filled);\n                debug_assert_eq!(collected.len(), 0);\n            }\n        }\n        // Let `Drain::drop` move the tail back if necessary and restore `vec.len`.\n    }"
}