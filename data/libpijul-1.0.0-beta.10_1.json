{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `output::output::move_or_create`",
    "file": "libpijul-1.0.0-beta.10/src/output/output.rs",
    "start_line": 620,
    "start_col": 1,
    "end_line": 749,
    "end_col": 2,
    "code_snippet": "fn move_or_create<T: GraphTxnT + TreeMutTxnT, R: WorkingCopy, C: ChangeStore>(\n    txn: ArcTxn<T>,\n    repo: &R,\n    output_item: &OutputItem,\n    output_item_inode: Option<(Inode, Position<ChangeId>)>,\n    path: &str,\n    tmp: &mut Option<String>,\n    file_name: &str,\n    actual_moves: &mut Vec<(String, String)>,\n    move_map: &mut HashMap<Inode, String>,\n    salt: u64,\n) -> Result<Inode, OutputError<C::Error, T, R::Error>> {\n    let file_id = OwnedPathId {\n        parent_inode: output_item.parent,\n        basename: SmallString::from_str(&file_name),\n    };\n    debug!(\"move_or_create {:?}\", file_id);\n\n    if let Some((inode, _)) = output_item_inode {\n        // If the file already exists, find its\n        // current name and rename it if that name\n        // is different.\n        let txn_ = txn.read();\n        if let Some(ref current_name) = inode_filename(&*txn_, inode, move_map)? {\n            let actual_path = if let Some(tmp) = tmp.take() {\n                Cow::Owned(tmp)\n            } else {\n                Cow::Borrowed(path)\n            };\n            debug!(\n                \"current_name = {:?}, path = {:?}, actual_path = {:?}\",\n                current_name, path, actual_path\n            );\n            if current_name.as_str() != &actual_path {\n                std::mem::drop(txn_);\n                let mut txn_ = txn.write();\n                let parent = txn_.get_revtree(&inode, None)?.unwrap().to_owned();\n                debug!(\"parent = {:?}, inode = {:?}\", parent, inode);\n                del_tree_with_rev(&mut *txn_, &parent, &inode)?;\n\n                let s = {\n                    let mut c = [0u8; 16];\n                    unsafe { *(c.as_mut_ptr() as *mut Position<ChangeId>) = output_item.pos }\n                    BASE32.encode(blake3::hash(&c).as_bytes())\n                };\n\n                if let Some(ref mut tmp) = tmp {\n                    // The parent was already moved\n                    debug!(\"tmp {:?}\", tmp);\n                    crate::path::pop(tmp);\n                    crate::path::push(tmp, &s);\n                }\n\n                let mut tmp_ = actual_path.to_string();\n                crate::path::pop(&mut tmp_);\n                crate::path::push(&mut tmp_, &s);\n\n                debug!(\"rename {:?} {:?}\", current_name, tmp_);\n                repo.rename(&current_name, &tmp_)\n                    .map_err(OutputError::WorkingCopy)?;\n\n                move_map.insert(inode, tmp_.to_string());\n                actual_moves.push((tmp_.to_string(), actual_path.to_string()));\n\n                *tmp = Some(tmp_);\n\n                // If the new location is overwriting an existing one,\n                // actually overwrite.\n                if let Some(&inode) = txn_.get_tree(&file_id, None)? {\n                    crate::fs::rec_delete(&mut *txn_, &file_id, inode, true)\n                        .map_err(PristineOutputError::Fs)?;\n                }\n                put_inodes_with_rev(&mut *txn_, &inode, &output_item.pos)?;\n                put_tree_with_rev(&mut *txn_, &file_id, &inode)?;\n                // The directory marker is necessarily already there,\n                // since the path is in the tree.\n                if output_item.meta.is_dir() {\n                    let path_id = OwnedPathId {\n                        parent_inode: inode,\n                        basename: SmallString::new(),\n                    };\n                    assert_eq!(txn_.get_tree(&path_id, None).unwrap(), Some(&inode))\n                }\n            } else {\n                if let Cow::Owned(tmp_) = actual_path {\n                    *tmp = Some(tmp_)\n                }\n            }\n        } else {\n            debug!(\"no current name, inserting {:?} {:?}\", file_id, inode);\n            std::mem::drop(txn_);\n            let mut txn_ = txn.write();\n            if let Some(&inode) = txn_.get_tree(&file_id, None)? {\n                crate::fs::rec_delete(&mut *txn_, &file_id, inode, true)\n                    .map_err(PristineOutputError::Fs)?;\n            }\n            put_inodes_with_rev(&mut *txn_, &inode, &output_item.pos)?;\n            put_tree_with_rev(&mut *txn_, &file_id, &inode)?;\n            if output_item.meta.is_dir() {\n                let path_id = OwnedPathId {\n                    parent_inode: inode,\n                    basename: SmallString::new(),\n                };\n                txn_.put_tree(&path_id, &inode)?;\n            }\n        }\n        Ok(inode)\n    } else {\n        let mut txn_ = txn.write();\n        if let Some(&inode) = txn_.get_tree(&file_id, None)? {\n            crate::fs::rec_delete(&mut *txn_, &file_id, inode, true)\n                .map_err(PristineOutputError::Fs)?;\n        }\n        let inode = create_new_inode(&mut *txn_, &file_id, salt)?;\n        debug!(\n            \"created new inode {:?} {:?} {:?}\",\n            inode, output_item.pos, file_id\n        );\n        put_inodes_with_rev(&mut *txn_, &inode, &output_item.pos)?;\n        put_tree_with_rev(&mut *txn_, &file_id, &inode)?;\n        if output_item.meta.is_dir() {\n            let path_id = OwnedPathId {\n                parent_inode: inode,\n                basename: SmallString::new(),\n            };\n            txn_.put_tree(&path_id, &inode)?;\n        }\n        Ok(inode)\n    }\n}"
}