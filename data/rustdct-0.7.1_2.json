{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<algorithm::type2and3_splitradix::Type2And3SplitRadix<T> as Dct2<T>>::process_dct2_with_scratch`",
    "file": "rustdct-0.7.1/src/algorithm/type2and3_splitradix.rs",
    "start_line": 68,
    "start_col": 5,
    "end_line": 136,
    "end_col": 6,
    "code_snippet": "fn process_dct2_with_scratch(&self, buffer: &mut [T], scratch: &mut [T]) {\n        let scratch = validate_buffers!(buffer, scratch, self.len(), self.get_scratch_len());\n\n        let len = self.len();\n        let half_len = len / 2;\n        let quarter_len = len / 4;\n\n        //preprocess the data by splitting it up into vectors of size n/2, n/4, and n/4\n        let (input_dct2, input_dct4) = scratch.split_at_mut(half_len);\n        let (input_dct4_even, input_dct4_odd) = input_dct4.split_at_mut(quarter_len);\n\n        for i in 0..quarter_len {\n            \n                let input_bottom = unsafe { *buffer.get_unchecked(i) };\n                let input_top = unsafe { *buffer.get_unchecked(len - i - 1) };\n\n                let input_half_bottom = unsafe { *buffer.get_unchecked(half_len - i - 1) };\n                let input_half_top = unsafe { *buffer.get_unchecked(half_len + i) };\n\n                //prepare the inner DCT2\n                unsafe {*input_dct2.get_unchecked_mut(i)  = input_top + input_bottom };\n                unsafe {*input_dct2.get_unchecked_mut(half_len - i - 1)  =\n                    input_half_bottom + input_half_top };\n\n                //prepare the inner DCT4 - which consists of two DCT2s of half size\n                let lower_dct4 = input_bottom - input_top;\n                let upper_dct4 = input_half_bottom - input_half_top;\n                let twiddle = unsafe { self.twiddles.get_unchecked(i) };\n\n                let cos_input = lower_dct4 * twiddle.re + upper_dct4 * twiddle.im;\n                let sin_input = upper_dct4 * twiddle.re - lower_dct4 * twiddle.im;\n\n                unsafe {*input_dct4_even.get_unchecked_mut(i) = cos_input };\n                unsafe {*input_dct4_odd.get_unchecked_mut(quarter_len - i - 1) =\n                    if i % 2 == 0 { sin_input } else { -sin_input } };\n            \n        }\n\n        // compute the recursive DCT2s, using the original buffer as scratch space\n        self.half_dct.process_dct2_with_scratch(input_dct2, buffer);\n        self.quarter_dct\n            .process_dct2_with_scratch(input_dct4_even, buffer);\n        self.quarter_dct\n            .process_dct2_with_scratch(input_dct4_odd, buffer);\n\n        unsafe {\n            //post process the 3 DCT2 outputs. the first few and the last will be done outside of the loop\n            *buffer.get_unchecked_mut(0) = *input_dct2.get_unchecked(0);\n            *buffer.get_unchecked_mut(1) = *input_dct4_even.get_unchecked(0);\n            *buffer.get_unchecked_mut(2) = *input_dct2.get_unchecked(1);\n\n            for i in 1..quarter_len {\n                let dct4_cos_output = *input_dct4_even.get_unchecked(i);\n                let dct4_sin_output = if (i + quarter_len) % 2 == 0 {\n                    -*input_dct4_odd.get_unchecked(quarter_len - i)\n                } else {\n                    *input_dct4_odd.get_unchecked(quarter_len - i)\n                };\n\n                *buffer.get_unchecked_mut(i * 4 - 1) = dct4_cos_output + dct4_sin_output;\n                *buffer.get_unchecked_mut(i * 4) = *input_dct2.get_unchecked(i * 2);\n\n                *buffer.get_unchecked_mut(i * 4 + 1) = dct4_cos_output - dct4_sin_output;\n                *buffer.get_unchecked_mut(i * 4 + 2) = *input_dct2.get_unchecked(i * 2 + 1);\n            }\n\n            *buffer.get_unchecked_mut(len - 1) = -*input_dct4_odd.get_unchecked(0);\n        }\n    }"
}