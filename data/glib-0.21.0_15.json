{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `functions::spawn_async_with_pipes`",
    "file": "glib-0.21.0/src/functions.rs",
    "start_line": 138,
    "start_col": 1,
    "end_line": 210,
    "end_col": 2,
    "code_snippet": "pub fn spawn_async_with_pipes<\n    P: AsRef<std::path::Path>,\n    T: FromRawFd,\n    U: FromRawFd,\n    V: FromRawFd,\n>(\n    working_directory: P,\n    argv: &[&std::path::Path],\n    envp: &[&std::path::Path],\n    flags: SpawnFlags,\n    child_setup: Option<Box_<dyn FnOnce() + 'static>>,\n) -> Result<(Pid, T, U, V), Error> {\n    let child_setup_data: Box_<Option<Box_<dyn FnOnce() + 'static>>> = Box_::new(child_setup);\n    unsafe extern \"C\" fn child_setup_func(user_data: ffi::gpointer) {\n        let callback: Box_<Option<Box_<dyn FnOnce() + 'static>>> =\n            Box_::from_raw(user_data as *mut _);\n        let callback = (*callback).expect(\"cannot get closure...\");\n        callback()\n    }\n    let child_setup = if child_setup_data.is_some() {\n        Some(child_setup_func as _)\n    } else {\n        None\n    };\n    let super_callback0: Box_<Option<Box_<dyn FnOnce() + 'static>>> = child_setup_data;\n    unsafe {\n        let mut child_pid = mem::MaybeUninit::uninit();\n        let mut standard_input = mem::MaybeUninit::uninit();\n        let mut standard_output = mem::MaybeUninit::uninit();\n        let mut standard_error = mem::MaybeUninit::uninit();\n        let mut error = ptr::null_mut();\n        let _ = ffi::g_spawn_async_with_pipes(\n            working_directory.as_ref().to_glib_none().0,\n            argv.to_glib_none().0,\n            envp.to_glib_none().0,\n            flags.into_glib(),\n            child_setup,\n            Box_::into_raw(super_callback0) as *mut _,\n            child_pid.as_mut_ptr(),\n            standard_input.as_mut_ptr(),\n            standard_output.as_mut_ptr(),\n            standard_error.as_mut_ptr(),\n            &mut error,\n        );\n        let child_pid = from_glib(child_pid.assume_init());\n        let standard_input = standard_input.assume_init();\n        let standard_output = standard_output.assume_init();\n        let standard_error = standard_error.assume_init();\n        if error.is_null() {\n            #[cfg(not(windows))]\n            {\n                Ok((\n                    child_pid,\n                    FromRawFd::from_raw_fd(standard_input),\n                    FromRawFd::from_raw_fd(standard_output),\n                    FromRawFd::from_raw_fd(standard_error),\n                ))\n            }\n        // #[cfg(windows)]\n        // {\n        //     use std::os::windows::io::{FromRawHandle, RawHandle};\n        //     Ok((\n        //         child_pid,\n        //         File::from_raw_handle(standard_input as usize as RawHandle),\n        //         File::from_raw_handle(standard_output as usize as RawHandle),\n        //         File::from_raw_handle(standard_error as usize as RawHandle),\n        //     ))\n        // }\n        } else {\n            Err(from_glib_full(error))\n        }\n    }\n}"
}