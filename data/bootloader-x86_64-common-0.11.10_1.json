{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "SliceFromRaw",
    "description": "Potential unsafe dataflow issue in `load_kernel::Inner::<'a, M, F>::copy_from`",
    "file": "bootloader-x86_64-common-0.11.10/src/load_kernel.rs",
    "start_line": 317,
    "start_col": 5,
    "end_line": 374,
    "end_col": 6,
    "code_snippet": "fn copy_from(&self, addr: VirtAddr, buf: &mut [u8]) {\n        // We can't know for sure that contiguous virtual address are contiguous\n        // in physical memory, so we iterate of the pages spanning the\n        // addresses, translate them to frames and copy the data.\n\n        let end_inclusive_addr = Step::forward_checked(addr, buf.len() - 1)\n            .expect(\"end address outside of the virtual address space\");\n        let start_page = Page::<Size4KiB>::containing_address(addr);\n        let end_inclusive_page = Page::<Size4KiB>::containing_address(end_inclusive_addr);\n\n        for page in start_page..=end_inclusive_page {\n            // Translate the virtual page to the physical frame.\n            let phys_addr = self\n                .page_table\n                .translate_page(page)\n                .expect(\"address is not mapped to the kernel's memory space\");\n\n            // Figure out which address range we want to copy from the frame.\n\n            // This page covers these addresses.\n            let page_start = page.start_address();\n            let page_end_inclusive = page.start_address() + 4095u64;\n\n            // We want to copy from the following address in this frame.\n            let start_copy_address = cmp::max(addr, page_start);\n            let end_inclusive_copy_address = cmp::min(end_inclusive_addr, page_end_inclusive);\n\n            // These are the offsets into the frame we want to copy from.\n            let start_offset_in_frame = start_copy_address - page_start;\n            let end_inclusive_offset_in_frame = end_inclusive_copy_address - page_start;\n\n            // Calculate how many bytes we want to copy from this frame.\n            let copy_len = end_inclusive_offset_in_frame - start_offset_in_frame + 1;\n\n            // Calculate the physical addresses.\n            let start_phys_addr = phys_addr.start_address() + start_offset_in_frame;\n\n            // These are the offsets from the start address. These correspond\n            // to the destination indices in `buf`.\n            let start_offset_in_buf = Step::steps_between(&addr, &start_copy_address).1.unwrap();\n\n            // Calculate the source slice.\n            // Utilize that frames are identity mapped.\n            let src_ptr = start_phys_addr.as_u64() as *const u8;\n            let src = unsafe {\n                // SAFETY: We know that this memory is valid because we got it\n                // as a result from a translation. There are not other\n                // references to it.\n                &*core::ptr::slice_from_raw_parts(src_ptr, copy_len as usize)\n            };\n\n            // Calculate the destination pointer.\n            let dest = &mut buf[start_offset_in_buf..][..copy_len as usize];\n\n            // Do the actual copy.\n            dest.copy_from_slice(src);\n        }\n    }"
}