{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `packet::signature::config::SignatureConfig::sign_primary_key_binding`",
    "file": "pgp-0.16.0/src/packet/signature/config.rs",
    "start_line": 364,
    "start_col": 5,
    "end_line": 405,
    "end_col": 6,
    "code_snippet": "pub fn sign_primary_key_binding<K, P, L>(\n        self,\n        signer: &K,\n        signer_pub: &P,\n        signer_pw: &Password,\n        signee: &L,\n    ) -> Result<Signature>\n    where\n        K: SecretKeyTrait,\n        P: PublicKeyTrait + Serialize,\n        L: PublicKeyTrait + Serialize,\n    {\n        ensure!(\n            (self.version() == SignatureVersion::V4 && signer.version() == KeyVersion::V4)\n                || (self.version() == SignatureVersion::V6 && signer.version() == KeyVersion::V6),\n            \"signature version {:?} not allowed for signer key version {:?}\",\n            self.version(),\n            signer.version()\n        );\n        debug!(\n            \"signing primary key binding: {:#?} - {:#?} - {:#?}\",\n            self, signer, signee\n        );\n\n        let mut hasher = self.hash_alg.new_hasher()?;\n\n        if let SignatureVersionSpecific::V6 { salt } = &self.version_specific {\n            hasher.update(salt.as_ref())\n        }\n\n        serialize_for_hashing(signee, &mut hasher)?; // primary\n        serialize_for_hashing(signer_pub, &mut hasher)?; // subkey\n\n        let len = self.hash_signature_data(&mut hasher)?;\n        hasher.update(&self.trailer(len)?);\n\n        let hash = &hasher.finalize()[..];\n        let signed_hash_value = [hash[0], hash[1]];\n        let signature = signer.create_signature(signer_pw, self.hash_alg, hash)?;\n\n        Signature::from_config(self, signed_hash_value, signature)\n    }"
}