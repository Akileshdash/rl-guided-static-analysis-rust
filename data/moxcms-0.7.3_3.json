{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `conversions::avx::t_lut3_to_3::TransformLut3x3AvxFma::<T, U, SRC_LAYOUT, DST_LAYOUT, GRID_SIZE, BIT_DEPTH, BINS, BARYCENTRIC_BINS>::transform_chunk`",
    "file": "moxcms-0.7.3/src/conversions/avx/t_lut3_to_3.rs",
    "start_line": 80,
    "start_col": 5,
    "end_line": 142,
    "end_col": 6,
    "code_snippet": "unsafe fn transform_chunk<'b, Interpolator: AvxMdInterpolation<'b, GRID_SIZE>>(\n        &'b self,\n        src: &[T],\n        dst: &mut [T],\n    ) {\n        let src_cn = Layout::from(SRC_LAYOUT);\n        let src_channels = src_cn.channels();\n\n        let dst_cn = Layout::from(DST_LAYOUT);\n        let dst_channels = dst_cn.channels();\n\n        let value_scale = unsafe { _mm_set1_ps(((1 << BIT_DEPTH) - 1) as f32) };\n        let max_value = ((1u32 << BIT_DEPTH) - 1).as_();\n\n        for (src, dst) in src\n            .chunks_exact(src_channels)\n            .zip(dst.chunks_exact_mut(dst_channels))\n        {\n            let x = <() as LutBarycentricReduction<T, U>>::reduce::<BIT_DEPTH, BARYCENTRIC_BINS>(\n                src[src_cn.r_i()],\n            );\n            let y = <() as LutBarycentricReduction<T, U>>::reduce::<BIT_DEPTH, BARYCENTRIC_BINS>(\n                src[src_cn.g_i()],\n            );\n            let z = <() as LutBarycentricReduction<T, U>>::reduce::<BIT_DEPTH, BARYCENTRIC_BINS>(\n                src[src_cn.b_i()],\n            );\n\n            let a = if src_channels == 4 {\n                src[src_cn.a_i()]\n            } else {\n                max_value\n            };\n\n            let tetrahedral = Interpolator::new(&self.lut);\n            let v = tetrahedral.inter3_sse(x, y, z, &self.weights);\n            if T::FINITE {\n                unsafe {\n                    let mut r = _mm_mul_ps(v.v, value_scale);\n                    r = _mm_max_ps(r, _mm_setzero_ps());\n                    r = _mm_min_ps(r, value_scale);\n                    let jvz = _mm_cvtps_epi32(r);\n\n                    let x = _mm_extract_epi32::<0>(jvz);\n                    let y = _mm_extract_epi32::<1>(jvz);\n                    let z = _mm_extract_epi32::<2>(jvz);\n\n                    dst[dst_cn.r_i()] = (x as u32).as_();\n                    dst[dst_cn.g_i()] = (y as u32).as_();\n                    dst[dst_cn.b_i()] = (z as u32).as_();\n                }\n            } else {\n                unsafe {\n                    dst[dst_cn.r_i()] = f32::from_bits(_mm_extract_ps::<0>(v.v) as u32).as_();\n                    dst[dst_cn.g_i()] = f32::from_bits(_mm_extract_ps::<1>(v.v) as u32).as_();\n                    dst[dst_cn.b_i()] = f32::from_bits(_mm_extract_ps::<2>(v.v) as u32).as_();\n                }\n            }\n            if dst_channels == 4 {\n                dst[dst_cn.a_i()] = a;\n            }\n        }\n    }"
}