{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `map::bucket_array_ref::BucketArrayRef::<'a, K, V, S>::insert_with_or_modify_entry_and`",
    "file": "cht-0.5.0/src/map/bucket_array_ref.rs",
    "start_line": 181,
    "start_col": 5,
    "end_line": 239,
    "end_col": 6,
    "code_snippet": "pub(crate) fn insert_with_or_modify_entry_and<\n        F: FnOnce() -> V,\n        G: FnMut(&K, &V) -> V,\n        H: FnOnce(&K, &V) -> T,\n        T,\n    >(\n        &self,\n        key: K,\n        hash: u64,\n        on_insert: F,\n        mut on_modify: G,\n        with_old_entry: H,\n    ) -> Option<T> {\n        let guard = &crossbeam_epoch::pin();\n        let current_ref = self.get(guard);\n        let mut bucket_array_ref = current_ref;\n        let mut state = InsertOrModifyState::New(key, on_insert);\n\n        let result;\n\n        loop {\n            while self.len.load(Ordering::Relaxed) > bucket_array_ref.capacity() {\n                bucket_array_ref = bucket_array_ref.rehash(guard, self.build_hasher);\n            }\n\n            match bucket_array_ref.insert_or_modify(guard, hash, state, on_modify) {\n                Ok(previous_bucket_ptr) => {\n                    if let Some(previous_bucket_ref) = unsafe { previous_bucket_ptr.as_ref() } {\n                        if previous_bucket_ptr.tag() & bucket::TOMBSTONE_TAG != 0 {\n                            self.len.fetch_add(1, Ordering::Relaxed);\n                            result = None;\n                        } else {\n                            let Bucket {\n                                key,\n                                maybe_value: value,\n                            } = previous_bucket_ref;\n                            result = Some(with_old_entry(key, unsafe { &*value.as_ptr() }));\n                        }\n\n                        unsafe { bucket::defer_destroy_bucket(guard, previous_bucket_ptr) };\n                    } else {\n                        self.len.fetch_add(1, Ordering::Relaxed);\n                        result = None;\n                    }\n\n                    break;\n                }\n                Err((s, f)) => {\n                    state = s;\n                    on_modify = f;\n                    bucket_array_ref = bucket_array_ref.rehash(guard, self.build_hasher);\n                }\n            }\n        }\n\n        self.swing(guard, current_ref, bucket_array_ref);\n\n        result\n    }"
}