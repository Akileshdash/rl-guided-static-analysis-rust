{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `items::WindowItemVTable::init`",
    "file": "i-slint-core-1.12.1/items.rs",
    "start_line": 122,
    "start_col": 26,
    "end_line": 122,
    "end_col": 28,
    "code_snippet": "pub init: extern \"C\" fn(core::pin::Pin<VRef<ItemVTable>>, my_item: &ItemRc),\n\n    /// offset in bytes from the *const ItemImpl.\n    /// isize::MAX  means None\n    #[allow(non_upper_case_globals)]\n    #[field_offset(CachedRenderingData)]\n    pub cached_rendering_data_offset: usize,\n\n    /// We would need max/min/preferred size, and all layout info\n    pub layout_info: extern \"C\" fn(\n        core::pin::Pin<VRef<ItemVTable>>,\n        orientation: Orientation,\n        window_adapter: &WindowAdapterRc,\n        self_rc: &ItemRc,\n    ) -> LayoutInfo,\n\n    /// Event handler for mouse and touch event. This function is called before being called on children.\n    /// Then, depending on the return value, it is called for the children, and their children, then\n    /// [`Self::input_event`] is called on the children, and finally [`Self::input_event`] is called\n    /// on this item again.\n    pub input_event_filter_before_children: extern \"C\" fn(\n        core::pin::Pin<VRef<ItemVTable>>,\n        MouseEvent,\n        window_adapter: &WindowAdapterRc,\n        self_rc: &ItemRc,\n    ) -> InputEventFilterResult,\n\n    /// Handle input event for mouse and touch event\n    pub input_event: extern \"C\" fn(\n        core::pin::Pin<VRef<ItemVTable>>,\n        MouseEvent,\n        window_adapter: &WindowAdapterRc,\n        self_rc: &ItemRc,\n    ) -> InputEventResult,\n\n    pub focus_event: extern \"C\" fn(\n        core::pin::Pin<VRef<ItemVTable>>,\n        &FocusEvent,\n        window_adapter: &WindowAdapterRc,\n        self_rc: &ItemRc,\n    ) -> FocusEventResult,\n\n    pub key_event: extern \"C\" fn(\n        core::pin::Pin<VRef<ItemVTable>>,\n        &KeyEvent,\n        window_adapter: &WindowAdapterRc,\n        self_rc: &ItemRc,\n    ) -> KeyEventResult,\n\n    pub render: extern \"C\" fn(\n        core::pin::Pin<VRef<ItemVTable>>,\n        backend: &mut ItemRendererRef,\n        self_rc: &ItemRc,\n        size: LogicalSize,\n    ) -> RenderingResult,\n\n    pub bounding_rect: extern \"C\" fn(\n        core::pin::Pin<VRef<ItemVTable>>,\n        window_adapter: &WindowAdapterRc,\n        self_rc: &ItemRc,\n        geometry: LogicalRect,\n    ) -> LogicalRect,\n\n    pub clips_children: extern \"C\" fn(core::pin::Pin<VRef<ItemVTable>>) -> bool,\n}\n\n/// Alias for `vtable::VRef<ItemVTable>` which represent a pointer to a `dyn Item` with\n/// the associated vtable\npub type ItemRef<'a> = vtable::VRef<'a, ItemVTable>;\n\n#[repr(C)]\n#[derive(FieldOffsets, Default, SlintElement)]\n#[pin]\n/// The implementation of an empty items that does nothing\npub struct Empty {\n    pub cached_rendering_data: CachedRenderingData,\n}"
}