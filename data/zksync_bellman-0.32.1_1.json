{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `plonk::better_better_cs::proof::<impl plonk::better_better_cs::cs::Assembly<E, P, MG, S>>::create_proof_by_ref`",
    "file": "zksync_bellman-0.32.1/src/plonk/better_better_cs/proof/mod.rs",
    "start_line": 339,
    "start_col": 5,
    "end_line": 2028,
    "end_col": 6,
    "code_snippet": "pub fn create_proof_by_ref<C: Circuit<E>, T: Transcript<E::Fr>>(\n        &self,\n        worker: &Worker,\n        setup: &Setup<E, C>,\n        mon_crs: &Crs<E, CrsForMonomialForm>,\n        transcript_params: Option<T::InitializationParameters>,\n    ) -> Result<Proof<E, C>, SynthesisError> {\n        assert!(S::PRODUCE_WITNESS);\n        assert!(self.is_finalized);\n\n        let mut transcript = if let Some(params) = transcript_params { T::new_from_params(params) } else { T::new() };\n\n        let mut proof = Proof::<E, C>::empty();\n\n        let input_values = self.input_assingments.clone();\n\n        proof.n = self.n();\n        proof.inputs = input_values.clone();\n\n        for inp in input_values.iter() {\n            transcript.commit_field_element(inp);\n        }\n\n        let num_state_polys = <Self as ConstraintSystem<E>>::Params::STATE_WIDTH;\n        let num_witness_polys = <Self as ConstraintSystem<E>>::Params::WITNESS_WIDTH;\n\n        let mut values_storage = self.make_assembled_poly_storage(worker, true)?;\n\n        let required_domain_size = self.n() + 1;\n        assert!(required_domain_size.is_power_of_two());\n\n        let omegas_bitreversed = BitReversedOmegas::<E::Fr>::new_for_domain_size(required_domain_size);\n        let omegas_inv_bitreversed = <OmegasInvBitreversed<E::Fr> as CTPrecomputations<E::Fr>>::new_for_domain_size(required_domain_size);\n\n        // if we simultaneously produce setup then grab permutation polys in values forms\n        if S::PRODUCE_SETUP {\n            let permutation_polys = self.make_permutations(&worker)?;\n            assert_eq!(permutation_polys.len(), num_state_polys);\n\n            for (idx, poly) in permutation_polys.into_iter().enumerate() {\n                let key = PolyIdentifier::PermutationPolynomial(idx);\n                let poly = PolynomialProxy::from_owned(poly);\n                values_storage.setup_map.insert(key, poly);\n            }\n        } else {\n            // compute from setup\n            for idx in 0..num_state_polys {\n                let key = PolyIdentifier::PermutationPolynomial(idx);\n                // let vals = setup.permutation_monomials[idx].clone().fft(&worker).into_coeffs();\n                let vals = setup.permutation_monomials[idx]\n                    .clone()\n                    .fft_using_bitreversed_ntt(&worker, &omegas_bitreversed, &E::Fr::one())?\n                    .into_coeffs();\n                let poly = Polynomial::from_values_unpadded(vals)?;\n                let poly = PolynomialProxy::from_owned(poly);\n                values_storage.setup_map.insert(key, poly);\n            }\n        }\n\n        let mut ldes_storage = AssembledPolynomialStorage::<E>::new(true, self.max_constraint_degree.next_power_of_two());\n\n        let mut monomials_storage = Self::create_monomial_storage(&worker, &omegas_inv_bitreversed, &values_storage, true)?;\n\n        monomials_storage.extend_from_setup(setup)?;\n\n        // step 1 - commit state and witness, enumerated. Also commit sorted polynomials for table arguments\n        for i in 0..num_state_polys {\n            let key = PolyIdentifier::VariablesPolynomial(i);\n            let poly_ref = monomials_storage.get_poly(key);\n            let commitment = commit_using_monomials(poly_ref, mon_crs, &worker)?;\n\n            commit_point_as_xy::<E, T>(&mut transcript, &commitment);\n\n            proof.state_polys_commitments.push(commitment);\n        }\n\n        for i in 0..num_witness_polys {\n            let key = PolyIdentifier::VariablesPolynomial(i);\n            let poly_ref = monomials_storage.get_poly(key);\n            let commitment = commit_using_monomials(poly_ref, mon_crs, &worker)?;\n\n            commit_point_as_xy::<E, T>(&mut transcript, &commitment);\n\n            proof.witness_polys_commitments.push(commitment);\n        }\n\n        let mut lookup_events = HashMap::<[E::Fr; 4], usize>::new();\n\n        // step 1.5 - if there are lookup tables then draw random \"eta\" to linearlize over tables\n        let mut lookup_data: Option<data_structures::LookupDataHolder<E>> = if self.tables.len() > 0 {\n            let eta = transcript.get_challenge();\n\n            // these are selected rows from witness (where lookup applies)\n\n            let (selector_poly, table_type_mononial, table_type_values) = if S::PRODUCE_SETUP {\n                let selector_for_lookup_values = self.calculate_lookup_selector_values()?;\n                assert!((selector_for_lookup_values.len() + 1).is_power_of_two());\n                let table_type_values = self.calculate_table_type_values()?;\n\n                assert_eq!(selector_for_lookup_values.len(), table_type_values.len());\n\n                let table_type_poly_monomial = {\n                    let mon = Polynomial::from_values(table_type_values.clone())?;\n                    let mon = mon.ifft_using_bitreversed_ntt(&worker, &omegas_inv_bitreversed, &E::Fr::one())?;\n\n                    mon\n                };\n\n                let selector_poly = Polynomial::<E::Fr, Values>::from_values(selector_for_lookup_values)?.ifft_using_bitreversed_ntt(&worker, &omegas_inv_bitreversed, &E::Fr::one())?;\n\n                let selector_poly = PolynomialProxy::from_owned(selector_poly);\n                let table_type_poly = PolynomialProxy::from_owned(table_type_poly_monomial);\n\n                (selector_poly, table_type_poly, table_type_values)\n            } else {\n                let selector_poly_ref = setup.lookup_selector_monomial.as_ref().expect(\"setup must contain lookup selector poly\");\n                let selector_poly = PolynomialProxy::from_borrowed(selector_poly_ref);\n\n                let table_type_poly_ref = setup.lookup_table_type_monomial.as_ref().expect(\"setup must contain lookup table type poly\");\n                let table_type_poly = PolynomialProxy::from_borrowed(table_type_poly_ref);\n\n                // let mut table_type_values = table_type_poly_ref.clone().fft(&worker).into_coeffs();\n                let mut table_type_values = table_type_poly_ref.clone().fft_using_bitreversed_ntt(&worker, &omegas_bitreversed, &E::Fr::one())?.into_coeffs();\n\n                table_type_values.pop().unwrap();\n\n                (selector_poly, table_type_poly, table_type_values)\n            };\n\n            assert!((table_type_values.len() + 1).is_power_of_two());\n            let witness_len = required_domain_size - 1;\n            assert!((witness_len + 1).is_power_of_two());\n            assert_eq!(table_type_values.len(), witness_len);\n\n            let f_poly_values_aggregated = {\n                let mut table_contributions_values = if S::PRODUCE_SETUP && S::PRODUCE_WITNESS {\n                    let masked_entries_using_bookkept_bitmasks = self.calculate_masked_lookup_entries(&values_storage)?;\n\n                    let typical_len = masked_entries_using_bookkept_bitmasks[0].len();\n                    assert!((typical_len + 1).is_power_of_two());\n\n                    masked_entries_using_bookkept_bitmasks\n                } else {\n                    assert!(S::PRODUCE_WITNESS);\n                    // let selector_values = PolynomialProxy::from_owned(selector_poly.as_ref().clone().fft(&worker));\n                    let selector_values = selector_poly.as_ref().clone().fft_using_bitreversed_ntt(&worker, &omegas_bitreversed, &E::Fr::one())?;\n\n                    let selector_values = PolynomialProxy::from_owned(selector_values);\n\n                    self.calculate_masked_lookup_entries_using_selector(&values_storage, &selector_values)?\n                };\n\n                assert_eq!(table_type_values.len(), table_contributions_values[0].len());\n\n                assert_eq!(table_contributions_values.len(), 3);\n\n                assert_eq!(witness_len, table_contributions_values[0].len());\n\n                let mut f_poly_values_aggregated = table_contributions_values.drain(0..1).collect::<Vec<_>>().pop().unwrap();\n\n                let mut current = eta;\n                for t in table_contributions_values.into_iter() {\n                    let op = BinopAddAssignScaled::new(current);\n                    binop_over_slices(&worker, &op, &mut f_poly_values_aggregated, &t);\n\n                    current.mul_assign(&eta);\n                }\n\n                // add table type marker\n                let op = BinopAddAssignScaled::new(current);\n                binop_over_slices(&worker, &op, &mut f_poly_values_aggregated, &table_type_values);\n\n                Polynomial::from_values_unpadded(f_poly_values_aggregated)?\n            };\n\n            let (t_poly_values, t_poly_values_shifted, t_poly_monomial) = if S::PRODUCE_SETUP {\n                // these are unsorted rows of lookup tables\n                let mut t_poly_ends = self.calculate_t_polynomial_values_for_single_application_tables()?;\n                assert_eq!(t_poly_ends.len(), 4);\n\n                let mut t_poly_values_aggregated = t_poly_ends.drain(0..1).collect::<Vec<_>>().pop().unwrap();\n                let mut current = eta;\n                for t in t_poly_ends.into_iter() {\n                    let op = BinopAddAssignScaled::new(current);\n                    binop_over_slices(&worker, &op, &mut t_poly_values_aggregated, &t);\n\n                    current.mul_assign(&eta);\n                }\n\n                let copy_start = witness_len - t_poly_values_aggregated.len();\n                let mut full_t_poly_values = vec![E::Fr::zero(); witness_len];\n                let mut full_t_poly_values_shifted = full_t_poly_values.clone();\n\n                full_t_poly_values[copy_start..].copy_from_slice(&t_poly_values_aggregated);\n                full_t_poly_values_shifted[(copy_start - 1)..(witness_len - 1)].copy_from_slice(&t_poly_values_aggregated);\n\n                assert!(full_t_poly_values[0].is_zero());\n\n                let t_poly_monomial = {\n                    let mon = Polynomial::from_values(full_t_poly_values.clone())?;\n                    let mon = mon.ifft_using_bitreversed_ntt(&worker, &omegas_inv_bitreversed, &E::Fr::one())?;\n\n                    mon\n                };\n\n                (\n                    PolynomialProxy::from_owned(Polynomial::from_values_unpadded(full_t_poly_values)?),\n                    PolynomialProxy::from_owned(Polynomial::from_values_unpadded(full_t_poly_values_shifted)?),\n                    PolynomialProxy::from_owned(t_poly_monomial),\n                )\n            } else {\n                let mut t_poly_values_monomial_aggregated = setup.lookup_tables_monomials[0].clone();\n                let mut current = eta;\n                for idx in 1..4 {\n                    let to_aggregate_ref = &setup.lookup_tables_monomials[idx];\n                    t_poly_values_monomial_aggregated.add_assign_scaled(&worker, to_aggregate_ref, &current);\n\n                    current.mul_assign(&eta);\n                }\n\n                assert!(t_poly_values_monomial_aggregated.size().is_power_of_two());\n\n                let mut t_poly_values = t_poly_values_monomial_aggregated.clone().fft_using_bitreversed_ntt(&worker, &omegas_bitreversed, &E::Fr::one())?;\n                assert!(t_poly_values.as_ref().last().unwrap().is_zero());\n                assert!(t_poly_values.size().is_power_of_two());\n\n                // let mut t_values_shifted_coeffs = vec![E::Fr::zero(); t_poly_values.size()];\n                // // manually shift by 1\n                // t_values_shifted_coeffs[1..].copy_from_slice(&t_poly_values.as_ref()[0..(t_poly_values.size()-1)]);\n                // t_values_shifted_coeffs[0] = t_poly_values.as_ref()[(t_poly_values.size()-1)];\n\n                let mut t_values_shifted_coeffs = t_poly_values.clone().into_coeffs();\n                let _last = t_poly_values.pop_last()?;\n                assert!(_last.is_zero());\n                let _: Vec<_> = t_values_shifted_coeffs.drain(0..1).collect();\n\n                let t_poly_values_shifted = Polynomial::from_values_unpadded(t_values_shifted_coeffs)?;\n\n                assert_eq!(witness_len, t_poly_values.size());\n                assert_eq!(witness_len, t_poly_values_shifted.size());\n\n                (\n                    PolynomialProxy::from_owned(t_poly_values),\n                    PolynomialProxy::from_owned(t_poly_values_shifted),\n                    PolynomialProxy::from_owned(t_poly_values_monomial_aggregated),\n                )\n            };\n\n            let (s_poly_monomial, s_poly_unpadded_values, s_shifted_unpadded_values) = {\n                let s_poly_values_aggregated = self.calculate_s_poly_contributions_from_witness(eta)?;\n\n                let sorted_copy_start = witness_len - s_poly_values_aggregated.len();\n\n                let mut full_s_poly_values = vec![E::Fr::zero(); witness_len];\n                let mut full_s_poly_values_shifted = full_s_poly_values.clone();\n\n                full_s_poly_values[sorted_copy_start..].copy_from_slice(&s_poly_values_aggregated);\n                full_s_poly_values_shifted[(sorted_copy_start - 1)..(witness_len - 1)].copy_from_slice(&s_poly_values_aggregated);\n\n                assert!(full_s_poly_values[0].is_zero());\n\n                let s_poly_monomial = {\n                    let mon = Polynomial::from_values(full_s_poly_values.clone())?;\n                    let mon = mon.ifft_using_bitreversed_ntt(&worker, &omegas_inv_bitreversed, &E::Fr::one())?;\n\n                    mon\n                };\n\n                (\n                    s_poly_monomial,\n                    Polynomial::from_values_unpadded(full_s_poly_values)?,\n                    Polynomial::from_values_unpadded(full_s_poly_values_shifted)?,\n                )\n            };\n\n            let s_poly_commitment = commit_using_monomials(&s_poly_monomial, mon_crs, &worker)?;\n\n            commit_point_as_xy::<E, T>(&mut transcript, &s_poly_commitment);\n\n            proof.lookup_s_poly_commitment = Some(s_poly_commitment);\n\n            let data = data_structures::LookupDataHolder::<E> {\n                eta,\n                f_poly_unpadded_values: Some(f_poly_values_aggregated),\n                t_poly_unpadded_values: Some(t_poly_values),\n                t_shifted_unpadded_values: Some(t_poly_values_shifted),\n                s_poly_unpadded_values: Some(s_poly_unpadded_values),\n                s_shifted_unpadded_values: Some(s_shifted_unpadded_values),\n                t_poly_monomial: Some(t_poly_monomial),\n                s_poly_monomial: Some(s_poly_monomial),\n                selector_poly_monomial: Some(selector_poly),\n                table_type_poly_monomial: Some(table_type_mononial),\n            };\n\n            Some(data)\n        } else {\n            None\n        };\n\n        if self.multitables.len() > 0 {\n            unimplemented!(\"do not support multitables yet\")\n        }\n\n        // step 2 - grand product arguments\n\n        let beta_for_copy_permutation = transcript.get_challenge();\n        let gamma_for_copy_permutation = transcript.get_challenge();\n\n        // copy permutation grand product argument\n\n        let mut grand_products_protos_with_gamma = vec![];\n\n        for i in 0..num_state_polys {\n            let id = PolyIdentifier::VariablesPolynomial(i);\n\n            let mut p = values_storage.state_map.get(&id).unwrap().as_ref().clone();\n            p.add_constant(&worker, &gamma_for_copy_permutation);\n\n            grand_products_protos_with_gamma.push(p);\n        }\n\n        #[allow(clippy::redundant_locals)]\n        let required_domain_size = required_domain_size;\n\n        let domain = Domain::new_for_size(required_domain_size as u64)?;\n\n        let mut domain_elements = materialize_domain_elements_with_natural_enumeration(&domain, &worker);\n\n        domain_elements.pop().expect(\"must pop last element for omega^i\");\n\n        let non_residues = make_non_residues::<E::Fr>(num_state_polys - 1);\n\n        let mut domain_elements_poly_by_beta = Polynomial::from_values_unpadded(domain_elements)?;\n        domain_elements_poly_by_beta.scale(&worker, beta_for_copy_permutation);\n\n        // we take A, B, C, ... values and form (A + beta * X * non_residue + gamma), etc and calculate their grand product\n\n        let mut z_num = {\n            let mut grand_products_proto_it = grand_products_protos_with_gamma.iter().cloned();\n\n            let mut z_1 = grand_products_proto_it.next().unwrap();\n            z_1.add_assign(&worker, &domain_elements_poly_by_beta);\n\n            for (mut p, non_res) in grand_products_proto_it.zip(non_residues.iter()) {\n                p.add_assign_scaled(&worker, &domain_elements_poly_by_beta, non_res);\n                z_1.mul_assign(&worker, &p);\n            }\n\n            z_1\n        };\n\n        // we take A, B, C, ... values and form (A + beta * perm_a + gamma), etc and calculate their grand product\n\n        let mut permutation_polynomials_values_of_size_n_minus_one = vec![];\n\n        for idx in 0..num_state_polys {\n            let key = PolyIdentifier::PermutationPolynomial(idx);\n\n            let mut coeffs = values_storage.get_poly(key).clone().into_coeffs();\n            coeffs.pop().unwrap();\n\n            let p = Polynomial::from_values_unpadded(coeffs)?;\n            permutation_polynomials_values_of_size_n_minus_one.push(p);\n        }\n\n        let z_den = {\n            assert_eq!(permutation_polynomials_values_of_size_n_minus_one.len(), grand_products_protos_with_gamma.len());\n            let mut grand_products_proto_it = grand_products_protos_with_gamma.into_iter();\n            let mut permutation_polys_it = permutation_polynomials_values_of_size_n_minus_one.iter();\n\n            let mut z_2 = grand_products_proto_it.next().unwrap();\n            z_2.add_assign_scaled(&worker, permutation_polys_it.next().unwrap(), &beta_for_copy_permutation);\n\n            for (mut p, perm) in grand_products_proto_it.zip(permutation_polys_it) {\n                // permutation polynomials\n                p.add_assign_scaled(&worker, &perm, &beta_for_copy_permutation);\n                z_2.mul_assign(&worker, &p);\n            }\n\n            z_2.batch_inversion(&worker)?;\n\n            z_2\n        };\n\n        z_num.mul_assign(&worker, &z_den);\n        drop(z_den);\n\n        let z = z_num.calculate_shifted_grand_product(&worker)?;\n        drop(z_num);\n\n        assert!(z.size().is_power_of_two());\n\n        assert!(z.as_ref()[0] == E::Fr::one());\n\n        let copy_permutation_z_in_monomial_form = z.ifft_using_bitreversed_ntt(&worker, &omegas_inv_bitreversed, &E::Fr::one())?;\n\n        let copy_permutation_z_poly_commitment = commit_using_monomials(&copy_permutation_z_in_monomial_form, mon_crs, &worker)?;\n\n        commit_point_as_xy::<E, T>(&mut transcript, &copy_permutation_z_poly_commitment);\n\n        proof.copy_permutation_grand_product_commitment = copy_permutation_z_poly_commitment;\n\n        let mut beta_for_lookup = None;\n        let mut gamma_for_lookup = None;\n\n        let lookup_z_poly_in_monomial_form = if let Some(data) = lookup_data.as_mut() {\n            let beta_for_lookup_permutation = transcript.get_challenge();\n            let gamma_for_lookup_permutation = transcript.get_challenge();\n\n            // let beta_for_lookup_permutation = E::Fr::from_str(\"789\").unwrap();\n            // let gamma_for_lookup_permutation = E::Fr::from_str(\"1230\").unwrap();\n\n            beta_for_lookup = Some(beta_for_lookup_permutation);\n            gamma_for_lookup = Some(gamma_for_lookup_permutation);\n\n            let mut beta_plus_one = beta_for_lookup_permutation;\n            beta_plus_one.add_assign(&E::Fr::one());\n            let mut gamma_beta = gamma_for_lookup_permutation;\n            gamma_beta.mul_assign(&beta_plus_one);\n\n            let expected = gamma_beta.pow([(required_domain_size - 1) as u64]);\n\n            let f_poly_unpadded_values = data.f_poly_unpadded_values.take().unwrap();\n            let t_poly_unpadded_values = data.t_poly_unpadded_values.take().unwrap();\n            let t_shifted_unpadded_values = data.t_shifted_unpadded_values.take().unwrap();\n            let s_poly_unpadded_values = data.s_poly_unpadded_values.take().unwrap();\n            let s_shifted_unpadded_values = data.s_shifted_unpadded_values.take().unwrap();\n\n            // Z(x*omega) = Z(x) *\n            // (\\beta + 1) * (\\gamma + f(x)) * (\\gamma(1 + \\beta) + t(x) + \\beta * t(x*omega)) /\n            // (\\gamma*(1 + \\beta) + s(x) + \\beta * s(x*omega)))\n\n            let mut z_num = {\n                // (\\beta + 1) * (\\gamma + f(x)) * (\\gamma(1 + \\beta) + t(x) + \\beta * t(x*omega))\n\n                let mut t = t_poly_unpadded_values.as_ref().clone();\n                t.add_assign_scaled(&worker, t_shifted_unpadded_values.as_ref(), &beta_for_lookup_permutation);\n                t.add_constant(&worker, &gamma_beta);\n\n                let mut tmp = f_poly_unpadded_values.clone();\n                tmp.add_constant(&worker, &gamma_for_lookup_permutation);\n                tmp.scale(&worker, beta_plus_one);\n\n                t.mul_assign(&worker, &tmp);\n                drop(tmp);\n\n                t\n            };\n\n            let z_den = {\n                // (\\gamma*(1 + \\beta) + s(x) + \\beta * s(x*omega)))\n\n                let mut t = s_poly_unpadded_values.clone();\n                t.add_assign_scaled(&worker, &s_shifted_unpadded_values, &beta_for_lookup_permutation);\n                t.add_constant(&worker, &gamma_beta);\n\n                t.batch_inversion(&worker)?;\n\n                t\n            };\n\n            z_num.mul_assign(&worker, &z_den);\n            drop(z_den);\n\n            let z = z_num.calculate_shifted_grand_product(&worker)?;\n            drop(z_num);\n\n            assert!(z.size().is_power_of_two());\n\n            assert_eq!(z.as_ref()[0], E::Fr::one());\n            assert_eq!(*z.as_ref().last().unwrap(), expected);\n\n            // let t_poly_monomial = t_poly_unpadded_values.as_ref().clone_padded_to_domain()?.ifft_using_bitreversed_ntt(\n            //     &worker,\n            //     &omegas_inv_bitreversed,\n            //     &E::Fr::one()\n            // )?;\n\n            // let s_poly_monomial = s_poly_unpadded_values.clone_padded_to_domain()?.ifft_using_bitreversed_ntt(\n            //     &worker,\n            //     &omegas_inv_bitreversed,\n            //     &E::Fr::one()\n            // )?;\n\n            // data.t_poly_monomial = Some(t_poly_monomial);\n            // data.s_poly_monomial = Some(s_poly_monomial);\n\n            let z = z.ifft_using_bitreversed_ntt(&worker, &omegas_inv_bitreversed, &E::Fr::one())?;\n\n            let lookup_z_poly_commitment = commit_using_monomials(&z, mon_crs, &worker)?;\n\n            commit_point_as_xy::<E, T>(&mut transcript, &lookup_z_poly_commitment);\n\n            proof.lookup_grand_product_commitment = Some(lookup_z_poly_commitment);\n\n            Some(z)\n        } else {\n            None\n        };\n\n        // now draw alpha and add all the contributions to the quotient polynomial\n\n        let alpha = transcript.get_challenge();\n        // let alpha = E::Fr::from_str(\"1234567890\").unwrap();\n\n        let mut total_powers_of_alpha_for_gates = 0;\n        for g in self.sorted_gates.iter() {\n            total_powers_of_alpha_for_gates += g.num_quotient_terms();\n        }\n\n        // println!(\"Have {} terms from {} gates\", total_powers_of_alpha_for_gates, self.sorted_gates.len());\n\n        let mut current_alpha = E::Fr::one();\n        let mut powers_of_alpha_for_gates = Vec::with_capacity(total_powers_of_alpha_for_gates);\n        powers_of_alpha_for_gates.push(current_alpha);\n        for _ in 1..total_powers_of_alpha_for_gates {\n            current_alpha.mul_assign(&alpha);\n            powers_of_alpha_for_gates.push(current_alpha);\n        }\n\n        assert_eq!(powers_of_alpha_for_gates.len(), total_powers_of_alpha_for_gates);\n\n        let mut all_gates = self.sorted_gates.clone();\n        let num_different_gates = self.sorted_gates.len();\n\n        let mut challenges_slice = &powers_of_alpha_for_gates[..];\n\n        let mut lde_factor = num_state_polys;\n        for g in self.sorted_gates.iter() {\n            let degree = g.degree();\n            if degree > lde_factor {\n                lde_factor = degree;\n            }\n        }\n\n        assert!(lde_factor <= 4);\n\n        let coset_factor = E::Fr::multiplicative_generator();\n\n        let mut t_poly = {\n            let gate = all_gates.drain(0..1).into_iter().next().unwrap();\n            assert!(<Self as ConstraintSystem<E>>::MainGate::default().into_internal() == gate);\n            let gate = <Self as ConstraintSystem<E>>::MainGate::default();\n            let num_challenges = gate.num_quotient_terms();\n            let (for_gate, rest) = challenges_slice.split_at(num_challenges);\n            challenges_slice = rest;\n\n            let input_values = self.input_assingments.clone();\n\n            let mut t = gate.contribute_into_quotient_for_public_inputs(\n                required_domain_size,\n                &input_values,\n                &mut ldes_storage,\n                &monomials_storage,\n                for_gate,\n                &omegas_bitreversed,\n                &omegas_inv_bitreversed,\n                &worker,\n            )?;\n\n            if num_different_gates > 1 {\n                // we have to multiply by the masking poly (selector)\n                let key = PolyIdentifier::GateSelector(gate.name());\n                let monomial_selector = monomials_storage.gate_selectors.get(&key).unwrap().as_ref();\n                let selector_lde = monomial_selector\n                    .clone_padded_to_domain()?\n                    .bitreversed_lde_using_bitreversed_ntt(&worker, lde_factor, &omegas_bitreversed, &coset_factor)?;\n\n                t.mul_assign(&worker, &selector_lde);\n                drop(selector_lde);\n            }\n\n            t\n        };\n\n        let non_main_gates = all_gates;\n\n        for gate in non_main_gates.into_iter() {\n            let num_challenges = gate.num_quotient_terms();\n            let (for_gate, rest) = challenges_slice.split_at(num_challenges);\n            challenges_slice = rest;\n\n            let mut contribution = gate.contribute_into_quotient(\n                required_domain_size,\n                &mut ldes_storage,\n                &monomials_storage,\n                for_gate,\n                &omegas_bitreversed,\n                &omegas_inv_bitreversed,\n                &worker,\n            )?;\n\n            {\n                // we have to multiply by the masking poly (selector)\n                let key = PolyIdentifier::GateSelector(gate.name());\n                let monomial_selector = monomials_storage.gate_selectors.get(&key).unwrap().as_ref();\n                let selector_lde = monomial_selector\n                    .clone_padded_to_domain()?\n                    .bitreversed_lde_using_bitreversed_ntt(&worker, lde_factor, &omegas_bitreversed, &coset_factor)?;\n\n                contribution.mul_assign(&worker, &selector_lde);\n                drop(selector_lde);\n            }\n\n            t_poly.add_assign(&worker, &contribution);\n        }\n\n        assert_eq!(challenges_slice.len(), 0);\n\n        // println!(\"Power of alpha for a start of normal permutation argument = {}\", total_powers_of_alpha_for_gates);\n\n        // perform copy-permutation argument\n\n        // we precompute L_{0} here cause it's necessary for both copy-permutation and lookup permutation\n\n        // z(omega^0) - 1 == 0\n        let l_0 = calculate_lagrange_poly::<E::Fr>(&worker, required_domain_size.next_power_of_two(), 0)?;\n\n        let l_0_coset_lde_bitreversed = l_0.bitreversed_lde_using_bitreversed_ntt(&worker, lde_factor, &omegas_bitreversed, &coset_factor)?;\n\n        let mut copy_grand_product_alphas = None;\n        let x_poly_lde_bitreversed = {\n            // now compute the permutation argument\n\n            // bump alpha\n            current_alpha.mul_assign(&alpha);\n            let alpha_0 = current_alpha;\n\n            let z_coset_lde_bitreversed = copy_permutation_z_in_monomial_form\n                .clone()\n                .bitreversed_lde_using_bitreversed_ntt(&worker, lde_factor, &omegas_bitreversed, &coset_factor)?;\n\n            assert!(z_coset_lde_bitreversed.size() == required_domain_size * lde_factor);\n\n            let z_shifted_coset_lde_bitreversed = z_coset_lde_bitreversed.clone_shifted_assuming_bitreversed(lde_factor, &worker)?;\n\n            assert!(z_shifted_coset_lde_bitreversed.size() == required_domain_size * lde_factor);\n\n            // For both Z_1 and Z_2 we first check for grand products\n            // z*(X)(A + beta*X + gamma)(B + beta*k_1*X + gamma)(C + beta*K_2*X + gamma) -\n            // - (A + beta*perm_a(X) + gamma)(B + beta*perm_b(X) + gamma)(C + beta*perm_c(X) + gamma)*Z(X*Omega)== 0\n\n            // we use evaluations of the polynomial X and K_i * X on a large domain's coset\n            let mut contrib_z = z_coset_lde_bitreversed.clone();\n\n            // precompute x poly\n            let mut x_poly = Polynomial::from_values(vec![coset_factor; required_domain_size * lde_factor])?;\n            x_poly.distribute_powers(&worker, z_shifted_coset_lde_bitreversed.omega);\n            x_poly.bitreverse_enumeration(&worker);\n\n            assert_eq!(x_poly.size(), required_domain_size * lde_factor);\n\n            // A + beta*X + gamma\n\n            let mut tmp = ldes_storage.state_map.get(&PolyIdentifier::VariablesPolynomial(0)).unwrap().as_ref().clone();\n            tmp.add_constant(&worker, &gamma_for_copy_permutation);\n            tmp.add_assign_scaled(&worker, &x_poly, &beta_for_copy_permutation);\n            contrib_z.mul_assign(&worker, &tmp);\n\n            assert_eq!(non_residues.len() + 1, num_state_polys);\n\n            for (poly_idx, non_res) in (1..num_state_polys).zip(non_residues.iter()) {\n                let mut factor = beta_for_copy_permutation;\n                factor.mul_assign(&non_res);\n\n                let key = PolyIdentifier::VariablesPolynomial(poly_idx);\n                tmp.reuse_allocation(&ldes_storage.state_map.get(&key).unwrap().as_ref());\n                tmp.add_constant(&worker, &gamma_for_copy_permutation);\n                tmp.add_assign_scaled(&worker, &x_poly, &factor);\n                contrib_z.mul_assign(&worker, &tmp);\n            }\n\n            t_poly.add_assign_scaled(&worker, &contrib_z, &current_alpha);\n\n            drop(contrib_z);\n\n            let mut contrib_z = z_shifted_coset_lde_bitreversed;\n\n            // A + beta*perm_a + gamma\n\n            for idx in 0..num_state_polys {\n                let key = PolyIdentifier::VariablesPolynomial(idx);\n\n                tmp.reuse_allocation(&ldes_storage.state_map.get(&key).unwrap().as_ref());\n                tmp.add_constant(&worker, &gamma_for_copy_permutation);\n\n                let key = PolyIdentifier::PermutationPolynomial(idx);\n                let perm = monomials_storage\n                    .get_poly(key)\n                    .clone()\n                    .bitreversed_lde_using_bitreversed_ntt(&worker, lde_factor, &omegas_bitreversed, &coset_factor)?;\n                tmp.add_assign_scaled(&worker, &perm, &beta_for_copy_permutation);\n                contrib_z.mul_assign(&worker, &tmp);\n                drop(perm);\n            }\n\n            t_poly.sub_assign_scaled(&worker, &contrib_z, &current_alpha);\n\n            drop(contrib_z);\n\n            drop(tmp);\n\n            // Z(x) * L_{0}(x) - 1 == 0\n            current_alpha.mul_assign(&alpha);\n\n            let alpha_1 = current_alpha;\n\n            {\n                let mut z_minus_one_by_l_0 = z_coset_lde_bitreversed;\n                z_minus_one_by_l_0.sub_constant(&worker, &E::Fr::one());\n\n                z_minus_one_by_l_0.mul_assign(&worker, &l_0_coset_lde_bitreversed);\n\n                t_poly.add_assign_scaled(&worker, &z_minus_one_by_l_0, &current_alpha);\n            }\n\n            copy_grand_product_alphas = Some([alpha_0, alpha_1]);\n\n            x_poly\n        };\n\n        // add contribution from grand product for loopup polys if there is one\n\n        let mut lookup_grand_product_alphas = None;\n        if let Some(z_poly_in_monomial_form) = lookup_z_poly_in_monomial_form.as_ref() {\n            let beta_for_lookup_permutation = beta_for_lookup.unwrap();\n            let gamma_for_lookup_permutation = gamma_for_lookup.unwrap();\n\n            let mut beta_plus_one = beta_for_lookup_permutation;\n            beta_plus_one.add_assign(&E::Fr::one());\n            let mut gamma_beta = gamma_for_lookup_permutation;\n            gamma_beta.mul_assign(&beta_plus_one);\n\n            let expected = gamma_beta.pow([(required_domain_size - 1) as u64]);\n\n            current_alpha.mul_assign(&alpha);\n\n            let alpha_0 = current_alpha;\n\n            // same grand product argument for lookup permutation except divisor is now with one point cut\n\n            let z_lde = z_poly_in_monomial_form\n                .clone()\n                .bitreversed_lde_using_bitreversed_ntt(&worker, lde_factor, &omegas_bitreversed, &coset_factor)?;\n\n            let z_lde_shifted = z_lde.clone_shifted_assuming_bitreversed(lde_factor, &worker)?;\n\n            // We make an small ad-hoc modification here and instead of dividing some contributions by\n            // (X^n - 1)/(X - omega^{n-1}) we move (X - omega^{n-1}) to the numerator and join the divisions\n\n            // Numerator degree is at max 4n, so it's < 4n after division\n\n            // ( Z(x*omega)*(\\gamma*(1 + \\beta) + s(x) + \\beta * s(x*omega))) -\n            // - Z(x) * (\\beta + 1) * (\\gamma + f(x)) * (\\gamma(1 + \\beta) + t(x) + \\beta * t(x*omega)) )*(X - omega^{n-1})\n\n            let data = lookup_data.as_ref().unwrap();\n\n            let s_lde = data\n                .s_poly_monomial\n                .as_ref()\n                .unwrap()\n                .clone()\n                .bitreversed_lde_using_bitreversed_ntt(&worker, lde_factor, &omegas_bitreversed, &coset_factor)?;\n\n            let s_lde_shifted = s_lde.clone_shifted_assuming_bitreversed(lde_factor, &worker)?;\n\n            // Z(x*omega)*(\\gamma*(1 + \\beta) + s(x) + \\beta * s(x*omega)))\n\n            let mut contribution = s_lde;\n            contribution.add_assign_scaled(&worker, &s_lde_shifted, &beta_for_lookup_permutation);\n            contribution.add_constant(&worker, &gamma_beta);\n            contribution.mul_assign(&worker, &z_lde_shifted);\n\n            drop(s_lde_shifted);\n            drop(z_lde_shifted);\n\n            let t_lde = data\n                .t_poly_monomial\n                .as_ref()\n                .unwrap()\n                .as_ref()\n                .clone()\n                .bitreversed_lde_using_bitreversed_ntt(&worker, lde_factor, &omegas_bitreversed, &coset_factor)?;\n\n            let t_lde_shifted = t_lde.clone_shifted_assuming_bitreversed(lde_factor, &worker)?;\n\n            let f_lde = {\n                // add up ldes of a,b,c and table_type poly and multiply by selector\n\n                let a_ref = get_from_map_unchecked(PolynomialInConstraint::from_id(PolyIdentifier::VariablesPolynomial(0)), &ldes_storage);\n                let mut tmp = a_ref.clone();\n                drop(a_ref);\n\n                let eta = lookup_data.as_ref().unwrap().eta;\n\n                let mut current = eta;\n\n                let b_ref = get_from_map_unchecked(PolynomialInConstraint::from_id(PolyIdentifier::VariablesPolynomial(1)), &ldes_storage);\n\n                tmp.add_assign_scaled(&worker, b_ref, &current);\n\n                drop(b_ref);\n                current.mul_assign(&eta);\n\n                let c_ref = get_from_map_unchecked(PolynomialInConstraint::from_id(PolyIdentifier::VariablesPolynomial(2)), &ldes_storage);\n\n                tmp.add_assign_scaled(&worker, c_ref, &current);\n\n                drop(c_ref);\n                current.mul_assign(&eta);\n\n                let table_type_lde = lookup_data\n                    .as_ref()\n                    .unwrap()\n                    .table_type_poly_monomial\n                    .as_ref()\n                    .unwrap()\n                    .as_ref()\n                    .clone()\n                    .bitreversed_lde_using_bitreversed_ntt(&worker, lde_factor, &omegas_bitreversed, &coset_factor)?;\n\n                tmp.add_assign_scaled(&worker, &table_type_lde, &current);\n\n                drop(table_type_lde);\n\n                let lookup_selector_lde = lookup_data\n                    .as_ref()\n                    .unwrap()\n                    .selector_poly_monomial\n                    .as_ref()\n                    .unwrap()\n                    .as_ref()\n                    .clone()\n                    .bitreversed_lde_using_bitreversed_ntt(&worker, lde_factor, &omegas_bitreversed, &coset_factor)?;\n\n                tmp.mul_assign(&worker, &lookup_selector_lde);\n\n                drop(lookup_selector_lde);\n\n                tmp\n            };\n\n            //  - Z(x) * (\\beta + 1) * (\\gamma + f(x)) * (\\gamma(1 + \\beta) + t(x) + \\beta * t(x*omega))\n\n            let mut tmp = f_lde;\n            tmp.add_constant(&worker, &gamma_for_lookup_permutation);\n            tmp.mul_assign(&worker, &z_lde);\n            tmp.scale(&worker, beta_plus_one);\n\n            let mut t = t_lde;\n            t.add_assign_scaled(&worker, &t_lde_shifted, &beta_for_lookup_permutation);\n            t.add_constant(&worker, &gamma_beta);\n\n            tmp.mul_assign(&worker, &t);\n\n            drop(t);\n            drop(t_lde_shifted);\n\n            contribution.sub_assign(&worker, &tmp);\n\n            contribution.scale(&worker, current_alpha);\n\n            // multiply by (X - omega^{n-1})\n\n            let last_omega = domain.generator.pow(&[(required_domain_size - 1) as u64]);\n            let mut x_minus_last_omega = x_poly_lde_bitreversed;\n            x_minus_last_omega.sub_constant(&worker, &last_omega);\n\n            contribution.mul_assign(&worker, &x_minus_last_omega);\n            drop(x_minus_last_omega);\n\n            // we do not need to do addition multiplications for terms below cause multiplication by lagrange poly\n            // does everything for us\n\n            // check that (Z(x) - 1) * L_{0} == 0\n            current_alpha.mul_assign(&alpha);\n\n            let alpha_1 = current_alpha;\n\n            tmp.reuse_allocation(&z_lde);\n            tmp.sub_constant(&worker, &E::Fr::one());\n            tmp.mul_assign(&worker, &l_0_coset_lde_bitreversed);\n\n            drop(l_0_coset_lde_bitreversed);\n\n            contribution.add_assign_scaled(&worker, &tmp, &current_alpha);\n\n            // check that (Z(x) - expected) * L_{n-1}  == 0\n\n            current_alpha.mul_assign(&alpha);\n\n            let alpha_2 = current_alpha;\n\n            let l_last = calculate_lagrange_poly::<E::Fr>(&worker, required_domain_size.next_power_of_two(), required_domain_size - 1)?;\n\n            let l_last_coset_lde_bitreversed = l_last.bitreversed_lde_using_bitreversed_ntt(&worker, lde_factor, &omegas_bitreversed, &coset_factor)?;\n\n            tmp.reuse_allocation(&z_lde);\n            tmp.sub_constant(&worker, &expected);\n            tmp.mul_assign(&worker, &l_last_coset_lde_bitreversed);\n\n            drop(l_last_coset_lde_bitreversed);\n\n            contribution.add_assign_scaled(&worker, &tmp, &current_alpha);\n\n            drop(tmp);\n            drop(z_lde);\n\n            t_poly.add_assign(&worker, &contribution);\n\n            drop(contribution);\n\n            lookup_grand_product_alphas = Some([alpha_0, alpha_1, alpha_2]);\n        } else {\n            drop(x_poly_lde_bitreversed);\n            drop(l_0_coset_lde_bitreversed);\n        }\n\n        // perform the division\n\n        let inverse_divisor_on_coset_lde_natural_ordering = {\n            let mut vanishing_poly_inverse_bitreversed =\n                evaluate_vanishing_polynomial_of_degree_on_domain_size::<E::Fr>(required_domain_size as u64, &E::Fr::multiplicative_generator(), (required_domain_size * lde_factor) as u64, &worker)?;\n            vanishing_poly_inverse_bitreversed.batch_inversion(&worker)?;\n            // vanishing_poly_inverse_bitreversed.bitreverse_enumeration(&worker)?;\n\n            vanishing_poly_inverse_bitreversed\n        };\n\n        // don't forget to bitreverse\n\n        t_poly.bitreverse_enumeration(&worker);\n\n        t_poly.mul_assign(&worker, &inverse_divisor_on_coset_lde_natural_ordering);\n\n        drop(inverse_divisor_on_coset_lde_natural_ordering);\n\n        let t_poly = t_poly.icoset_fft_for_generator(&worker, &coset_factor);\n\n        // println!(\"Lde factor = {}\", lde_factor);\n\n        // println!(\"Quotient poly = {:?}\", t_poly.as_ref());\n\n        {\n            // degree is 4n-4\n            let l = t_poly.as_ref().len();\n            // assert_eq!(&t_poly.as_ref()[(l-4)..], &[E::Fr::zero(); 4][..], \"quotient degree is too large\");\n            if &t_poly.as_ref()[(l - 4)..] != &[E::Fr::zero(); 4][..] {\n                println!(\"End coeffs are {:?}\", &t_poly.as_ref()[(l - 4)..]);\n                return Err(SynthesisError::Unsatisfiable);\n            }\n        }\n\n        // println!(\"Quotient poly degree = {}\", get_degree::<E::Fr>(&t_poly));\n\n        let mut t_poly_parts = t_poly.break_into_multiples(required_domain_size)?;\n\n        for part in t_poly_parts.iter() {\n            let commitment = commit_using_monomials(part, mon_crs, &worker)?;\n\n            commit_point_as_xy::<E, T>(&mut transcript, &commitment);\n\n            proof.quotient_poly_parts_commitments.push(commitment);\n        }\n\n        // draw opening point\n        let z = transcript.get_challenge();\n\n        // let z = E::Fr::from_str(\"333444555\").unwrap();\n        let omega = domain.generator;\n\n        // evaluate quotient at z\n\n        let quotient_at_z = {\n            let mut result = E::Fr::zero();\n            let mut current = E::Fr::one();\n            let z_in_domain_size = z.pow(&[required_domain_size as u64]);\n            for p in t_poly_parts.iter() {\n                let mut subvalue_at_z = p.evaluate_at(&worker, z);\n\n                subvalue_at_z.mul_assign(&current);\n                result.add_assign(&subvalue_at_z);\n                current.mul_assign(&z_in_domain_size);\n            }\n\n            result\n        };\n\n        // commit quotient value\n        transcript.commit_field_element(&quotient_at_z);\n\n        proof.quotient_poly_opening_at_z = quotient_at_z;\n\n        // Now perform the linearization.\n        // First collect and evalute all the polynomials that are necessary for linearization\n        // and construction of the verification equation\n\n        const MAX_DILATION: usize = 1;\n\n        let queries_with_linearization = sort_queries_for_linearization(&self.sorted_gates, MAX_DILATION);\n\n        let mut query_values_map = std::collections::HashMap::new();\n\n        // go over all required queries\n\n        for (dilation_value, ids) in queries_with_linearization.state_polys.iter().enumerate() {\n            for id in ids.into_iter() {\n                let (poly_ref, poly_idx) = if let PolyIdentifier::VariablesPolynomial(idx) = id {\n                    (monomials_storage.state_map.get(&id).unwrap().as_ref(), idx)\n                } else {\n                    unreachable!();\n                };\n\n                let mut opening_point = z;\n                for _ in 0..dilation_value {\n                    opening_point.mul_assign(&omega);\n                }\n\n                let value = poly_ref.evaluate_at(&worker, opening_point);\n\n                transcript.commit_field_element(&value);\n\n                if dilation_value == 0 {\n                    proof.state_polys_openings_at_z.push(value);\n                } else {\n                    proof.state_polys_openings_at_dilations.push((dilation_value, *poly_idx, value));\n                }\n\n                let key = PolynomialInConstraint::from_id_and_dilation(*id, dilation_value);\n\n                query_values_map.insert(key, value);\n            }\n        }\n\n        for (dilation_value, ids) in queries_with_linearization.witness_polys.iter().enumerate() {\n            for id in ids.into_iter() {\n                let (poly_ref, poly_idx) = if let PolyIdentifier::WitnessPolynomial(idx) = id {\n                    (monomials_storage.witness_map.get(&id).unwrap().as_ref(), idx)\n                } else {\n                    unreachable!();\n                };\n\n                let mut opening_point = z;\n                for _ in 0..dilation_value {\n                    opening_point.mul_assign(&omega);\n                }\n\n                let value = poly_ref.evaluate_at(&worker, opening_point);\n\n                transcript.commit_field_element(&value);\n\n                if dilation_value == 0 {\n                    proof.witness_polys_openings_at_z.push(value);\n                } else {\n                    proof.witness_polys_openings_at_dilations.push((dilation_value, *poly_idx, value));\n                }\n\n                let key = PolynomialInConstraint::from_id_and_dilation(*id, dilation_value);\n\n                query_values_map.insert(key, value);\n            }\n        }\n\n        for (gate_idx, queries) in queries_with_linearization.gate_setup_polys.iter().enumerate() {\n            for (dilation_value, ids) in queries.iter().enumerate() {\n                for id in ids.into_iter() {\n                    let (poly_ref, poly_idx) = if let PolyIdentifier::GateSetupPolynomial(_, idx) = id {\n                        (monomials_storage.setup_map.get(&id).unwrap().as_ref(), idx)\n                    } else {\n                        unreachable!();\n                    };\n\n                    let mut opening_point = z;\n                    for _ in 0..dilation_value {\n                        opening_point.mul_assign(&omega);\n                    }\n\n                    let value = poly_ref.evaluate_at(&worker, opening_point);\n\n                    transcript.commit_field_element(&value);\n\n                    if dilation_value == 0 {\n                        proof.gate_setup_openings_at_z.push((gate_idx, *poly_idx, value));\n                    } else {\n                        unimplemented!(\"gate setup polynomials can not be time dilated\");\n                    }\n\n                    let key = PolynomialInConstraint::from_id_and_dilation(*id, dilation_value);\n\n                    query_values_map.insert(key, value);\n                }\n            }\n        }\n\n        // also open selectors\n\n        let mut selector_values = vec![];\n        for s in queries_with_linearization.gate_selectors.iter() {\n            let gate_index = self.sorted_gates.iter().position(|r| r == s).unwrap();\n\n            let key = PolyIdentifier::GateSelector(s.name());\n            let poly_ref = monomials_storage.gate_selectors.get(&key).unwrap().as_ref();\n            let value = poly_ref.evaluate_at(&worker, z);\n\n            transcript.commit_field_element(&value);\n\n            proof.gate_selectors_openings_at_z.push((gate_index, value));\n\n            selector_values.push(value);\n        }\n\n        // copy-permutation polynomials queries\n\n        let mut copy_permutation_queries = vec![];\n\n        for idx in 0..(num_state_polys - 1) {\n            let key = PolyIdentifier::PermutationPolynomial(idx);\n            let value = monomials_storage.get_poly(key).evaluate_at(&worker, z);\n\n            transcript.commit_field_element(&value);\n\n            proof.copy_permutation_polys_openings_at_z.push(value);\n\n            copy_permutation_queries.push(value);\n        }\n\n        // copy-permutation grand product query\n\n        let mut z_omega = z;\n        z_omega.mul_assign(&domain.generator);\n        let copy_permutation_z_at_z_omega = copy_permutation_z_in_monomial_form.evaluate_at(&worker, z_omega);\n        transcript.commit_field_element(&copy_permutation_z_at_z_omega);\n        proof.copy_permutation_grand_product_opening_at_z_omega = copy_permutation_z_at_z_omega;\n\n        // we've computed everything, so perform linearization\n\n        let mut challenges_slice = &powers_of_alpha_for_gates[..];\n\n        let mut all_gates = self.sorted_gates.clone();\n\n        let mut r_poly = {\n            let gate = all_gates.drain(0..1).into_iter().next().unwrap();\n            assert!(gate.benefits_from_linearization(), \"main gate is expected to benefit from linearization!\");\n            assert!(<Self as ConstraintSystem<E>>::MainGate::default().into_internal() == gate);\n            let gate = <Self as ConstraintSystem<E>>::MainGate::default();\n            let num_challenges = gate.num_quotient_terms();\n            let (for_gate, rest) = challenges_slice.split_at(num_challenges);\n            challenges_slice = rest;\n\n            let input_values = self.input_assingments.clone();\n\n            let mut r = gate.contribute_into_linearization_for_public_inputs(required_domain_size, &input_values, z, &query_values_map, &monomials_storage, for_gate, &worker)?;\n\n            let mut selectors_it = selector_values.clone().into_iter();\n\n            if num_different_gates > 1 {\n                // first multiply r by the selector value at z\n                r.scale(&worker, selectors_it.next().unwrap());\n            }\n\n            // now proceed per gate\n            for gate in all_gates.into_iter() {\n                let num_challenges = gate.num_quotient_terms();\n                let (for_gate, rest) = challenges_slice.split_at(num_challenges);\n                challenges_slice = rest;\n\n                if gate.benefits_from_linearization() {\n                    // gate benefits from linearization, so make temporary value\n                    let tmp = gate.contribute_into_linearization(required_domain_size, z, &query_values_map, &monomials_storage, for_gate, &worker)?;\n\n                    let selector_value = selectors_it.next().unwrap();\n\n                    r.add_assign_scaled(&worker, &tmp, &selector_value);\n                } else {\n                    // we linearize over the selector, so take a selector and scale it\n                    let gate_value_at_z = gate.contribute_into_verification_equation(required_domain_size, z, &query_values_map, for_gate)?;\n\n                    let key = PolyIdentifier::GateSelector(gate.name());\n                    let gate_selector_ref = monomials_storage.gate_selectors.get(&key).expect(\"must get monomial form of gate selector\").as_ref();\n\n                    r.add_assign_scaled(&worker, gate_selector_ref, &gate_value_at_z);\n                }\n            }\n\n            assert!(selectors_it.next().is_none());\n            assert_eq!(challenges_slice.len(), 0);\n\n            r\n        };\n\n        // add contributions from copy-permutation and lookup-permutation\n\n        // copy-permutation linearization comtribution\n        {\n            // + (a(z) + beta*z + gamma)*()*()*()*Z(x)\n\n            let [alpha_0, alpha_1] = copy_grand_product_alphas.expect(\"there must be powers of alpha for copy permutation\");\n\n            let some_one = Some(E::Fr::one());\n            let mut non_residues_iterator = some_one.iter().chain(&non_residues);\n\n            let mut factor = alpha_0;\n\n            for idx in 0..num_state_polys {\n                let key = PolynomialInConstraint::from_id(PolyIdentifier::VariablesPolynomial(idx));\n                let wire_value = query_values_map.get(&key).ok_or(SynthesisError::AssignmentMissing)?;\n                let mut t = z;\n                let non_res = non_residues_iterator.next().unwrap();\n                t.mul_assign(&non_res);\n                t.mul_assign(&beta_for_copy_permutation);\n                t.add_assign(&wire_value);\n                t.add_assign(&gamma_for_copy_permutation);\n\n                factor.mul_assign(&t);\n            }\n\n            assert!(non_residues_iterator.next().is_none());\n\n            r_poly.add_assign_scaled(&worker, &copy_permutation_z_in_monomial_form, &factor);\n\n            // - (a(z) + beta*perm_a + gamma)*()*()*z(z*omega) * beta * perm_d(X)\n\n            let mut factor = alpha_0;\n            factor.mul_assign(&beta_for_copy_permutation);\n            factor.mul_assign(&copy_permutation_z_at_z_omega);\n\n            for idx in 0..(num_state_polys - 1) {\n                let key = PolynomialInConstraint::from_id(PolyIdentifier::VariablesPolynomial(idx));\n                let wire_value = query_values_map.get(&key).ok_or(SynthesisError::AssignmentMissing)?;\n                let permutation_at_z = copy_permutation_queries[idx];\n                let mut t = permutation_at_z;\n\n                t.mul_assign(&beta_for_copy_permutation);\n                t.add_assign(&wire_value);\n                t.add_assign(&gamma_for_copy_permutation);\n\n                factor.mul_assign(&t);\n            }\n\n            let key = PolyIdentifier::PermutationPolynomial(num_state_polys - 1);\n            let last_permutation_poly_ref = monomials_storage.get_poly(key);\n\n            r_poly.sub_assign_scaled(&worker, last_permutation_poly_ref, &factor);\n\n            // + L_0(z) * Z(x)\n\n            let mut factor = evaluate_l0_at_point(required_domain_size as u64, z)?;\n            factor.mul_assign(&alpha_1);\n\n            r_poly.add_assign_scaled(&worker, &copy_permutation_z_in_monomial_form, &factor);\n        }\n\n        // lookup grand product linearization\n\n        // due to separate divisor it's not obvious if this is beneficial without some tricks\n        // like multiplication by (1 - L_{n-1}) or by (x - omega^{n-1})\n\n        // Z(x*omega)*(\\gamma*(1 + \\beta) + s(x) + \\beta * s(x*omega))) -\n        // Z(x) * (\\beta + 1) * (\\gamma + f(x)) * (\\gamma(1 + \\beta) + t(x) + \\beta * t(x*omega)) == 0\n        // check that (Z(x) - 1) * L_{0} == 0\n        // check that (Z(x) - expected) * L_{n-1} == 0, or (Z(x*omega) - expected)* L_{n-2} == 0\n\n        // f(x) does not need to be opened as it's made of table selector and witnesses\n        // if we pursue the strategy from the linearization of a copy-permutation argument\n        // then we leave something like s(x) from the Z(x*omega)*(\\gamma*(1 + \\beta) + s(x) + \\beta * s(x*omega))) term,\n        // and Z(x) from Z(x) * (\\beta + 1) * (\\gamma + f(x)) * (\\gamma(1 + \\beta) + t(x) + \\beta * t(x*omega)) term,\n        // with terms with lagrange polys as multipliers left intact\n\n        let lookup_queries = if let Some(lookup_z_poly) = lookup_z_poly_in_monomial_form.as_ref() {\n            let [alpha_0, alpha_1, alpha_2] = lookup_grand_product_alphas.expect(\"there must be powers of alpha for lookup permutation\");\n\n            let s_at_z_omega = lookup_data.as_ref().unwrap().s_poly_monomial.as_ref().unwrap().evaluate_at(&worker, z_omega);\n            let grand_product_at_z_omega = lookup_z_poly.evaluate_at(&worker, z_omega);\n            let t_at_z = lookup_data.as_ref().unwrap().t_poly_monomial.as_ref().unwrap().as_ref().evaluate_at(&worker, z);\n            let t_at_z_omega = lookup_data.as_ref().unwrap().t_poly_monomial.as_ref().unwrap().as_ref().evaluate_at(&worker, z_omega);\n            let selector_at_z = lookup_data.as_ref().unwrap().selector_poly_monomial.as_ref().unwrap().as_ref().evaluate_at(&worker, z);\n            let table_type_at_z = lookup_data.as_ref().unwrap().table_type_poly_monomial.as_ref().unwrap().as_ref().evaluate_at(&worker, z);\n\n            let l_0_at_z = evaluate_lagrange_poly_at_point(0, &domain, z)?;\n            let l_n_minus_one_at_z = evaluate_lagrange_poly_at_point(required_domain_size - 1, &domain, z)?;\n\n            let beta_for_lookup_permutation = beta_for_lookup.unwrap();\n            let gamma_for_lookup_permutation = gamma_for_lookup.unwrap();\n\n            let mut beta_plus_one = beta_for_lookup_permutation;\n            beta_plus_one.add_assign(&E::Fr::one());\n            let mut gamma_beta = gamma_for_lookup_permutation;\n            gamma_beta.mul_assign(&beta_plus_one);\n\n            // (Z(x*omega)*(\\gamma*(1 + \\beta) + s(x) + \\beta * s(x*omega))) -\n            // Z(x) * (\\beta + 1) * (\\gamma + f(x)) * (\\gamma(1 + \\beta) + t(x) + \\beta * t(x*omega)))*(X - omega^{n-1})\n\n            let last_omega = domain.generator.pow(&[(required_domain_size - 1) as u64]);\n            let mut z_minus_last_omega = z;\n            z_minus_last_omega.sub_assign(&last_omega);\n\n            // s(x) from the Z(x*omega)*(\\gamma*(1 + \\beta) + s(x) + \\beta * s(x*omega)))\n            let mut factor = grand_product_at_z_omega; // we do not need to account for additive terms\n            factor.mul_assign(&alpha_0);\n            factor.mul_assign(&z_minus_last_omega);\n\n            r_poly.add_assign_scaled(&worker, lookup_data.as_ref().unwrap().s_poly_monomial.as_ref().unwrap(), &factor);\n\n            // Z(x) from - alpha_0 * Z(x) * (\\beta + 1) * (\\gamma + f(x)) * (\\gamma(1 + \\beta) + t(x) + \\beta * t(x*omega))\n            // + alpha_1 * Z(x) * L_{0}(z) + alpha_2 * Z(x) * L_{n-1}(z)\n\n            // accumulate coefficient\n            let mut factor = t_at_z_omega;\n            factor.mul_assign(&beta_for_lookup_permutation);\n            factor.add_assign(&t_at_z);\n            factor.add_assign(&gamma_beta);\n\n            // (\\gamma + f(x))\n\n            let mut f_reconstructed = E::Fr::zero();\n            let mut current = E::Fr::one();\n            let eta = lookup_data.as_ref().unwrap().eta;\n            // a,b,c\n            for idx in 0..(num_state_polys - 1) {\n                let key = PolynomialInConstraint::from_id(PolyIdentifier::VariablesPolynomial(idx));\n                let mut value = *query_values_map.get(&key).ok_or(SynthesisError::AssignmentMissing)?;\n\n                value.mul_assign(&current);\n                f_reconstructed.add_assign(&value);\n\n                current.mul_assign(&eta);\n            }\n\n            // and table type\n            let mut t = table_type_at_z;\n            t.mul_assign(&current);\n            f_reconstructed.add_assign(&t);\n\n            f_reconstructed.mul_assign(&selector_at_z);\n            f_reconstructed.add_assign(&gamma_for_lookup_permutation);\n\n            // end of (\\gamma + f(x)) part\n\n            factor.mul_assign(&f_reconstructed);\n            factor.mul_assign(&beta_plus_one);\n            factor.negate(); // don't forget minus sign\n            factor.mul_assign(&alpha_0);\n\n            // Multiply by (z - omega^{n-1})\n\n            factor.mul_assign(&z_minus_last_omega);\n\n            // L_{0}(z) in front of Z(x)\n\n            let mut tmp = l_0_at_z;\n            tmp.mul_assign(&alpha_1);\n            factor.add_assign(&tmp);\n\n            // L_{n-1}(z) in front of Z(x)\n\n            let mut tmp = l_n_minus_one_at_z;\n            tmp.mul_assign(&alpha_2);\n            factor.add_assign(&tmp);\n\n            r_poly.add_assign_scaled(&worker, lookup_z_poly, &factor);\n\n            let query = LookupQuery::<E> {\n                s_at_z_omega,\n                grand_product_at_z_omega,\n                t_at_z,\n                t_at_z_omega,\n                selector_at_z,\n                table_type_at_z,\n            };\n\n            Some(query)\n        } else {\n            None\n        };\n\n        if let Some(queries) = lookup_queries.as_ref() {\n            // first commit values at z, and then at z*omega\n            transcript.commit_field_element(&queries.t_at_z);\n            transcript.commit_field_element(&queries.selector_at_z);\n            transcript.commit_field_element(&queries.table_type_at_z);\n\n            // now at z*omega\n            transcript.commit_field_element(&queries.s_at_z_omega);\n            transcript.commit_field_element(&queries.grand_product_at_z_omega);\n            transcript.commit_field_element(&queries.t_at_z_omega);\n\n            proof.lookup_s_poly_opening_at_z_omega = Some(queries.s_at_z_omega);\n            proof.lookup_grand_product_opening_at_z_omega = Some(queries.grand_product_at_z_omega);\n            proof.lookup_t_poly_opening_at_z = Some(queries.t_at_z);\n            proof.lookup_t_poly_opening_at_z_omega = Some(queries.t_at_z_omega);\n            proof.lookup_selector_poly_opening_at_z = Some(queries.selector_at_z);\n            proof.lookup_table_type_poly_opening_at_z = Some(queries.table_type_at_z);\n        }\n\n        let linearization_at_z = r_poly.evaluate_at(&worker, z);\n\n        transcript.commit_field_element(&linearization_at_z);\n        proof.linearization_poly_opening_at_z = linearization_at_z;\n\n        // linearization is done, now perform sanity check\n        // this is effectively a verification procedure\n\n        {\n            let vanishing_at_z = evaluate_vanishing_for_size(&z, required_domain_size as u64);\n\n            // first let's aggregate gates\n\n            let mut t_num_on_full_domain = E::Fr::zero();\n\n            let challenges_slice = &powers_of_alpha_for_gates[..];\n\n            let mut all_gates = self.sorted_gates.clone();\n\n            // we've suffered and linearization polynomial captures all the gates except the public input!\n\n            {\n                let mut tmp = linearization_at_z;\n                // add input values\n\n                let gate = all_gates.drain(0..1).into_iter().next().unwrap();\n                assert!(gate.benefits_from_linearization(), \"main gate is expected to benefit from linearization!\");\n                assert!(<Self as ConstraintSystem<E>>::MainGate::default().into_internal() == gate);\n                let gate = <Self as ConstraintSystem<E>>::MainGate::default();\n                let num_challenges = gate.num_quotient_terms();\n                let (for_gate, _) = challenges_slice.split_at(num_challenges);\n\n                let input_values = self.input_assingments.clone();\n\n                let mut inputs_term = gate.add_inputs_into_quotient(required_domain_size, &input_values, z, for_gate)?;\n\n                if num_different_gates > 1 {\n                    let selector_value = selector_values[0];\n                    inputs_term.mul_assign(&selector_value);\n                }\n\n                tmp.add_assign(&inputs_term);\n\n                t_num_on_full_domain.add_assign(&tmp);\n            }\n\n            // now aggregate leftovers from grand product for copy permutation\n            {\n                // - alpha_0 * (a + perm(z) * beta + gamma)*()*(d + gamma) * z(z*omega)\n                let [alpha_0, alpha_1] = copy_grand_product_alphas.expect(\"there must be powers of alpha for copy permutation\");\n\n                let mut factor = alpha_0;\n                factor.mul_assign(&copy_permutation_z_at_z_omega);\n\n                for idx in 0..(num_state_polys - 1) {\n                    let key = PolynomialInConstraint::from_id(PolyIdentifier::VariablesPolynomial(idx));\n                    let wire_value = query_values_map.get(&key).ok_or(SynthesisError::AssignmentMissing)?;\n                    let permutation_at_z = copy_permutation_queries[idx];\n                    let mut t = permutation_at_z;\n\n                    t.mul_assign(&beta_for_copy_permutation);\n                    t.add_assign(&wire_value);\n                    t.add_assign(&gamma_for_copy_permutation);\n\n                    factor.mul_assign(&t);\n                }\n\n                let key = PolynomialInConstraint::from_id(PolyIdentifier::VariablesPolynomial(num_state_polys - 1));\n                let mut tmp = *query_values_map.get(&key).ok_or(SynthesisError::AssignmentMissing)?;\n                tmp.add_assign(&gamma_for_copy_permutation);\n\n                factor.mul_assign(&tmp);\n\n                t_num_on_full_domain.sub_assign(&factor);\n\n                // - L_0(z) * alpha_1\n\n                let mut l_0_at_z = evaluate_l0_at_point(required_domain_size as u64, z)?;\n                l_0_at_z.mul_assign(&alpha_1);\n\n                t_num_on_full_domain.sub_assign(&l_0_at_z);\n            }\n\n            // and if exists - grand product for lookup permutation\n\n            {\n                if lookup_queries.is_some() {\n                    let [alpha_0, alpha_1, alpha_2] = lookup_grand_product_alphas.expect(\"there must be powers of alpha for lookup permutation\");\n\n                    let lookup_queries = lookup_queries.clone().expect(\"lookup queries must be made\");\n\n                    let beta_for_lookup_permutation = beta_for_lookup.unwrap();\n                    let gamma_for_lookup_permutation = gamma_for_lookup.unwrap();\n                    let mut beta_plus_one = beta_for_lookup_permutation;\n                    beta_plus_one.add_assign(&E::Fr::one());\n                    let mut gamma_beta = gamma_for_lookup_permutation;\n                    gamma_beta.mul_assign(&beta_plus_one);\n\n                    let expected = gamma_beta.pow([(required_domain_size - 1) as u64]);\n\n                    // in a linearization we've taken terms:\n                    // - s(x) from the alpha_0 * Z(x*omega)*(\\gamma*(1 + \\beta) + s(x) + \\beta * s(x*omega)))\n                    // - and Z(x) from - alpha_0 * Z(x) * (\\beta + 1) * (\\gamma + f(x)) * (\\gamma(1 + \\beta) + t(x) + \\beta * t(x*omega)) (term in full) +\n                    // + alpha_1 * (Z(x) - 1) * L_{0}(z) + alpha_2 * (Z(x) - expected) * L_{n-1}(z)\n\n                    // first make alpha_0 * Z(x*omega)*(\\gamma*(1 + \\beta) + \\beta * s(x*omega)))\n\n                    let mut tmp = lookup_queries.s_at_z_omega;\n                    tmp.mul_assign(&beta_for_lookup_permutation);\n                    tmp.add_assign(&gamma_beta);\n                    tmp.mul_assign(&lookup_queries.grand_product_at_z_omega);\n                    tmp.mul_assign(&alpha_0);\n\n                    // (z - omega^{n-1}) for this part\n                    let last_omega = domain.generator.pow(&[(required_domain_size - 1) as u64]);\n                    let mut z_minus_last_omega = z;\n                    z_minus_last_omega.sub_assign(&last_omega);\n\n                    tmp.mul_assign(&z_minus_last_omega);\n\n                    t_num_on_full_domain.add_assign(&tmp);\n\n                    // // - alpha_1 * L_{0}(z)\n\n                    let mut l_0_at_z = evaluate_l0_at_point(required_domain_size as u64, z)?;\n                    l_0_at_z.mul_assign(&alpha_1);\n\n                    t_num_on_full_domain.sub_assign(&l_0_at_z);\n\n                    // // - alpha_2 * expected L_{n-1}(z)\n\n                    let mut l_n_minus_one_at_z = evaluate_lagrange_poly_at_point(required_domain_size - 1, &domain, z)?;\n                    l_n_minus_one_at_z.mul_assign(&expected);\n                    l_n_minus_one_at_z.mul_assign(&alpha_2);\n\n                    t_num_on_full_domain.sub_assign(&l_n_minus_one_at_z);\n                }\n            }\n\n            let mut lhs = quotient_at_z;\n            lhs.mul_assign(&vanishing_at_z);\n\n            let rhs = t_num_on_full_domain;\n\n            if lhs != rhs {\n                dbg!(\"Circuit is not satisfied\");\n                return Err(SynthesisError::Unsatisfiable);\n            }\n        }\n\n        let v = transcript.get_challenge();\n\n        // now construct two polynomials that are opened at z and z*omega\n\n        let mut multiopening_challenge = E::Fr::one();\n\n        let mut poly_to_divide_at_z = t_poly_parts.drain(0..1).collect::<Vec<_>>().pop().unwrap();\n        let z_in_domain_size = z.pow(&[required_domain_size as u64]);\n        let mut power_of_z = z_in_domain_size;\n        for t_part in t_poly_parts.into_iter() {\n            poly_to_divide_at_z.add_assign_scaled(&worker, &t_part, &power_of_z);\n            power_of_z.mul_assign(&z_in_domain_size);\n        }\n\n        // linearization polynomial\n        multiopening_challenge.mul_assign(&v);\n        poly_to_divide_at_z.add_assign_scaled(&worker, &r_poly, &multiopening_challenge);\n\n        debug_assert_eq!(multiopening_challenge, v.pow(&[1 as u64]));\n\n        // now proceed over all queries\n\n        const THIS_STEP_DILATION: usize = 0;\n        for id in queries_with_linearization.state_polys[THIS_STEP_DILATION].iter() {\n            multiopening_challenge.mul_assign(&v);\n            let poly_ref = monomials_storage.get_poly(*id);\n            poly_to_divide_at_z.add_assign_scaled(&worker, poly_ref, &multiopening_challenge);\n        }\n\n        for id in queries_with_linearization.witness_polys[THIS_STEP_DILATION].iter() {\n            multiopening_challenge.mul_assign(&v);\n            let poly_ref = monomials_storage.get_poly(*id);\n            poly_to_divide_at_z.add_assign_scaled(&worker, poly_ref, &multiopening_challenge);\n        }\n\n        for queries in queries_with_linearization.gate_setup_polys.iter() {\n            for id in queries[THIS_STEP_DILATION].iter() {\n                multiopening_challenge.mul_assign(&v);\n                let poly_ref = monomials_storage.get_poly(*id);\n                poly_to_divide_at_z.add_assign_scaled(&worker, poly_ref, &multiopening_challenge);\n            }\n        }\n\n        // also open selectors at z\n        for s in queries_with_linearization.gate_selectors.iter() {\n            multiopening_challenge.mul_assign(&v);\n            let key = PolyIdentifier::GateSelector(s.name());\n            let poly_ref = monomials_storage.get_poly(key);\n            poly_to_divide_at_z.add_assign_scaled(&worker, poly_ref, &multiopening_challenge);\n        }\n\n        for idx in 0..(num_state_polys - 1) {\n            multiopening_challenge.mul_assign(&v);\n            let key = PolyIdentifier::PermutationPolynomial(idx);\n            let poly_ref = monomials_storage.get_poly(key);\n            poly_to_divide_at_z.add_assign_scaled(&worker, poly_ref, &multiopening_challenge);\n        }\n\n        // if lookup is present - add it\n        if let Some(data) = lookup_data.as_ref() {\n            // we need to add t(x), selector(x) and table type(x)\n            multiopening_challenge.mul_assign(&v);\n            let poly_ref = data.t_poly_monomial.as_ref().unwrap().as_ref();\n            poly_to_divide_at_z.add_assign_scaled(&worker, poly_ref, &multiopening_challenge);\n\n            multiopening_challenge.mul_assign(&v);\n            let poly_ref = data.selector_poly_monomial.as_ref().unwrap().as_ref();\n            poly_to_divide_at_z.add_assign_scaled(&worker, poly_ref, &multiopening_challenge);\n\n            multiopening_challenge.mul_assign(&v);\n            let poly_ref = data.table_type_poly_monomial.as_ref().unwrap().as_ref();\n            poly_to_divide_at_z.add_assign_scaled(&worker, poly_ref, &multiopening_challenge);\n        }\n\n        // now proceed at z*omega\n        multiopening_challenge.mul_assign(&v);\n        let mut poly_to_divide_at_z_omega = copy_permutation_z_in_monomial_form;\n        poly_to_divide_at_z_omega.scale(&worker, multiopening_challenge);\n\n        const NEXT_STEP_DILATION: usize = 1;\n\n        for id in queries_with_linearization.state_polys[NEXT_STEP_DILATION].iter() {\n            multiopening_challenge.mul_assign(&v);\n            let poly_ref = monomials_storage.get_poly(*id);\n            poly_to_divide_at_z_omega.add_assign_scaled(&worker, poly_ref, &multiopening_challenge);\n        }\n\n        for id in queries_with_linearization.witness_polys[NEXT_STEP_DILATION].iter() {\n            multiopening_challenge.mul_assign(&v);\n            let poly_ref = monomials_storage.get_poly(*id);\n            poly_to_divide_at_z_omega.add_assign_scaled(&worker, poly_ref, &multiopening_challenge);\n        }\n\n        for queries in queries_with_linearization.gate_setup_polys.iter() {\n            for id in queries[NEXT_STEP_DILATION].iter() {\n                multiopening_challenge.mul_assign(&v);\n                let poly_ref = monomials_storage.get_poly(*id);\n                poly_to_divide_at_z_omega.add_assign_scaled(&worker, poly_ref, &multiopening_challenge);\n            }\n        }\n\n        if let Some(data) = lookup_data {\n            // we need to add s(x), grand_product(x) and t(x)\n            multiopening_challenge.mul_assign(&v);\n            let poly_ref = data.s_poly_monomial.as_ref().unwrap();\n            poly_to_divide_at_z_omega.add_assign_scaled(&worker, poly_ref, &multiopening_challenge);\n\n            multiopening_challenge.mul_assign(&v);\n            let poly_ref = lookup_z_poly_in_monomial_form.as_ref().unwrap();\n            poly_to_divide_at_z_omega.add_assign_scaled(&worker, poly_ref, &multiopening_challenge);\n\n            multiopening_challenge.mul_assign(&v);\n            let poly_ref = data.t_poly_monomial.as_ref().unwrap().as_ref();\n            poly_to_divide_at_z_omega.add_assign_scaled(&worker, poly_ref, &multiopening_challenge);\n        }\n\n        // division in monomial form is sequential, so we parallelize the divisions\n\n        let mut z_by_omega = z;\n        z_by_omega.mul_assign(&domain.generator);\n\n        let mut polys = vec![(poly_to_divide_at_z, z), (poly_to_divide_at_z_omega, z_by_omega)];\n\n        worker.scope(polys.len(), |scope, chunk| {\n            for p in polys.chunks_mut(chunk) {\n                scope.spawn(move |_| {\n                    let (poly, at) = &p[0];\n                    let at = *at;\n                    let result = divide_single::<E>(poly.as_ref(), at);\n                    p[0] = (Polynomial::from_coeffs(result).unwrap(), at);\n                });\n            }\n        });\n\n        let open_at_z_omega = polys.pop().unwrap().0;\n        let open_at_z = polys.pop().unwrap().0;\n\n        let opening_at_z = commit_using_monomials(&open_at_z, &mon_crs, &worker)?;\n\n        let opening_at_z_omega = commit_using_monomials(&open_at_z_omega, &mon_crs, &worker)?;\n\n        proof.opening_proof_at_z = opening_at_z;\n        proof.opening_proof_at_z_omega = opening_at_z_omega;\n\n        Ok(proof)\n    }"
}