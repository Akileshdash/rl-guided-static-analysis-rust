{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<socket::io::tx::Tx<T> as s2n_quic_core::io::tx::Tx>::queue`",
    "file": "s2n-quic-platform-0.63.0/src/socket/io/tx.rs",
    "start_line": 81,
    "start_col": 5,
    "end_line": 139,
    "end_col": 6,
    "code_snippet": "fn queue<F: FnOnce(&mut Self::Queue)>(&mut self, f: F) {\n        let this: &'static mut Self = unsafe {\n            // Safety: As noted in the [transmute examples](https://doc.rust-lang.org/std/mem/fn.transmute.html#examples)\n            // it can be used to temporarily extend the lifetime of a reference. In this case, we\n            // don't want to use GATs until the MSRV is >=1.65.0, which means `Self::Queue` is not\n            // allowed to take generic lifetimes.\n            //\n            // We are left with using a `'static` lifetime here and encapsulating it in a private\n            // field. The `Self::Queue` struct is then borrowed for the lifetime of the `F`\n            // function. This will prevent the value from escaping beyond the lifetime of `&mut\n            // self`.\n            //\n            // See https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=9a32abe85c666f36fb2ec86496cc41b4\n            //\n            // Once https://github.com/aws/s2n-quic/issues/1742 is resolved this code can go away\n            core::mem::transmute(self)\n        };\n\n        let mut capacity = 0;\n        let mut first_with_free_slots = None;\n        for (idx, channel) in this.channels.iter_mut().enumerate() {\n            // try to make one more effort to acquire capacity for sending\n            let count = channel.acquire(u32::MAX) as usize;\n\n            if count > 0 && first_with_free_slots.is_none() {\n                // find the first channel that had capacity\n                first_with_free_slots = Some(idx);\n            }\n\n            capacity += count;\n        }\n\n        // mark that we're still full so we need to poll and wake up next iteration\n        this.is_full = capacity == 0;\n\n        // start with the first queue that has free slots, otherwise set the index to the length,\n        // which will return an AtCapacity error immediately.\n        let channel_index = first_with_free_slots.unwrap_or(this.channels.len());\n\n        // query the maximum number of segments we can fill at this point in time\n        //\n        // NOTE: this value could be lowered in the case the TX task encounters an error with GSO\n        //       so we do need to query it each iteration.\n        let max_segments = this.gso.max_segments();\n\n        let mut queue = TxQueue {\n            channels: &mut this.channels,\n            channel_index,\n            message_index: 0,\n            pending_release: 0,\n            gso_segment: None,\n            max_segments,\n            max_mtu: this.max_mtu,\n            capacity,\n            is_full: &mut this.is_full,\n        };\n\n        f(&mut queue);\n    }"
}