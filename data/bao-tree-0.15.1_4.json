{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `iter::ResponseIterInner::try_new_or_recover`",
    "file": "bao-tree-0.15.1//usagers4/u139091/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/self_cell-1.0.3/src/lib.rs",
    "start_line": 449,
    "start_col": 9,
    "end_line": 506,
    "end_col": 10,
    "code_snippet": "$Vis fn try_new_or_recover<Err>(\n            owner: $Owner,\n            dependent_builder:\n                impl for<'_q> ::core::ops::FnOnce(&'_q $Owner) -> ::core::result::Result<$Dependent<'_q>, Err>\n        ) -> ::core::result::Result<Self, ($Owner, Err)> {\n            use ::core::ptr::NonNull;\n\n            unsafe {\n                // See fn new for more explanation.\n\n                type JoinedCell<'_q $(, $OwnerLifetime)?> =\n                    $crate::unsafe_self_cell::JoinedCell<$Owner, $Dependent<'_q>>;\n\n                let layout = $crate::alloc::alloc::Layout::new::<JoinedCell>();\n                assert!(layout.size() != 0);\n\n                let joined_void_ptr = NonNull::new($crate::alloc::alloc::alloc(layout)).unwrap();\n\n                let mut joined_ptr = joined_void_ptr.cast::<JoinedCell>();\n\n                let (owner_ptr, dependent_ptr) = JoinedCell::_field_pointers(joined_ptr.as_ptr());\n\n                // Move owner into newly allocated space.\n                owner_ptr.write(owner);\n\n                // Drop guard that cleans up should building the dependent panic.\n                let mut drop_guard =\n                    $crate::unsafe_self_cell::OwnerAndCellDropGuard::new(joined_ptr);\n\n                match dependent_builder(&*owner_ptr) {\n                    ::core::result::Result::Ok(dependent) => {\n                        dependent_ptr.write(dependent);\n                        ::core::mem::forget(drop_guard);\n\n                        ::core::result::Result::Ok(Self {\n                            unsafe_self_cell: $crate::unsafe_self_cell::UnsafeSelfCell::new(\n                                joined_void_ptr,\n                            ),\n                            $(owner_marker: $crate::_covariant_owner_marker_ctor!($OwnerLifetime) ,)?\n                        })\n                    }\n                    ::core::result::Result::Err(err) => {\n                        // In contrast to into_owner ptr::read, here no dependent\n                        // ever existed in this function and so we are sure its\n                        // drop impl can't access owner after the read.\n                        // And err can't return a reference to owner.\n                        let owner_on_err = ::core::ptr::read(owner_ptr);\n\n                        // Allowing drop_guard to finish would let it double free owner.\n                        // So we dealloc the JoinedCell here manually.\n                        ::core::mem::forget(drop_guard);\n                        $crate::alloc::alloc::dealloc(joined_void_ptr.as_ptr(), layout);\n\n                        ::core::result::Result::Err((owner_on_err, err))\n                    }\n                }\n            }\n        }"
}