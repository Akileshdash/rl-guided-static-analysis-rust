{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `conversions::sse::t_lut3_to_3_q0_15::TransformLut3x3SseQ0_15::<T, U, SRC_LAYOUT, DST_LAYOUT, GRID_SIZE, BIT_DEPTH, BINS, BARYCENTRIC_BINS>::transform_chunk`",
    "file": "moxcms-0.7.3/src/conversions/sse/t_lut3_to_3_q0_15.rs",
    "start_line": 87,
    "start_col": 5,
    "end_line": 151,
    "end_col": 6,
    "code_snippet": "unsafe fn transform_chunk<'b, Interpolator: SseMdInterpolationQ0_15<'b, GRID_SIZE>>(\n        &'b self,\n        src: &[T],\n        dst: &mut [T],\n    ) {\n        unsafe {\n            let src_cn = Layout::from(SRC_LAYOUT);\n            let src_channels = src_cn.channels();\n\n            let dst_cn = Layout::from(DST_LAYOUT);\n            let dst_channels = dst_cn.channels();\n\n            let f_value_scale = _mm_set1_ps(1. / ((1 << 14i32) - 1) as f32);\n            let max_value = ((1u32 << BIT_DEPTH) - 1).as_();\n            let v_max_scale = if T::FINITE {\n                _mm_set1_epi16(((1i32 << BIT_DEPTH) - 1) as i16)\n            } else {\n                _mm_set1_epi16(((1i32 << 14i32) - 1) as i16)\n            };\n\n            for (src, dst) in src\n                .chunks_exact(src_channels)\n                .zip(dst.chunks_exact_mut(dst_channels))\n            {\n                let x = <() as LutBarycentricReduction<T, U>>::reduce::<BIT_DEPTH, BARYCENTRIC_BINS>(\n                    src[src_cn.r_i()],\n                );\n                let y = <() as LutBarycentricReduction<T, U>>::reduce::<BIT_DEPTH, BARYCENTRIC_BINS>(\n                    src[src_cn.g_i()],\n                );\n                let z = <() as LutBarycentricReduction<T, U>>::reduce::<BIT_DEPTH, BARYCENTRIC_BINS>(\n                    src[src_cn.b_i()],\n                );\n\n                let a = if src_channels == 4 {\n                    src[src_cn.a_i()]\n                } else {\n                    max_value\n                };\n\n                let tetrahedral = Interpolator::new(&self.lut);\n                let v = tetrahedral.inter3_sse(x, y, z, &self.weights);\n                if T::FINITE {\n                    let mut o = _mm_max_epi16(v.v, _mm_setzero_si128());\n                    o = _mm_min_epi16(o, v_max_scale);\n                    let x = _mm_extract_epi16::<0>(o);\n                    let y = _mm_extract_epi16::<1>(o);\n                    let z = _mm_extract_epi16::<2>(o);\n\n                    dst[dst_cn.r_i()] = (x as u32).as_();\n                    dst[dst_cn.g_i()] = (y as u32).as_();\n                    dst[dst_cn.b_i()] = (z as u32).as_();\n                } else {\n                    let mut r = _mm_cvtepi32_ps(_mm_cvtepi16_epi32(v.v));\n                    r = _mm_mul_ps(r, f_value_scale);\n                    dst[dst_cn.r_i()] = f32::from_bits(_mm_extract_ps::<0>(r) as u32).as_();\n                    dst[dst_cn.g_i()] = f32::from_bits(_mm_extract_ps::<1>(r) as u32).as_();\n                    dst[dst_cn.b_i()] = f32::from_bits(_mm_extract_ps::<2>(r) as u32).as_();\n                }\n                if dst_channels == 4 {\n                    dst[dst_cn.a_i()] = a;\n                }\n            }\n        }\n    }"
}