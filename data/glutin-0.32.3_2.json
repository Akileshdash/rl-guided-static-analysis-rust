{
    "level": "Warning",
    "analyzer": "UnsafeDestructor",
    "op_type": null,
    "description": "unsafe block detected in drop",
    "file": "glutin-0.32.3/src/api/egl/display.rs",
    "start_line": 695,
    "start_col": 1,
    "end_line": 695,
    "end_col": 27,
    "code_snippet": "impl Drop for DisplayInner {\n    fn drop(&mut self) {\n        if self.uses_display_reference() {\n            unsafe {\n                self.egl.Terminate(*self.raw);\n            }\n        }\n\n        // We cannot call safely call `eglTerminate`.\n        //\n        // This may sound confusing, but this is a result of how EGL works:\n        //\n        // From the documentation of `eglGetDisplay`:\n        // > Multiple calls made to eglGetDisplay with the same display_id will\n        // > return the same EGLDisplay handle.\n        //\n        // And from the documentation of `eglGetPlatformDisplay`:\n        // > Multiple calls made to eglGetPlatformDisplay with the same\n        // > parameters will return the same\n        // > EGLDisplay handle.\n        //\n        // Furthermore the following is done when a display is initialized:\n        // > Initializing an already initialized EGL display connection has no\n        // > effect besides returning the\n        // > version numbers.\n        //\n        // Terminating a display connection and then creating a new display\n        // connection will reference the same display. This effectively\n        // makes an EGLDisplay a singleton for the specified display_id or\n        // platform and native display.\n        //\n        // Because EGLDisplay is a singleton, this makes the following sequence\n        // problematic:\n        //\n        // 1. A display is created for a platform\n        // 2. A second display is created for the same platform\n        // 3. The first display is dropped, resulting in eglTerminate being\n        // called.\n        // 4. A context created from the second display is made\n        // current, but it has been terminated and returns an EGL_BAD_DISPLAY\n        // error.\n        //\n        // But wait? This causes a memory leak!\n        //\n        // Yes it does indeed result in a memory leak since we do not terminate\n        // displays on drop. For most applications there is only ever a\n        // single EGLDisplay for the lifetime of the application. The cost\n        // of not dropping the display is negligible because the display will\n        // probably be destroyed on app termination and we can let the\n        // operating system deal with tearing down EGL instead.\n    }\n}"
}