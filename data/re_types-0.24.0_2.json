{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<datatypes::_datatypes::annotation_info::AnnotationInfo as re_types_core::Loggable>::to_arrow_opt`",
    "file": "re_types-0.24.0/src/datatypes/../datatypes/annotation_info.rs",
    "start_line": 52,
    "start_col": 5,
    "end_line": 164,
    "end_col": 6,
    "code_snippet": "fn to_arrow_opt<'a>(\n        data: impl IntoIterator<Item = Option<impl Into<::std::borrow::Cow<'a, Self>>>>,\n    ) -> SerializationResult<arrow::array::ArrayRef>\n    where\n        Self: Clone + 'a,\n    {\n        #![allow(clippy::wildcard_imports)]\n        #![allow(clippy::manual_is_variant_and)]\n        use ::re_types_core::{arrow_helpers::as_array_ref, Loggable as _, ResultExt as _};\n        use arrow::{array::*, buffer::*, datatypes::*};\n        Ok({\n            let fields = Fields::from(vec![\n                Field::new(\"id\", DataType::UInt16, false),\n                Field::new(\"label\", <crate::datatypes::Utf8>::arrow_datatype(), true),\n                Field::new(\"color\", <crate::datatypes::Rgba32>::arrow_datatype(), true),\n            ]);\n            let (somes, data): (Vec<_>, Vec<_>) = data\n                .into_iter()\n                .map(|datum| {\n                    let datum: Option<::std::borrow::Cow<'a, Self>> = datum.map(Into::into);\n                    (datum.is_some(), datum)\n                })\n                .unzip();\n            let validity: Option<arrow::buffer::NullBuffer> = {\n                let any_nones = somes.iter().any(|some| !*some);\n                any_nones.then(|| somes.into())\n            };\n            as_array_ref(StructArray::new(\n                fields,\n                vec![\n                    {\n                        let (somes, id): (Vec<_>, Vec<_>) = data\n                            .iter()\n                            .map(|datum| {\n                                let datum = datum.as_ref().map(|datum| datum.id.clone());\n                                (datum.is_some(), datum)\n                            })\n                            .unzip();\n                        let id_validity: Option<arrow::buffer::NullBuffer> = {\n                            let any_nones = somes.iter().any(|some| !*some);\n                            any_nones.then(|| somes.into())\n                        };\n                        as_array_ref(PrimitiveArray::<UInt16Type>::new(\n                            ScalarBuffer::from(\n                                id.into_iter()\n                                    .map(|v| v.unwrap_or_default())\n                                    .collect::<Vec<_>>(),\n                            ),\n                            id_validity,\n                        ))\n                    },\n                    {\n                        let (somes, label): (Vec<_>, Vec<_>) = data\n                            .iter()\n                            .map(|datum| {\n                                let datum =\n                                    datum.as_ref().map(|datum| datum.label.clone()).flatten();\n                                (datum.is_some(), datum)\n                            })\n                            .unzip();\n                        let label_validity: Option<arrow::buffer::NullBuffer> = {\n                            let any_nones = somes.iter().any(|some| !*some);\n                            any_nones.then(|| somes.into())\n                        };\n                        {\n                            let offsets = arrow::buffer::OffsetBuffer::<i32>::from_lengths(\n                                label.iter().map(|opt| {\n                                    opt.as_ref().map(|datum| datum.0.len()).unwrap_or_default()\n                                }),\n                            );\n                            #[allow(clippy::unwrap_used)]\n                            let capacity = offsets.last().copied().unwrap() as usize;\n                            let mut buffer_builder =\n                                arrow::array::builder::BufferBuilder::<u8>::new(capacity);\n                            for data in label.iter().flatten() {\n                                buffer_builder.append_slice(data.0.as_bytes());\n                            }\n                            let inner_data: arrow::buffer::Buffer = buffer_builder.finish();\n\n                            #[allow(unsafe_code, clippy::undocumented_unsafe_blocks)]\n                            as_array_ref(unsafe {\n                                StringArray::new_unchecked(offsets, inner_data, label_validity)\n                            })\n                        }\n                    },\n                    {\n                        let (somes, color): (Vec<_>, Vec<_>) = data\n                            .iter()\n                            .map(|datum| {\n                                let datum =\n                                    datum.as_ref().map(|datum| datum.color.clone()).flatten();\n                                (datum.is_some(), datum)\n                            })\n                            .unzip();\n                        let color_validity: Option<arrow::buffer::NullBuffer> = {\n                            let any_nones = somes.iter().any(|some| !*some);\n                            any_nones.then(|| somes.into())\n                        };\n                        as_array_ref(PrimitiveArray::<UInt32Type>::new(\n                            ScalarBuffer::from(\n                                color\n                                    .into_iter()\n                                    .map(|datum| datum.map(|datum| datum.0).unwrap_or_default())\n                                    .collect::<Vec<_>>(),\n                            ),\n                            color_validity,\n                        ))\n                    },\n                ],\n                validity,\n            ))\n        })\n    }"
}