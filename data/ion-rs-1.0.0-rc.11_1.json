{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `lazy::streaming_raw_reader::StreamingRawReader::<Encoding, Input>::read_next`",
    "file": "ion-rs-1.0.0-rc.11/src/lazy/streaming_raw_reader.rs",
    "start_line": 123,
    "start_col": 5,
    "end_line": 246,
    "end_col": 6,
    "code_snippet": "fn read_next<'top>(\n        &'top mut self,\n        context: EncodingContextRef<'top>,\n        is_peek: bool,\n    ) -> IonResult<LazyRawStreamItem<'top, Encoding>> {\n        // If the input is a stream, we assume there may be more data available.\n        // If it's a fixed slice, we know it's already complete.\n        let mut input_source_exhausted = !Input::DataSource::IS_STREAMING;\n        loop {\n            // If the input buffer is empty, try to pull more data from the source before proceeding.\n            // It's important that we do this _before_ reading from the buffer; any item returned\n            // from a successful `slice_reader.next()` will hold a reference to the buffer. We cannot\n            // modify it once we have that item.\n            if self.buffer_is_empty() {\n                self.pull_more_data_from_source()?;\n            }\n\n            // We're going to try to read a lazy value from the available input. If we\n            // succeed, we'll return it. If the data is incomplete, we'll return to the top\n            // of the loop. Conditionally returning a value in a loop is the borrow checker's\n            // Achilles' heel (see comment on the `StreamingRawReader` type), so we use an\n            // unsafe access to get a reference to the available bytes.\n            //\n            // SAFETY: If `self.input` needs to be refilled later on, `available_bytes` MUST NOT be\n            //         read from in the same loop iteration afterward, since it may refer to a buffer\n            //         that has been dropped.\n            let available_bytes = unsafe { &*self.input.get() }.buffer();\n            let state = RawReaderState::new(\n                available_bytes,\n                self.stream_position,\n                input_source_exhausted,\n                self.encoding(),\n            );\n\n            // Construct a new raw reader picking up from where the StreamingRawReader left off.\n            let mut slice_reader =\n                <Encoding::Reader<'top> as LazyRawReader<'top, Encoding>>::resume(context, state);\n            let starting_position = slice_reader.position();\n            let old_encoding = slice_reader.encoding();\n\n            let result = slice_reader.next();\n\n            let new_encoding = slice_reader.encoding();\n            let end_position = slice_reader.position();\n\n            let bytes_read = end_position - starting_position;\n\n            // If we ran out of data before we could get a result...\n            if matches!(\n                result,\n                Err(IonError::Incomplete(_)) | Ok(LazyRawStreamItem::<Encoding>::EndOfStream(_))\n            ) {\n                if input_source_exhausted {\n                    // There's no more data, so the result is final.\n                } else {\n                    // ...more data may be available, so try to pull from the data source.\n                    if self.pull_more_data_from_source()? == 0 {\n                        input_source_exhausted = true;\n                    }\n                    continue;\n                }\n            } else if let Ok(ref item) = result {\n                // We have successfully read something from the buffer.\n                //\n                // In binary encodings, stream items contain enough data for the reader to tell\n                // whether they are complete.\n                //\n                // In text encodings, it's possible for the buffer to end with data that looks like\n                // a complete item but is not. The only way to be certain is to try to read again\n                // from the input source to confirm there's no more data. Consider the following\n                // examples in which Ion is being pulled from a `File` into a `Vec<u8>`:\n                //\n                //       foo /* comment */   ::bar::baz::1000\n                //       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                //         buffer contents   remaining in File\n                //\n                //                     $ion _1_0\n                //       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                //         buffer contents   remaining in File\n                //\n                //                       75 1.20\n                //       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                //         buffer contents   remaining in File\n                //\n                // To avoid this, we perform a final check for text readers who have emptied their\n                // buffer: we do not consider the item complete unless the input source is exhausted.\n                if old_encoding.is_text()\n                    && bytes_read == available_bytes.len()\n                    && !input_source_exhausted\n                {\n                    use crate::lazy::raw_stream_item::RawStreamItem::*;\n                    match item {\n                        // Text containers and e-expressions have closing delimiters that allow us\n                        // to tell that they're complete.\n                        Value(v) if v.ion_type().is_container() => {}\n                        EExp(_eexp) => {}\n                        // IVMs (which look like symbols), scalar values, and the end of the\n                        // stream are all cases where the reader looking at a fixed slice of the\n                        // buffer may reach the wrong conclusion.\n                        _ => {\n                            // Try to pull more data from the input source.\n                            if self.pull_more_data_from_source()? == 0 {\n                                input_source_exhausted = true;\n                            }\n                            continue;\n                        }\n                    }\n                }\n\n                // If this isn't just a peek, update our state to remember what we've already read.\n                if !is_peek {\n                    // Mark those input bytes as having been consumed so they are not read again.\n                    self.input.get_mut().consume(bytes_read);\n                    // Update the streaming reader's position to reflect the number of bytes we\n                    // just read.\n                    self.stream_position = end_position;\n                    // If the item read was an IVM, this will be a new value.\n                    self.detected_encoding = new_encoding;\n                }\n            }\n\n            return result;\n        }\n    }"
}