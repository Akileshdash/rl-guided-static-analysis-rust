{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `compute::concatenate::concatenate_view`",
    "file": "polars-arrow-0.49.1/src/compute/concatenate.rs",
    "start_line": 202,
    "start_col": 1,
    "end_line": 346,
    "end_col": 2,
    "code_snippet": "fn concatenate_view<V: ViewType + ?Sized, A: AsRef<dyn Array>>(\n    arrays: &[A],\n) -> BinaryViewArrayGeneric<V> {\n    let dtype = arrays[0].as_ref().dtype().clone();\n    let (total_len, null_count) = len_null_count(arrays);\n    if total_len == 0 {\n        return BinaryViewArrayGeneric::new_empty(dtype);\n    }\n    let validity = concatenate_validities_with_len_null_count(arrays, total_len, null_count);\n\n    let first_arr: &BinaryViewArrayGeneric<V> = arrays[0].as_ref().as_any().downcast_ref().unwrap();\n    let mut total_nondedup_buffers = first_arr.data_buffers().len();\n    let mut max_arr_bufferset_len = 0;\n    let mut all_same_bufs = true;\n    for arr in arrays {\n        let arr: &BinaryViewArrayGeneric<V> = arr.as_ref().as_any().downcast_ref().unwrap();\n        max_arr_bufferset_len = max_arr_bufferset_len.max(arr.data_buffers().len());\n        total_nondedup_buffers += arr.data_buffers().len();\n        // Fat pointer equality, checks both start and length.\n        all_same_bufs &= std::ptr::eq(\n            Arc::as_ptr(arr.data_buffers()),\n            Arc::as_ptr(first_arr.data_buffers()),\n        );\n    }\n\n    let mut total_bytes_len = 0;\n    let mut views = Vec::with_capacity(total_len);\n\n    let mut total_buffer_len = 0;\n    let buffers = if all_same_bufs {\n        total_buffer_len = first_arr.total_buffer_len();\n        for arr in arrays {\n            let arr: &BinaryViewArrayGeneric<V> = arr.as_ref().as_any().downcast_ref().unwrap();\n            views.extend_from_slice(arr.views());\n            total_bytes_len += arr.total_bytes_len();\n        }\n        Arc::clone(first_arr.data_buffers())\n\n    // There might be way more buffers than elements, so we only dedup if there\n    // is at least one element per buffer on average.\n    } else if total_len > total_nondedup_buffers {\n        assert!(arrays.len() < u32::MAX as usize);\n\n        let mut dedup_buffers = Vec::with_capacity(total_nondedup_buffers);\n        let mut global_dedup_buffer_idx = PlHashMap::with_capacity(total_nondedup_buffers);\n        let mut local_dedup_buffer_idx = Vec::new();\n        local_dedup_buffer_idx.resize(max_arr_bufferset_len, (0, u32::MAX));\n\n        for (arr_idx, arr) in arrays.iter().enumerate() {\n            let arr: &BinaryViewArrayGeneric<V> = arr.as_ref().as_any().downcast_ref().unwrap();\n\n            unsafe {\n                for mut view in arr.views().iter().copied() {\n                    if view.length > View::MAX_INLINE_SIZE {\n                        // Translate from old array-local buffer idx to global deduped buffer idx.\n                        let (mut new_buffer_idx, cache_tag) =\n                            *local_dedup_buffer_idx.get_unchecked(view.buffer_idx as usize);\n                        if cache_tag != arr_idx as u32 {\n                            // This buffer index wasn't seen before for this array, do a dedup lookup.\n                            let buffer = arr.data_buffers().get_unchecked(view.buffer_idx as usize);\n                            let buf_id = (buffer.as_slice().as_ptr(), buffer.len());\n                            let idx = match global_dedup_buffer_idx.entry(buf_id) {\n                                Entry::Occupied(o) => *o.get(),\n                                Entry::Vacant(v) => {\n                                    let idx = dedup_buffers.len() as u32;\n                                    dedup_buffers.push(buffer.clone());\n                                    total_buffer_len += buffer.len();\n                                    v.insert(idx);\n                                    idx\n                                },\n                            };\n\n                            // Cache result for future lookups.\n                            *local_dedup_buffer_idx.get_unchecked_mut(view.buffer_idx as usize) =\n                                (idx, arr_idx as u32);\n                            new_buffer_idx = idx;\n                        }\n                        view.buffer_idx = new_buffer_idx;\n                    }\n\n                    total_bytes_len += view.length as usize;\n                    views.push_unchecked(view);\n                }\n            }\n        }\n\n        dedup_buffers.into_iter().collect()\n    } else {\n        // Only very few of the total number of buffers is referenced, simply\n        // create a new direct buffer.\n        for arr in arrays {\n            let arr: &BinaryViewArrayGeneric<V> = arr.as_ref().as_any().downcast_ref().unwrap();\n            total_buffer_len += arr\n                .len_iter()\n                .map(|l| if l > 12 { l as usize } else { 0 })\n                .sum::<usize>();\n        }\n\n        let mut unprocessed_buffer_len = total_buffer_len;\n        let mut new_buffers: Vec<Vec<u8>> = vec![Vec::with_capacity(\n            unprocessed_buffer_len.min(u32::MAX as usize),\n        )];\n        for arr in arrays {\n            let arr: &BinaryViewArrayGeneric<V> = arr.as_ref().as_any().downcast_ref().unwrap();\n            let buffers = arr.data_buffers();\n\n            unsafe {\n                for mut view in arr.views().iter().copied() {\n                    total_bytes_len += view.length as usize;\n                    if view.length > 12 {\n                        if new_buffers.last().unwrap_unchecked().len() + view.length as usize\n                            >= u32::MAX as usize\n                        {\n                            new_buffers.push(Vec::with_capacity(\n                                unprocessed_buffer_len.min(u32::MAX as usize),\n                            ));\n                        }\n                        let new_offset = new_buffers.last().unwrap_unchecked().len() as u32;\n                        new_buffers\n                            .last_mut()\n                            .unwrap_unchecked()\n                            .extend_from_slice(view.get_slice_unchecked(buffers));\n                        view.offset = new_offset;\n                        view.buffer_idx = new_buffers.len() as u32 - 1;\n                        unprocessed_buffer_len -= view.length as usize;\n                    }\n                    views.push_unchecked(view);\n                }\n            }\n        }\n\n        new_buffers.into_iter().map(Buffer::from).collect()\n    };\n\n    unsafe {\n        BinaryViewArrayGeneric::new_unchecked(\n            dtype,\n            views.into(),\n            buffers,\n            validity,\n            total_bytes_len,\n            total_buffer_len,\n        )\n    }\n}"
}