{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `run`",
    "file": "k8s-openapi-codegen-common-0.25.0/src/lib.rs",
    "start_line": 138,
    "start_col": 1,
    "end_line": 805,
    "end_col": 2,
    "code_snippet": "pub fn run(\n    definitions: &std::collections::BTreeMap<swagger20::DefinitionPath, swagger20::Schema>,\n    operations: &mut Vec<swagger20::Operation>,\n    definition_path: &swagger20::DefinitionPath,\n    map_namespace: &impl MapNamespace,\n    vis: &str,\n    generate_schema: GenerateSchema<'_>,\n    mut state: impl RunState,\n) -> Result<RunResult, Error> {\n    let definition = definitions.get(definition_path).ok_or_else(|| format!(\"definition for {definition_path} does not exist in spec\"))?;\n\n    let local = map_namespace_local_to_string(map_namespace)?;\n\n    let mut run_result = RunResult {\n        num_generated_structs: 0,\n        num_generated_type_aliases: 0,\n    };\n\n    let path_parts: Vec<_> = definition_path.split('.').collect();\n    let namespace_parts: Vec<_> =\n        map_namespace.map_namespace(&path_parts).ok_or_else(|| format!(\"unexpected path {definition_path:?}\"))?\n        .into_iter()\n        .collect();\n\n    let mut out = state.make_writer(&namespace_parts)?;\n\n    let type_name = path_parts.last().ok_or_else(|| format!(\"path for {definition_path} has no parts\"))?;\n\n    let derives = get_derives(&definition.kind, definitions, map_namespace)?;\n\n    templates::type_header::generate(\n        &mut out,\n        definition_path,\n        definition.description.as_deref(),\n        derives,\n        vis,\n    )?;\n\n    match &definition.kind {\n        swagger20::SchemaKind::Properties(properties) => {\n            let (template_properties, resource_metadata, metadata_ty) = {\n                let mut result = Vec::with_capacity(properties.len());\n\n                let mut single_group_version_kind = match &definition.kubernetes_group_kind_versions[..] {\n                    [group_version_kind] => Some((group_version_kind, false, false)),\n                    _ => None,\n                };\n\n                let mut metadata_ty = None;\n\n                for (name, (schema, required)) in properties {\n                    if name.0 == \"apiVersion\" {\n                        if let Some((_, has_api_version, _)) = &mut single_group_version_kind {\n                            *has_api_version = true;\n                            continue;\n                        }\n                    }\n\n                    if name.0 == \"kind\" {\n                        if let Some((_, _, has_kind)) = &mut single_group_version_kind {\n                            *has_kind = true;\n                            continue;\n                        }\n                    }\n\n                    let field_name = get_rust_ident(name);\n\n                    let mut field_type_name = String::new();\n\n                    let required = match required {\n                        true => templates::PropertyRequired::Required {\n                            is_default: is_default(&schema.kind, definitions, map_namespace)?,\n                        },\n                        false => templates::PropertyRequired::Optional,\n                    };\n\n                    if let templates::PropertyRequired::Optional = required {\n                        field_type_name.push_str(\"Option<\");\n                    }\n\n                    let type_name = get_rust_type(&schema.kind, map_namespace)?;\n\n                    if name.0 == \"metadata\" {\n                        metadata_ty = Some((type_name.clone(), required));\n                    }\n\n                    // Fix cases of infinite recursion\n                    if let swagger20::SchemaKind::Ref(swagger20::RefPath { path, .. }) = &schema.kind {\n                        match (&**definition_path, &**name, &**path) {\n                            (\n                                \"io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps\",\n                                \"not\",\n                                \"io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps\",\n                            ) |\n                            (\n                                \"io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSONSchemaProps\",\n                                \"not\",\n                                \"io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSONSchemaProps\",\n                            ) => {\n                                field_type_name.push_str(\"std::boxed::Box<\");\n                                field_type_name.push_str(&type_name);\n                                field_type_name.push('>');\n                            },\n\n                            _ => field_type_name.push_str(&type_name),\n                        }\n                    }\n                    else {\n                        field_type_name.push_str(&type_name);\n                    }\n\n                    if let templates::PropertyRequired::Optional = required {\n                        field_type_name.push('>');\n                    }\n\n                    let is_flattened = matches!(&schema.kind, swagger20::SchemaKind::Ty(swagger20::Type::CustomResourceSubresources(_)));\n\n                    result.push(templates::Property {\n                        name,\n                        comment: schema.description.as_deref(),\n                        field_name,\n                        field_type_name,\n                        required,\n                        is_flattened,\n                        merge_type: &schema.merge_type,\n                    });\n                }\n\n                let resource_metadata = match single_group_version_kind {\n                    Some((single_group_version_kind, true, true)) =>\n                        Some(if single_group_version_kind.group.is_empty() {\n                            (\n                                format!(\"{:?}\", single_group_version_kind.version),\n                                format!(\"{:?}\", \"\"),\n                                format!(\"{:?}\", single_group_version_kind.kind),\n                                format!(\"{:?}\", single_group_version_kind.version),\n                                definition.list_kind.as_ref().map(|kind| format!(\"{kind:?}\")),\n                            )\n                        }\n                        else {\n                            (\n                                format!(\"{:?}\", format!(\"{}/{}\", single_group_version_kind.group, single_group_version_kind.version)),\n                                format!(\"{:?}\", single_group_version_kind.group),\n                                format!(\"{:?}\", single_group_version_kind.kind),\n                                format!(\"{:?}\", single_group_version_kind.version),\n                                definition.list_kind.as_ref().map(|kind| format!(\"{kind:?}\")),\n                            )\n                        }),\n                    Some((_, true, false)) => return Err(format!(\"{definition_path} has an apiVersion property but not a kind property\").into()),\n                    Some((_, false, true)) => return Err(format!(\"{definition_path} has a kind property but not an apiVersion property\").into()),\n                    Some((_, false, false)) | None => None,\n                };\n\n                (result, resource_metadata, metadata_ty)\n            };\n\n            templates::r#struct::generate(\n                &mut out,\n                vis,\n                type_name,\n                Default::default(),\n                &template_properties,\n            )?;\n\n            let mut namespace_or_cluster_scoped_url_path_segment_and_scope = vec![];\n            let mut subresource_url_path_segment_and_scope = vec![];\n\n            if !definition.kubernetes_group_kind_versions.is_empty() {\n                let mut kubernetes_group_kind_versions: Vec<_> = definition.kubernetes_group_kind_versions.iter().collect();\n                kubernetes_group_kind_versions.sort();\n\n                let mut operations_by_gkv: std::collections::BTreeMap<_, Vec<_>> = Default::default();\n                for operation in std::mem::take(operations) {\n                    operations_by_gkv\n                        .entry(operation.kubernetes_group_kind_version.clone())\n                        .or_default()\n                        .push(operation);\n                }\n\n                for kubernetes_group_kind_version in kubernetes_group_kind_versions {\n                    if let Some(mut operations) = operations_by_gkv.remove(&Some(kubernetes_group_kind_version.clone())) {\n                        operations.sort_by(|o1, o2| o1.id.cmp(&o2.id));\n\n                        for operation in operations {\n                            // If this is a CRUD operation, use it to determine the resource's URL path segment and scope.\n                            match operation.kubernetes_action {\n                                Some(\n                                    swagger20::KubernetesAction::Delete |\n                                    swagger20::KubernetesAction::Get |\n                                    swagger20::KubernetesAction::Post |\n                                    swagger20::KubernetesAction::Put\n                                ) => (),\n                                _ => continue,\n                            }\n                            let mut components = operation.path.rsplit('/');\n                            let components = (\n                                components.next().expect(\"str::rsplit returns at least one component\"),\n                                components.next(),\n                                components.next(),\n                                components.next(),\n                            );\n\n                            let (url_path_segment_, scope_, url_path_segment_and_scope) = match components {\n                                (\"{name}\", Some(url_path_segment), Some(\"{namespace}\"), Some(\"namespaces\")) =>\n                                    (\n                                        format!(\"{url_path_segment:?}\"),\n                                        format!(\"{local}NamespaceResourceScope\"),\n                                        &mut namespace_or_cluster_scoped_url_path_segment_and_scope,\n                                    ),\n\n                                (\"{name}\", Some(url_path_segment), _, _) =>\n                                    (\n                                        format!(\"{url_path_segment:?}\"),\n                                        format!(\"{local}ClusterResourceScope\"),\n                                        &mut namespace_or_cluster_scoped_url_path_segment_and_scope,\n                                    ),\n\n                                (url_path_segment, Some(\"{name}\"), _, _) =>\n                                    (\n                                        format!(\"{url_path_segment:?}\"),\n                                        format!(\"{local}SubResourceScope\"),\n                                        &mut subresource_url_path_segment_and_scope,\n                                    ),\n\n                                (url_path_segment, Some(\"{namespace}\"), Some(\"namespaces\"), _) =>\n                                    (\n                                        format!(\"{url_path_segment:?}\"),\n                                        format!(\"{local}NamespaceResourceScope\"),\n                                        &mut namespace_or_cluster_scoped_url_path_segment_and_scope,\n                                    ),\n\n                                (url_path_segment, _, _, _) =>\n                                    (\n                                        format!(\"{url_path_segment:?}\"),\n                                        format!(\"{local}ClusterResourceScope\"),\n                                        &mut namespace_or_cluster_scoped_url_path_segment_and_scope,\n                                    ),\n                            };\n\n                            url_path_segment_and_scope.push((url_path_segment_, scope_));\n                        }\n                    }\n                }\n\n                *operations = operations_by_gkv.into_values().flatten().collect();\n            }\n\n            match &**definition_path {\n                \"io.k8s.apimachinery.pkg.apis.meta.v1.APIGroup\" |\n                \"io.k8s.apimachinery.pkg.apis.meta.v1.APIGroupList\" |\n                \"io.k8s.apimachinery.pkg.apis.meta.v1.APIResourceList\" |\n                \"io.k8s.apimachinery.pkg.apis.meta.v1.APIVersions\" =>\n                    namespace_or_cluster_scoped_url_path_segment_and_scope.push((r#\"\"\"\"#.to_owned(), format!(\"{local}ClusterResourceScope\"))),\n                \"io.k8s.apimachinery.pkg.apis.meta.v1.Status\" =>\n                    subresource_url_path_segment_and_scope.push((r#\"\"status\"\"#.to_owned(), format!(\"{local}SubResourceScope\"))),\n                _ => (),\n            }\n\n            namespace_or_cluster_scoped_url_path_segment_and_scope.dedup();\n            subresource_url_path_segment_and_scope.dedup();\n\n            let template_resource_metadata = match (&resource_metadata, &metadata_ty) {\n                (\n                    Some((api_version, group, kind, version, list_kind)),\n                    Some((metadata_ty, templates::PropertyRequired::Required { is_default: _ })),\n                ) => Some(templates::ResourceMetadata {\n                    api_version,\n                    group,\n                    kind,\n                    version,\n                    list_kind: list_kind.as_deref(),\n                    metadata_ty: Some(metadata_ty),\n                    url_path_segment_and_scope: match (&*namespace_or_cluster_scoped_url_path_segment_and_scope, &*subresource_url_path_segment_and_scope) {\n                        ([(url_path_segment, scope)], _) |\n                        ([], [(url_path_segment, scope)]) => (&**url_path_segment, &**scope),\n\n                        ([], []) => return Err(format!(\n                            \"definition {definition_path} is a Resource but its URL path segment and scope could not be inferred\").into()),\n                        ([_, ..], _) => return Err(format!(\n                            \"definition {definition_path} is a Resource but was inferred to have multiple scopes {namespace_or_cluster_scoped_url_path_segment_and_scope:?}\").into()),\n                        ([], [_, ..]) => return Err(format!(\n                            \"definition {definition_path} is a Resource but was inferred to have multiple scopes {subresource_url_path_segment_and_scope:?}\").into()),\n                    },\n                }),\n\n                (Some(_), Some((_, templates::PropertyRequired::Optional | templates::PropertyRequired::OptionalDefault))) =>\n                    return Err(format!(\"definition {definition_path} has optional metadata\").into()),\n\n                (\n                    Some((api_version, group, kind, version, list_kind)),\n                    None,\n                ) => Some(templates::ResourceMetadata {\n                    api_version,\n                    group,\n                    kind,\n                    version,\n                    list_kind: list_kind.as_deref(),\n                    metadata_ty: None,\n                    url_path_segment_and_scope: match (&*namespace_or_cluster_scoped_url_path_segment_and_scope, &*subresource_url_path_segment_and_scope) {\n                        ([(url_path_segment, scope)], _) |\n                        ([], [(url_path_segment, scope)]) => (&**url_path_segment, &**scope),\n\n                        ([], []) => return Err(format!(\n                            \"definition {definition_path} is a Resource but its URL path segment and scope could not be inferred\").into()),\n                        ([_, _, ..], _) => return Err(format!(\n                            \"definition {definition_path} is a Resource but was inferred to have multiple scopes {namespace_or_cluster_scoped_url_path_segment_and_scope:?}\").into()),\n                        ([], [_, _, ..]) => return Err(format!(\n                            \"definition {definition_path} is a Resource but was inferred to have multiple scopes {subresource_url_path_segment_and_scope:?}\").into()),\n                    },\n                }),\n\n                (None, _) => None,\n            };\n\n            if let Some(template_resource_metadata) = &template_resource_metadata {\n                templates::impl_resource::generate(\n                    &mut out,\n                    type_name,\n                    Default::default(),\n                    map_namespace,\n                    template_resource_metadata,\n                )?;\n\n                templates::impl_listable_resource::generate(\n                    &mut out,\n                    type_name,\n                    Default::default(),\n                    map_namespace,\n                    template_resource_metadata,\n                )?;\n\n                templates::impl_metadata::generate(\n                    &mut out,\n                    type_name,\n                    Default::default(),\n                    map_namespace,\n                    template_resource_metadata,\n                )?;\n            }\n\n            if definition.impl_deep_merge {\n                templates::struct_deep_merge::generate(\n                    &mut out,\n                    type_name,\n                    Default::default(),\n                    &template_properties,\n                    map_namespace,\n                )?;\n            }\n\n            templates::impl_deserialize::generate(\n                &mut out,\n                type_name,\n                Default::default(),\n                &template_properties,\n                map_namespace,\n                template_resource_metadata.as_ref(),\n            )?;\n\n            templates::impl_serialize::generate(\n                &mut out,\n                type_name,\n                Default::default(),\n                &template_properties,\n                map_namespace,\n                template_resource_metadata.as_ref(),\n            )?;\n\n            run_result.num_generated_structs += 1;\n        },\n\n        swagger20::SchemaKind::Ref(_) => return Err(format!(\"{definition_path} is a Ref\").into()),\n\n        swagger20::SchemaKind::Ty(swagger20::Type::IntOrString) => {\n            templates::int_or_string::generate(\n                &mut out,\n                type_name,\n                map_namespace,\n            )?;\n\n            run_result.num_generated_structs += 1;\n        },\n\n        swagger20::SchemaKind::Ty(swagger20::Type::JsonSchemaPropsOr(namespace, json_schema_props_or)) => {\n            let json_schema_props_or = match json_schema_props_or {\n                swagger20::JsonSchemaPropsOr::Array => templates::json_schema_props_or::Or::Array,\n                swagger20::JsonSchemaPropsOr::Bool => templates::json_schema_props_or::Or::Bool,\n                swagger20::JsonSchemaPropsOr::StringArray => templates::json_schema_props_or::Or::StringArray,\n            };\n\n            let json_schema_props_type_name =\n                get_fully_qualified_type_name(\n                    &swagger20::RefPath {\n                        path: format!(\"io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.{namespace}.JSONSchemaProps\"),\n                        can_be_default: None,\n                    },\n                    map_namespace);\n\n            templates::json_schema_props_or::generate(\n                &mut out,\n                type_name,\n                json_schema_props_or,\n                &json_schema_props_type_name,\n                map_namespace,\n            )?;\n\n            run_result.num_generated_structs += 1;\n        },\n\n        swagger20::SchemaKind::Ty(swagger20::Type::Patch) => {\n            templates::patch::generate(\n                &mut out,\n                type_name,\n                map_namespace,\n            )?;\n\n            run_result.num_generated_structs += 1;\n        },\n\n        swagger20::SchemaKind::Ty(swagger20::Type::WatchEvent(raw_extension_ref_path)) => {\n            let error_status_rust_type = get_rust_type(\n                &swagger20::SchemaKind::Ref(swagger20::RefPath {\n                    path: \"io.k8s.apimachinery.pkg.apis.meta.v1.Status\".to_owned(),\n                    can_be_default: None,\n                }),\n                map_namespace,\n            )?;\n\n            let error_other_rust_type = get_rust_type(\n                &swagger20::SchemaKind::Ref(raw_extension_ref_path.clone()),\n                map_namespace,\n            )?;\n\n            templates::watch_event::generate(\n                &mut out,\n                type_name,\n                &error_status_rust_type,\n                &error_other_rust_type,\n                map_namespace,\n            )?;\n\n            run_result.num_generated_structs += 1;\n        },\n\n        swagger20::SchemaKind::Ty(swagger20::Type::ListDef { metadata }) => {\n            let metadata_rust_type = get_rust_type(metadata, map_namespace)?;\n\n            let template_generics_where_part = format!(\"T: {local}ListableResource\");\n            let template_generics = templates::Generics {\n                type_part: Some(\"T\"),\n                where_part: Some(&template_generics_where_part),\n            };\n\n            let items_merge_type = swagger20::MergeType::List {\n                strategy: swagger20::KubernetesListType::Map,\n                keys: vec![\"metadata().namespace\".to_string(), \"metadata().name\".to_string()],\n                item_merge_type: Box::new(swagger20::MergeType::Default),\n            };\n\n            let template_properties = vec![\n                templates::Property {\n                    name: \"items\",\n                    comment: Some(\"List of objects.\"),\n                    field_name: \"items\".into(),\n                    field_type_name: \"std::vec::Vec<T>\".to_owned(),\n                    required: templates::PropertyRequired::Required { is_default: true },\n                    is_flattened: false,\n                    merge_type: &items_merge_type,\n                },\n\n                templates::Property {\n                    name: \"metadata\",\n                    comment: Some(\"Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\"),\n                    field_name: \"metadata\".into(),\n                    field_type_name: (*metadata_rust_type).to_owned(),\n                    required: templates::PropertyRequired::Required { is_default: true },\n                    is_flattened: false,\n                    merge_type: &swagger20::MergeType::Default,\n                },\n            ];\n\n            let template_resource_metadata = templates::ResourceMetadata {\n                api_version: \"<T as crate::Resource>::API_VERSION\",\n                group: \"<T as crate::Resource>::GROUP\",\n                kind: \"<T as crate::ListableResource>::LIST_KIND\",\n                version: \"<T as crate::Resource>::VERSION\",\n                list_kind: None,\n                metadata_ty: Some(&metadata_rust_type),\n                url_path_segment_and_scope: (r#\"\"\"\"#, \"<T as crate::Resource>::Scope\"),\n            };\n\n            templates::r#struct::generate(\n                &mut out,\n                vis,\n                type_name,\n                template_generics,\n                &template_properties,\n            )?;\n\n            templates::impl_resource::generate(\n                &mut out,\n                type_name,\n                template_generics,\n                map_namespace,\n                &template_resource_metadata,\n            )?;\n\n            templates::impl_listable_resource::generate(\n                &mut out,\n                type_name,\n                template_generics,\n                map_namespace,\n                &template_resource_metadata,\n            )?;\n\n            templates::impl_metadata::generate(\n                &mut out,\n                type_name,\n                template_generics,\n                map_namespace,\n                &template_resource_metadata,\n            )?;\n\n            if definition.impl_deep_merge {\n                let template_generics_where_part = format!(\"T: {local}DeepMerge + {local}Metadata<Ty = {local}apimachinery::pkg::apis::meta::v1::ObjectMeta> + {local}ListableResource\");\n                let template_generics = templates::Generics {\n                    where_part: Some(&template_generics_where_part),\n                    ..template_generics\n                };\n\n                templates::struct_deep_merge::generate(\n                    &mut out,\n                    type_name,\n                    template_generics,\n                    &template_properties,\n                    map_namespace,\n                )?;\n            }\n\n            {\n                let template_generics_where_part = format!(\"T: {local}serde::Deserialize<'de> + {local}ListableResource\");\n                let template_generics = templates::Generics {\n                    where_part: Some(&template_generics_where_part),\n                    ..template_generics\n                };\n\n                templates::impl_deserialize::generate(\n                    &mut out,\n                    type_name,\n                    template_generics,\n                    &template_properties,\n                    map_namespace,\n                    Some(&template_resource_metadata),\n                )?;\n            }\n\n            {\n                let template_generics_where_part = format!(\"T: {local}serde::Serialize + {local}ListableResource\");\n                let template_generics = templates::Generics {\n                    where_part: Some(&template_generics_where_part),\n                    ..template_generics\n                };\n\n                templates::impl_serialize::generate(\n                    &mut out,\n                    type_name,\n                    template_generics,\n                    &template_properties,\n                    map_namespace,\n                    Some(&template_resource_metadata),\n                )?;\n            }\n\n            run_result.num_generated_structs += 1;\n        },\n\n        swagger20::SchemaKind::Ty(swagger20::Type::ListRef { .. }) => return Err(format!(\"definition {definition_path} is a ListRef\").into()),\n\n        swagger20::SchemaKind::Ty(_) => {\n            let inner_type_name = get_rust_type(&definition.kind, map_namespace)?;\n\n            // Kubernetes requires MicroTime to be serialized with exactly six decimal digits, instead of the default serde serialization of `chrono::DateTime`\n            // that uses a variable number up to nine.\n            //\n            // Furthermore, while Kubernetes does deserialize a Time from a string with one or more decimal digits,\n            // the format string it uses to *serialize* datetimes does not contain any decimal digits. So match that behavior just to be safe, and to have\n            // the same behavior as the golang client.\n            //\n            // Refs:\n            // - https://github.com/Arnavion/k8s-openapi/issues/63\n            // - https://github.com/deislabs/krustlet/issues/5\n            // - https://github.com/kubernetes/apimachinery/issues/88\n            let datetime_serialization_format = match (&**definition_path, &definition.kind) {\n                (\n                    \"io.k8s.apimachinery.pkg.apis.meta.v1.MicroTime\",\n                    swagger20::SchemaKind::Ty(swagger20::Type::String { format: Some(swagger20::StringFormat::DateTime) }),\n                ) => templates::DateTimeSerializationFormat::SixDecimalDigits,\n\n                (\n                    \"io.k8s.apimachinery.pkg.apis.meta.v1.Time\",\n                    swagger20::SchemaKind::Ty(swagger20::Type::String { format: Some(swagger20::StringFormat::DateTime) }),\n                ) => templates::DateTimeSerializationFormat::ZeroDecimalDigits,\n\n                _ => templates::DateTimeSerializationFormat::Default,\n            };\n\n            templates::newtype::generate(\n                &mut out,\n                vis,\n                type_name,\n                &inner_type_name,\n                datetime_serialization_format,\n                map_namespace,\n            )?;\n\n            run_result.num_generated_type_aliases += 1;\n        },\n    }\n\n    if let GenerateSchema::Yes { feature: schema_feature } = generate_schema {\n        match &definition.kind {\n            swagger20::SchemaKind::Properties(_) |\n            swagger20::SchemaKind::Ty(\n                swagger20::Type::Any |\n                swagger20::Type::Array { .. } |\n                swagger20::Type::Boolean |\n                swagger20::Type::Integer { .. } |\n                swagger20::Type::IntOrString |\n                swagger20::Type::Number { .. } |\n                swagger20::Type::Object { .. } |\n                swagger20::Type::String { .. } |\n                swagger20::Type::JsonSchemaPropsOr(_, _) |\n                swagger20::Type::Patch\n            ) => {\n                templates::impl_schema::generate(\n                    &mut out,\n                    type_name,\n                    Default::default(),\n                    definition_path,\n                    definition,\n                    schema_feature,\n                    map_namespace,\n                )?;\n            }\n\n            swagger20::SchemaKind::Ty(swagger20::Type::WatchEvent(_)) => {\n                templates::impl_schema::generate(\n                    &mut out,\n                    type_name,\n                    templates::Generics {\n                        type_part: Some(\"T\"),\n                        where_part: None,\n                    },\n                    definition_path,\n                    definition,\n                    schema_feature,\n                    map_namespace,\n                )?;\n            }\n\n            _ => (),\n        }\n    }\n\n    state.finish(out);\n\n    Ok(run_result)\n}"
}