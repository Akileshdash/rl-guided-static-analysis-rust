{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `vec2::partition_dedup_by`",
    "file": "oxc_allocator-0.79.1/src/vec2/mod.rs",
    "start_line": 123,
    "start_col": 1,
    "end_line": 210,
    "end_col": 2,
    "code_snippet": "fn partition_dedup_by<T, F>(s: &mut [T], mut same_bucket: F) -> (&mut [T], &mut [T])\nwhere\n    F: FnMut(&mut T, &mut T) -> bool,\n{\n    // Although we have a mutable reference to `s`, we cannot make\n    // *arbitrary* changes. The `same_bucket` calls could panic, so we\n    // must ensure that the slice is in a valid state at all times.\n    //\n    // The way that we handle this is by using swaps; we iterate\n    // over all the elements, swapping as we go so that at the end\n    // the elements we wish to keep are in the front, and those we\n    // wish to reject are at the back. We can then split the slice.\n    // This operation is still O(n).\n    //\n    // Example: We start in this state, where `r` represents \"next\n    // read\" and `w` represents \"next_write`.\n    //\n    //           r\n    //     +---+---+---+---+---+---+\n    //     | 0 | 1 | 1 | 2 | 3 | 3 |\n    //     +---+---+---+---+---+---+\n    //           w\n    //\n    // Comparing s[r] against s[w-1], this is not a duplicate, so\n    // we swap s[r] and s[w] (no effect as r==w) and then increment both\n    // r and w, leaving us with:\n    //\n    //               r\n    //     +---+---+---+---+---+---+\n    //     | 0 | 1 | 1 | 2 | 3 | 3 |\n    //     +---+---+---+---+---+---+\n    //               w\n    //\n    // Comparing s[r] against s[w-1], this value is a duplicate,\n    // so we increment `r` but leave everything else unchanged:\n    //\n    //                   r\n    //     +---+---+---+---+---+---+\n    //     | 0 | 1 | 1 | 2 | 3 | 3 |\n    //     +---+---+---+---+---+---+\n    //               w\n    //\n    // Comparing s[r] against s[w-1], this is not a duplicate,\n    // so swap s[r] and s[w] and advance r and w:\n    //\n    //                       r\n    //     +---+---+---+---+---+---+\n    //     | 0 | 1 | 2 | 1 | 3 | 3 |\n    //     +---+---+---+---+---+---+\n    //                   w\n    //\n    // Not a duplicate, repeat:\n    //\n    //                           r\n    //     +---+---+---+---+---+---+\n    //     | 0 | 1 | 2 | 3 | 1 | 3 |\n    //     +---+---+---+---+---+---+\n    //                       w\n    //\n    // Duplicate, advance r. End of slice. Split at w.\n\n    let len = s.len();\n    if len <= 1 {\n        return (s, &mut []);\n    }\n\n    let ptr = s.as_mut_ptr();\n    let mut next_read: usize = 1;\n    let mut next_write: usize = 1;\n\n    unsafe {\n        // Avoid bounds checks by using raw pointers.\n        while next_read < len {\n            let ptr_read = ptr.add(next_read);\n            let prev_ptr_write = ptr.add(next_write - 1);\n            if !same_bucket(&mut *ptr_read, &mut *prev_ptr_write) {\n                if next_read != next_write {\n                    let ptr_write = prev_ptr_write.offset(1);\n                    mem::swap(&mut *ptr_read, &mut *ptr_write);\n                }\n                next_write += 1;\n            }\n            next_read += 1;\n        }\n    }\n\n    s.split_at_mut(next_write)\n}"
}