{
    "level": "Warning",
    "analyzer": "UnsafeDataflow",
    "op_type": "ReadFlow",
    "description": "Potential unsafe dataflow issue in `partition`",
    "file": "pdqsort-1.0.3/src/lib.rs",
    "start_line": 434,
    "start_col": 1,
    "end_line": 477,
    "end_col": 2,
    "code_snippet": "fn partition<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> (usize, bool)\n    where F: FnMut(&T, &T) -> bool\n{\n    let (mid, was_partitioned) = {\n        // Place the pivot at the beginning of slice.\n        v.swap(0, pivot);\n        let (pivot, v) = v.split_at_mut(1);\n        let pivot = &mut pivot[0];\n\n        // Read the pivot into a stack-allocated variable for efficiency. If a following comparison\n        // operation panics, the pivot will be automatically written back into the slice.\n        let write_on_drop = WriteOnDrop {\n            value: unsafe { Some(ptr::read(pivot)) },\n            dest: pivot,\n        };\n        let pivot = write_on_drop.value.as_ref().unwrap();\n\n        // Find the first pair of out-of-order elements.\n        let mut l = 0;\n        let mut r = v.len();\n        unsafe {\n            // Find the first element greater then or equal to the pivot.\n            while l < r && is_less(v.get_unchecked(l), pivot) {\n                l += 1;\n            }\n\n            // Find the last element smaller that the pivot.\n            while l < r && !is_less(v.get_unchecked(r - 1), pivot) {\n                r -= 1;\n            }\n        }\n\n        (l + partition_in_blocks(&mut v[l..r], pivot, is_less), l >= r)\n\n        // `write_on_drop` goes out of scope and writes the pivot (which is a stack-allocated\n        // variable) back into the slice where it originally was. This step is critical in ensuring\n        // safety!\n    };\n\n    // Place the pivot between the two partitions.\n    v.swap(0, mid);\n\n    (mid, was_partitioned)\n}"
}