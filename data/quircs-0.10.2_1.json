{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `identify::flood_fill_seed`",
    "file": "quircs-0.10.2/src/identify.rs",
    "start_line": 149,
    "start_col": 1,
    "end_line": 226,
    "end_col": 2,
    "code_snippet": "fn flood_fill_seed<F>(\n    image: &mut ImageMut<'_>,\n    starting_x: i32,\n    starting_y: usize,\n    from: Pixel,\n    to: Pixel,\n    func: Option<&F>,\n    user_data: &mut UserData<'_>,\n) where\n    F: Fn(&mut UserData<'_>, usize, i32, i32),\n{\n    let mut flood_from = vec![(starting_x as usize, starting_y)];\n\n    while let Some((x, y)) = flood_from.pop() {\n        let mut left = x;\n        let mut right = x;\n        let width = image.width;\n\n        let row = &mut image.pixels[y * width..(y + 1) * width];\n        while left > 0 && row[left - 1] == from {\n            left -= 1;\n        }\n        while right < width - 1 && row[right + 1] == from {\n            right += 1;\n        }\n\n        // Fill the extent\n        for val in &mut row[left..=right] {\n            *val = to;\n        }\n\n        if let Some(func) = func {\n            func(user_data, y, left as i32, right as i32);\n        }\n\n        // Seed new flood-fills\n\n        if y > 0 {\n            // Not the first row, so fill the previous row\n            let offset = (y - 1) * width;\n            // Two side-by-side pixels do not need two flood fills seeded, since the first flood file will scan to the right and cover the second one.\n            // Keeping track of whether the previous pixel matched lets those unnecessary side-by-side flood fills to be skipped.\n            let mut prev_matched = false;\n            for i in left..=right {\n                // Safety: pixels is in range, as verified by the assert at the beginning.\n                // Unfortunately this is required, as the compiler will add bounds checks that are quite measurable.\n                let val = unsafe { *image.pixels.get_unchecked(offset + i) };\n                if val == from {\n                    if !prev_matched {\n                        flood_from.push((i, y - 1));\n                        prev_matched = true;\n                    }\n                } else {\n                    prev_matched = false;\n                }\n            }\n        }\n\n        if y < image.height - 1 {\n            // Not the last row, so fill the next row\n            let offset = (y + 1) * width;\n            let mut prev_matched = false;\n            for i in left..=right {\n                // Safety: pixels is in range, as verified by the assert at the beginning.\n                // Unfortunately this is required, as the compiler will add bounds checks that are quite measurable.\n                let val = unsafe { *image.pixels.get_unchecked(offset + i) };\n                if val == from {\n                    if !prev_matched {\n                        flood_from.push((i, y + 1));\n                        prev_matched = true;\n                    }\n                } else {\n                    prev_matched = false;\n                }\n            }\n        }\n    }\n}"
}