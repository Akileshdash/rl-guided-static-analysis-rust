{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `parma::raw::RawTable::<K, V>::try_find_or_insert_impl`",
    "file": "polars-utils-0.49.1/src/parma/raw/mod.rs",
    "start_line": 495,
    "start_col": 5,
    "end_line": 590,
    "end_col": 6,
    "code_snippet": "fn try_find_or_insert_impl<E>(\n        &self,\n        orig_probe_alloc: *mut AllocHeader<K, V>,\n        mut prober: Prober,\n        hash: usize,\n        key: &K,\n        val_f: impl FnOnce(&K) -> Result<V, E>,\n        mut eq: impl FnMut(&K) -> bool,\n    ) -> Result<*mut EntryHeader<K, V>, E> {\n        unsafe {\n            let new_entry_ptr = EntryHeader::<K, V>::new(hash, key);\n\n            let alloc = self.start_insert_attempt();\n            if alloc != orig_probe_alloc {\n                prober = Prober::new(hash);\n            }\n\n            let header = &*alloc;\n            let tags = header.tags(alloc);\n            let entries = header.entries(alloc);\n            let group_mask = TagGroup::idx_mask(header.num_entries);\n            let mut needle = TagGroup::all_occupied(hash);\n\n            'probe_loop: loop {\n                let group_idx = prober.get() & group_mask;\n                let mut tag_group = TagGroup::load(tags.get_unchecked(group_idx));\n                let matches = tag_group.matches(&mut needle);\n                let empties = tag_group.empties();\n                let mut insert_locs = matches | empties;\n                while insert_locs.has_matches() {\n                    let idx_in_group = insert_locs.get();\n\n                    // Insert a new tag if this insert location.\n                    if empties.has_match_at(idx_in_group) {\n                        if !tags.get_unchecked(group_idx).try_occupy(\n                            &mut tag_group,\n                            idx_in_group,\n                            hash,\n                        ) {\n                            continue 'probe_loop;\n                        }\n                    }\n\n                    let entry_idx = size_of::<TagGroup>() * group_idx + idx_in_group;\n                    let entry = entries.get_unchecked(entry_idx);\n                    let mut entry_ptr = entry.load(Ordering::Acquire);\n                    if entry_ptr.addr() == UNCLAIMED {\n                        // Try to claim this entry.\n                        match entry.compare_exchange(\n                            entry_ptr,\n                            new_entry_ptr,\n                            Ordering::Release,\n                            Ordering::Acquire,\n                        ) {\n                            Ok(_) => {\n                                header.finish_claim_attempt(\n                                    &self.alloc_lock,\n                                    &self.waiting_for_alloc,\n                                );\n                                return self.try_init_entry_val(\n                                    hash,\n                                    header,\n                                    entry,\n                                    new_entry_ptr,\n                                    val_f,\n                                );\n                            },\n                            Err(ev) => entry_ptr = ev,\n                        }\n                    }\n\n                    // We couldn't claim the entry, see if our key is the same as\n                    // whoever claimed this entry, assuming it's not deleted.\n                    if entry_ptr.addr() != DELETED {\n                        let entry_key = K::get(EntryHeader::key_ptr(entry_ptr));\n                        if eq(entry_key) {\n                            if EntryHeader::wait_for_init(\n                                entry_ptr,\n                                &self.init_lock,\n                                &self.waiting_for_init,\n                            ) {\n                                EntryHeader::free(new_entry_ptr);\n                                header\n                                    .abort_claim_attempt(&self.alloc_lock, &self.waiting_for_alloc);\n                                return Ok(entry_ptr);\n                            }\n                        }\n                    }\n\n                    insert_locs.advance();\n                }\n\n                prober.advance();\n            }\n        }\n    }"
}