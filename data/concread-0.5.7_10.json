{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `internals::bptree::iter::RangeIter::<'_, K, V>::new`",
    "file": "concread-0.5.7/src/internals/bptree/iter.rs",
    "start_line": 438,
    "start_col": 5,
    "end_line": 598,
    "end_col": 6,
    "code_snippet": "pub(crate) fn new<R, T>(root: *mut Node<K, V>, range: R, length: usize) -> Self\n    where\n        T: Ord + ?Sized,\n        K: Borrow<T>,\n        R: RangeBounds<T>,\n    {\n        let length = Some(length);\n        // We need to position the VecDeque here. This requires us\n        // to know the bounds that we have. We do this similar to the main\n        // rust library tree by locating our \"edges\", and maintaining stacks to their paths.\n\n        // Setup and position the two iters.\n        let mut left_iter = LeafIter::new(root, range.start_bound());\n        let mut right_iter = RevLeafIter::new(root, range.end_bound());\n\n        //If needed, advanced the left / right iter depending on the situation.\n\n        match range.start_bound() {\n            Bound::Unbounded => {\n                // Do nothing!\n            }\n            Bound::Included(k) => {\n                if let Some((node, idx)) = left_iter.get_mut() {\n                    let leaf = leaf_ref!(*node, K, V);\n                    // eprintln!(\"Positioning Included with ... {:?} {:?}\", leaf, idx);\n                    match leaf.locate(k) {\n                        Ok(fidx) | Err(fidx) => {\n                            // eprintln!(\"Using, {}\", fidx);\n                            *idx = fidx;\n                            // Done!\n                        }\n                    }\n                } else {\n                    // Do nothing, it's empty.\n                }\n            }\n            Bound::Excluded(k) => {\n                if let Some((node, idx)) = left_iter.get_mut() {\n                    let leaf = leaf_ref!(*node, K, V);\n                    // eprintln!(\"Positioning Excluded with ... {:?} {:?}\", leaf, idx);\n                    match leaf.locate(k) {\n                        Ok(fidx) => {\n                            // eprintln!(\"Excluding Using, {}\", fidx);\n                            *idx = fidx + 1;\n                            if *idx >= leaf.count() {\n                                if let Some((rnode, _)) = right_iter.get_mut() {\n                                    // If the leaf iterators were in the same node before advancing left iterator\n                                    // means that left iterator would be ahead of right iter so no elements left\n                                    if rnode == node {\n                                        left_iter.clear();\n                                        right_iter.clear();\n                                    }\n                                }\n                                // Okay, this means we overflowed to the next leaf, so just\n                                // advanced the leaf iter to the start of the next\n                                left_iter.next();\n                            }\n                            // Done\n                        }\n                        Err(fidx) => {\n                            // eprintln!(\"Using, {}\", fidx);\n                            *idx = fidx;\n                            // Done!\n                        }\n                    }\n                } else {\n                    // Do nothing, the leaf iter is empty.\n                }\n            }\n        }\n\n        match range.end_bound() {\n            Bound::Unbounded => {\n                // Do nothing!\n            }\n            Bound::Included(k) => {\n                if let Some((node, idx)) = right_iter.get_mut() {\n                    let leaf = leaf_ref!(*node, K, V);\n                    // eprintln!(\"Positioning Included with ... {:?} {:?}\", leaf, idx);\n                    match leaf.locate(k) {\n                        Ok(fidx) => {\n                            *idx = fidx;\n                        }\n                        Err(fidx) => {\n                            // eprintln!(\"Using, {}\", fidx);\n                            let (nidx, oflow) = fidx.overflowing_sub(1);\n                            if oflow {\n                                if let Some((lnode, _)) = left_iter.get_mut() {\n                                    // If the leaf iterators were in the same node before advancing right iterator\n                                    // means that left iterator would be ahead of right iter so no elements left\n                                    if lnode == node {\n                                        left_iter.clear();\n                                        right_iter.clear();\n                                    }\n                                }\n                                right_iter.next();\n                            } else {\n                                *idx = nidx;\n                            }\n                            // Done!\n                        }\n                    }\n                } else {\n                    // Do nothing, it's empty.\n                }\n            }\n            Bound::Excluded(k) => {\n                if let Some((node, idx)) = right_iter.get_mut() {\n                    let leaf = leaf_ref!(*node, K, V);\n                    // eprintln!(\"Positioning Included with ... {:?} {:?}\", leaf, idx);\n                    match leaf.locate(k) {\n                        Ok(fidx) | Err(fidx) => {\n                            // eprintln!(\"Using, {}\", fidx);\n                            let (nidx, oflow) = fidx.overflowing_sub(1);\n                            if oflow {\n                                if let Some((lnode, _)) = left_iter.get_mut() {\n                                    // If the leaf iterators were in the same node before advancing right iterator\n                                    // means that left iterator would be ahead of right iter so no elements left\n                                    if lnode == node {\n                                        left_iter.clear();\n                                        right_iter.clear();\n                                    }\n                                }\n                                right_iter.next();\n                            } else {\n                                *idx = nidx;\n                            }\n                            // Done!\n                        }\n                    }\n                } else {\n                    // Do nothing, it's empty.\n                }\n            }\n        }\n\n        // If either side is empty, it indicates a bound hit the end of the tree\n        // and we can't proceed\n        if left_iter.is_empty() || right_iter.is_empty() {\n            left_iter.clear();\n            right_iter.clear();\n        }\n\n        // If both iterators end up in the same leaf and left index is larger,\n        // it indicates that there is nothing to return\n        if let Some((lnode, lidx)) = left_iter.get_mut() {\n            if let Some((rnode, ridx)) = right_iter.get_mut() {\n                if rnode == lnode && lidx > ridx {\n                    right_iter.clear();\n                    left_iter.clear();\n                }\n            }\n        }\n\n        RangeIter {\n            length,\n            left_iter,\n            right_iter,\n            phantom_root: PhantomData,\n        }\n    }"
}