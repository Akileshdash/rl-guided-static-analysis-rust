{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `iter::ResponseIterInner::new`",
    "file": "bao-tree-0.15.1//usagers4/u139091/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/self_cell-1.0.3/src/lib.rs",
    "start_line": 346,
    "start_col": 9,
    "end_line": 395,
    "end_col": 10,
    "code_snippet": "$Vis fn new(\n            owner: $Owner,\n            dependent_builder: impl for<'_q> ::core::ops::FnOnce(&'_q $Owner) -> $Dependent<'_q>\n        ) -> Self {\n            use ::core::ptr::NonNull;\n\n            unsafe {\n                // All this has to happen here, because there is not good way\n                // of passing the appropriate logic into UnsafeSelfCell::new\n                // short of assuming Dependent<'static> is the same as\n                // Dependent<'_q>, which I'm not confident is safe.\n\n                // For this API to be safe there has to be no safe way to\n                // capture additional references in `dependent_builder` and then\n                // return them as part of Dependent. Eg. it should be impossible\n                // to express: '_q should outlive 'x here `fn\n                // bad<'_q>(outside_ref: &'_q String) -> impl for<'x> ::core::ops::FnOnce(&'x\n                // Owner) -> Dependent<'x>`.\n\n                type JoinedCell<'_q $(, $OwnerLifetime)?> =\n                    $crate::unsafe_self_cell::JoinedCell<$Owner, $Dependent<'_q>>;\n\n                let layout = $crate::alloc::alloc::Layout::new::<JoinedCell>();\n                assert!(layout.size() != 0);\n\n                let joined_void_ptr = NonNull::new($crate::alloc::alloc::alloc(layout)).unwrap();\n\n                let mut joined_ptr = joined_void_ptr.cast::<JoinedCell>();\n\n                let (owner_ptr, dependent_ptr) = JoinedCell::_field_pointers(joined_ptr.as_ptr());\n\n                // Move owner into newly allocated space.\n                owner_ptr.write(owner);\n\n                // Drop guard that cleans up should building the dependent panic.\n                let drop_guard =\n                    $crate::unsafe_self_cell::OwnerAndCellDropGuard::new(joined_ptr);\n\n                // Initialize dependent with owner reference in final place.\n                dependent_ptr.write(dependent_builder(&*owner_ptr));\n                ::core::mem::forget(drop_guard);\n\n                Self {\n                    unsafe_self_cell: $crate::unsafe_self_cell::UnsafeSelfCell::new(\n                        joined_void_ptr,\n                    ),\n                    $(owner_marker: $crate::_covariant_owner_marker_ctor!($OwnerLifetime) ,)?\n                }\n            }\n        }"
}