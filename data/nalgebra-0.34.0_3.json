{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "SliceFromRaw",
    "description": "Potential unsafe dataflow issue in `base::edition::<impl base::matrix::Matrix<T, R, C, S>>::remove_columns_at`",
    "file": "nalgebra-0.34.0/src/base/edition.rs",
    "start_line": 362,
    "start_col": 5,
    "end_line": 409,
    "end_col": 6,
    "code_snippet": "pub fn remove_columns_at(self, indices: &[usize]) -> OMatrix<T, R, Dyn>\n    where\n        C: DimSub<Dyn, Output = Dyn>,\n        DefaultAllocator: Reallocator<T, R, C, R, Dyn>,\n    {\n        let mut m = self.into_owned();\n        let (nrows, ncols) = m.shape_generic();\n        let mut offset: usize = 0;\n        let mut target: usize = 0;\n        while offset + target < ncols.value() {\n            if indices.contains(&(target + offset)) {\n                // Safety: the resulting pointer is within range.\n                let col_ptr = unsafe { m.data.ptr_mut().add((target + offset) * nrows.value()) };\n                // Drop every element in the column we are about to overwrite.\n                // We use the a similar technique as in `Vec::truncate`.\n                let s = ptr::slice_from_raw_parts_mut(col_ptr, nrows.value());\n                // Safety: we drop the column in-place, which is OK because we will overwrite these\n                //         entries later in the loop, or discard them with the `reallocate_copy`\n                //         afterwards.\n                unsafe { ptr::drop_in_place(s) };\n\n                offset += 1;\n            } else {\n                unsafe {\n                    let ptr_source = m.data.ptr().add((target + offset) * nrows.value());\n                    let ptr_target = m.data.ptr_mut().add(target * nrows.value());\n\n                    // Copy the data, overwriting what we dropped.\n                    ptr::copy(ptr_source, ptr_target, nrows.value());\n                    target += 1;\n                }\n            }\n        }\n\n        // Safety: The new size is smaller than the old size, so\n        //         DefaultAllocator::reallocate_copy will initialize\n        //         every element of the new matrix which can then\n        //         be assumed to be initialized.\n        unsafe {\n            let new_data = DefaultAllocator::reallocate_copy(\n                nrows,\n                ncols.sub(Dyn::from_usize(offset)),\n                m.data,\n            );\n\n            Matrix::from_data(new_data).assume_init()\n        }\n    }"
}