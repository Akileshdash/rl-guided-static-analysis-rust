{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `raw::HashMap::<K, V, S>::insert_at`",
    "file": "papaya-0.2.3/src/raw/mod.rs",
    "start_line": 878,
    "start_col": 5,
    "end_line": 936,
    "end_col": 6,
    "code_snippet": "unsafe fn insert_at(\n        &self,\n        i: usize,\n        meta: u8,\n        new_entry: *mut Entry<K, V>,\n        table: Table<Entry<K, V>>,\n        guard: &impl VerifiedGuard,\n    ) -> InsertStatus<K, V> {\n        // Safety: The caller guarantees that `i` is in-bounds.\n        let entry = unsafe { table.entry(i) };\n        let meta_entry = unsafe { table.meta(i) };\n\n        // Try to claim the empty entry.\n        let found = match guard.compare_exchange(\n            entry,\n            ptr::null_mut(),\n            new_entry,\n            Ordering::Release,\n            Ordering::Acquire,\n        ) {\n            // Successfully claimed the entry.\n            Ok(_) => {\n                // Update the metadata table.\n                meta_entry.store(meta, Ordering::Release);\n\n                // Return the value we inserted.\n                return InsertStatus::Inserted;\n            }\n\n            // Lost to a concurrent update.\n            Err(found) => found.unpack(),\n        };\n\n        let (meta, status) = match EntryStatus::from(found) {\n            EntryStatus::Value(_) | EntryStatus::Copied(_) => {\n                // Safety: We performed a protected load of the pointer using a verified guard\n                // with `Acquire` and ensured that it is non-null, meaning it is valid for reads\n                // as long as we hold the guard.\n                let key = unsafe { &(*found.ptr).key };\n\n                // An entry was inserted, we have to hash it to get the metadata.\n                //\n                // The logic is the same for copied entries here as we have to\n                // check if the key matches and continue the update in the new table.\n                let hash = self.hasher.hash_one(key);\n                (meta::h2(hash), EntryStatus::Value(found))\n            }\n\n            // The entry was deleted or null copied.\n            EntryStatus::Null => (meta::TOMBSTONE, EntryStatus::Null),\n        };\n\n        // Ensure the meta table is updated to keep the probe chain alive for readers.\n        if meta_entry.load(Ordering::Relaxed) == meta::EMPTY {\n            meta_entry.store(meta, Ordering::Release);\n        }\n\n        InsertStatus::Found(status)\n    }"
}