{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<core::mem::ManuallyDrop<T> as CheckBytes<C>>::check_bytes`",
    "file": "bytecheck-0.8.1/src/lib.rs",
    "start_line": 415,
    "start_col": 5,
    "end_line": 434,
    "end_col": 6,
    "code_snippet": "unsafe fn check_bytes(\n        value: *const Self,\n        c: &mut C,\n    ) -> Result<(), C::Error> {\n        // SAFETY: Because `ManuallyDrop<T>` is `#[repr(transparent)]`, a\n        // pointer to a `ManuallyDrop<T>` is guaranteed to be the same as a\n        // pointer to `T`. We can't call `.cast()` here because `T` may be\n        // an unsized type.\n        let inner_ptr =\n            unsafe { core::mem::transmute::<*const Self, *const T>(value) };\n        // SAFETY: The caller has guaranteed that `value` is aligned for\n        // `ManuallyDrop<T>` and points to enough bytes to represent\n        // `ManuallyDrop<T>`. Since `ManuallyDrop<T>` is `#[repr(transparent)]`,\n        // `inner_ptr` is also aligned for `T` and points to enough bytes to\n        // represent it.\n        unsafe {\n            T::check_bytes(inner_ptr, c)\n                .trace(\"while checking inner value of `ManuallyDrop`\")\n        }\n    }"
}