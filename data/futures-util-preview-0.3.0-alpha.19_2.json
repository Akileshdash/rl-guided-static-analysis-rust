{
    "level": "Warning",
    "analyzer": "UnsafeDestructor",
    "op_type": null,
    "description": "unsafe block detected in drop",
    "file": "futures-util-preview-0.3.0-alpha.19/src/stream/futures_unordered/mod.rs",
    "start_line": 443,
    "start_col": 1,
    "end_line": 443,
    "end_col": 41,
    "code_snippet": "impl<Fut> Drop for FuturesUnordered<Fut> {\n    fn drop(&mut self) {\n        // When a `FuturesUnordered` is dropped we want to drop all futures\n        // associated with it. At the same time though there may be tons of\n        // wakers flying around which contain `Task<Fut>` references\n        // inside them. We'll let those naturally get deallocated.\n        unsafe {\n            while !self.head_all.is_null() {\n                let head = self.head_all;\n                let task = self.unlink(head);\n                self.release_task(task);\n            }\n        }\n\n        // Note that at this point we could still have a bunch of tasks in the\n        // ready to run queue. None of those tasks, however, have futures\n        // associated with them so they're safe to destroy on any thread. At\n        // this point the `FuturesUnordered` struct, the owner of the one strong\n        // reference to the ready to run queue will drop the strong reference.\n        // At that point whichever thread releases the strong refcount last (be\n        // it this thread or some other thread as part of an `upgrade`) will\n        // clear out the ready to run queue and free all remaining tasks.\n        //\n        // While that freeing operation isn't guaranteed to happen here, it's\n        // guaranteed to happen \"promptly\" as no more \"blocking work\" will\n        // happen while there's a strong refcount held.\n    }\n}"
}