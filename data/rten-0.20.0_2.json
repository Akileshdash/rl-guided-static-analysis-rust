{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `gemm::kernels::simd_generic::simd_gemv`",
    "file": "rten-0.20.0/src/gemm/kernels/simd_generic.rs",
    "start_line": 13,
    "start_col": 1,
    "end_line": 102,
    "end_col": 2,
    "code_snippet": "pub fn simd_gemv<I: Isa, const NR_REGS: usize>(\n    isa: I,\n    out: MatVecOutput<f32, f32>,\n    a: &[f32],\n    b: Matrix,\n    alpha: f32,\n) {\n    // Handle cases where `b` does not have unit stride.\n    if b.row_stride() == 1 {\n        return simd_gemv_transposed(isa, out, a, b, alpha);\n    } else if b.col_stride() != 1 {\n        return simd_gemv_fallback(out, a, b, alpha);\n    }\n\n    assert_eq!(a.len(), b.rows());\n    assert_eq!(out.data.len(), b.cols());\n    assert_eq!(b.col_stride(), 1);\n\n    let ops = isa.f32();\n    let out_ptr = out.data.as_mut_ptr();\n    let a_ptr = a.as_ptr();\n    let b_ptr = b.storage().as_ptr();\n    let b_row_stride = b.row_stride();\n    let v_len = ops.len();\n\n    let mut b_tiles = range_chunks_exact(0..b.cols(), NR_REGS * v_len);\n    for b_tile in b_tiles.by_ref() {\n        let mut acc = [ops.zero(); NR_REGS];\n        unroll_loop!(0..a.len(), k, 4, {\n            let a_elt = unsafe { *a_ptr.add(k) };\n            let a_elts = ops.splat(a_elt);\n\n            // Pre-fetch the current row for the next column tile.\n            ops.prefetch(unsafe { b_ptr.add(k * b_row_stride + b_tile.start + NR_REGS + v_len) });\n\n            for i in 0..NR_REGS {\n                let b_elts = unsafe {\n                    ops.load_ptr(b_ptr.add(k * b_row_stride + b_tile.start + i * ops.len()))\n                };\n                acc[i] = ops.mul_add(a_elts, b_elts, acc[i]);\n            }\n        });\n\n        if alpha != 1. {\n            let alpha_vec = ops.splat(alpha);\n            for i in 0..NR_REGS {\n                acc[i] = ops.mul(acc[i], alpha_vec);\n            }\n        }\n\n        let get_out_tile_ptr = |i| unsafe { out_ptr.add(b_tile.start + i * v_len) };\n\n        if out.beta == 0. {\n            for i in 0..NR_REGS {\n                unsafe {\n                    ops.store_ptr(acc[i], get_out_tile_ptr(i) as *mut f32);\n                }\n            }\n        } else if out.beta == 1. {\n            for i in 0..NR_REGS {\n                let out_tile_ptr = get_out_tile_ptr(i);\n                let out_tile = unsafe { ops.load_ptr(out_tile_ptr as *mut f32) };\n                let out_tile = ops.add(out_tile, acc[i]);\n                unsafe { ops.store_ptr(out_tile, out_tile_ptr as *mut f32) };\n            }\n        } else {\n            let beta_vec = ops.splat(out.beta);\n            for i in 0..NR_REGS {\n                let out_tile_ptr = get_out_tile_ptr(i);\n                let out_tile = unsafe { ops.load_ptr(out_tile_ptr as *mut f32) };\n                let out_tile = ops.mul_add(out_tile, beta_vec, acc[i]);\n                unsafe { ops.store_ptr(out_tile, out_tile_ptr as *mut f32) };\n            }\n        }\n    }\n\n    for c in b_tiles.remainder() {\n        let mut acc = 0.;\n        for (k, ax) in a.iter().enumerate() {\n            acc += ax * unsafe { *b_ptr.add(k * b_row_stride + c) };\n        }\n        let out_el = unsafe { out.data.get_unchecked_mut(c) };\n        let tmp = if out.beta == 0. {\n            0.\n        } else {\n            unsafe { out_el.assume_init() }\n        };\n        out_el.write(out.beta * tmp + acc * alpha);\n    }\n}"
}