{
    "level": "Warning",
    "analyzer": "SendSyncVariance",
    "op_type": "NaiveSyncForSync/RelaxSync",
    "description": "Suspicious impl of `Sync` found",
    "file": "wayland-client-0.31.11/src/lib.rs",
    "start_line": 219,
    "start_col": 9,
    "end_line": 219,
    "end_col": 61,
    "code_snippet": "wayland_scanner::generate_interfaces!(\"wayland.xml\");\n    }\n    wayland_scanner::generate_client_code!(\"wayland.xml\");\n}\n\n/// Trait representing a Wayland interface\npub trait Proxy: Clone + std::fmt::Debug + Sized {\n    /// The event enum for this interface\n    type Event;\n    /// The request enum for this interface\n    type Request<'a>;\n\n    /// The interface description\n    fn interface() -> &'static Interface;\n\n    /// The ID of this object\n    fn id(&self) -> ObjectId;\n\n    /// The version of this object\n    fn version(&self) -> u32;\n\n    /// Checks if the Wayland object associated with this proxy is still alive\n    fn is_alive(&self) -> bool {\n        if let Some(backend) = self.backend().upgrade() {\n            backend.info(self.id()).is_ok()\n        } else {\n            false\n        }\n    }\n\n    /// Access the user-data associated with this object\n    fn data<U: Send + Sync + 'static>(&self) -> Option<&U>;\n\n    /// Access the raw data associated with this object.\n    ///\n    /// For objects created using the scanner-generated methods, this will be an instance of the\n    /// [`QueueProxyData`] type.\n    fn object_data(&self) -> Option<&Arc<dyn ObjectData>>;\n\n    /// Access the backend associated with this object\n    fn backend(&self) -> &backend::WeakBackend;\n\n    /// Create an object proxy from its ID\n    ///\n    /// Returns an error this the provided object ID does not correspond to\n    /// the `Self` interface.\n    ///\n    /// **Note:** This method is mostly meant as an implementation detail to be\n    /// used by code generated by wayland-scanner.\n    fn from_id(conn: &Connection, id: ObjectId) -> Result<Self, InvalidId>;\n\n    /// Create an inert object proxy\n    ///\n    /// **Note:** This method is mostly meant as an implementation detail to be\n    /// used by code generated by wayland-scanner.\n    fn inert(backend: backend::WeakBackend) -> Self;\n\n    /// Send a request for this object.\n    ///\n    /// It is an error to use this function on requests that create objects; use\n    /// [`send_constructor()`][Self::send_constructor()] for such requests.\n    fn send_request(&self, req: Self::Request<'_>) -> Result<(), InvalidId>;\n\n    /// Send a request for this object that creates another object.\n    ///\n    /// It is an error to use this function on requests that do not create objects; use\n    /// [`send_request()`][Self::send_request()] for such requests.\n    fn send_constructor<I: Proxy>(\n        &self,\n        req: Self::Request<'_>,\n        data: Arc<dyn ObjectData>,\n    ) -> Result<I, InvalidId>;\n\n    /// Parse a event for this object\n    ///\n    /// **Note:** This method is mostly meant as an implementation detail to be\n    /// used by code generated by wayland-scanner.\n    fn parse_event(\n        conn: &Connection,\n        msg: Message<ObjectId, OwnedFd>,\n    ) -> Result<(Self, Self::Event), DispatchError>;\n\n    /// Serialize a request for this object\n    ///\n    /// **Note:** This method is mostly meant as an implementation detail to be\n    /// used by code generated by wayland-scanner.\n    #[allow(clippy::type_complexity)]\n    fn write_request<'a>(\n        &self,\n        conn: &Connection,\n        req: Self::Request<'a>,\n    ) -> Result<(Message<ObjectId, BorrowedFd<'a>>, Option<(&'static Interface, u32)>), InvalidId>;\n\n    /// Creates a weak handle to this object\n    ///\n    /// This weak handle will not keep the user-data associated with the object alive,\n    /// and can be converted back to a full proxy using [`Weak::upgrade()`].\n    ///\n    /// This can be of use if you need to store proxies in the used data of other objects and want\n    /// to be sure to avoid reference cycles that would cause memory leaks.\n    fn downgrade(&self) -> Weak<Self> {\n        Weak { backend: self.backend().clone(), id: self.id(), _iface: std::marker::PhantomData }\n    }\n}"
}