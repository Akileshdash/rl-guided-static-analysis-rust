{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `world::deferred_world::DeferredWorld::<'w>::modify_component_by_id`",
    "file": "bevy_ecs-0.16.1/src/world/deferred_world.rs",
    "start_line": 127,
    "start_col": 5,
    "end_line": 206,
    "end_col": 6,
    "code_snippet": "pub(crate) fn modify_component_by_id<R>(\n        &mut self,\n        entity: Entity,\n        component_id: ComponentId,\n        f: impl for<'a> FnOnce(MutUntyped<'a>) -> R,\n    ) -> Result<Option<R>, EntityMutableFetchError> {\n        let entity_cell = self.get_entity_mut(entity)?;\n\n        if !entity_cell.contains_id(component_id) {\n            return Ok(None);\n        }\n\n        let archetype = &raw const *entity_cell.archetype();\n\n        // SAFETY:\n        // - DeferredWorld ensures archetype pointer will remain valid as no\n        //   relocations will occur.\n        // - component_id exists on this world and this entity\n        // - ON_REPLACE is able to accept ZST events\n        unsafe {\n            let archetype = &*archetype;\n            self.trigger_on_replace(\n                archetype,\n                entity,\n                [component_id].into_iter(),\n                MaybeLocation::caller(),\n                RelationshipHookMode::Run,\n            );\n            if archetype.has_replace_observer() {\n                self.trigger_observers(\n                    ON_REPLACE,\n                    entity,\n                    [component_id].into_iter(),\n                    MaybeLocation::caller(),\n                );\n            }\n        }\n\n        let mut entity_cell = self\n            .get_entity_mut(entity)\n            .expect(\"entity access confirmed above\");\n\n        // SAFETY: we will run the required hooks to simulate removal/replacement.\n        let mut component = unsafe {\n            entity_cell\n                .get_mut_assume_mutable_by_id(component_id)\n                .expect(\"component access confirmed above\")\n        };\n\n        let result = f(component.reborrow());\n\n        // Simulate adding this component by updating the relevant ticks\n        *component.ticks.added = *component.ticks.changed;\n\n        // SAFETY:\n        // - DeferredWorld ensures archetype pointer will remain valid as no\n        //   relocations will occur.\n        // - component_id exists on this world and this entity\n        // - ON_REPLACE is able to accept ZST events\n        unsafe {\n            let archetype = &*archetype;\n            self.trigger_on_insert(\n                archetype,\n                entity,\n                [component_id].into_iter(),\n                MaybeLocation::caller(),\n                RelationshipHookMode::Run,\n            );\n            if archetype.has_insert_observer() {\n                self.trigger_observers(\n                    ON_INSERT,\n                    entity,\n                    [component_id].into_iter(),\n                    MaybeLocation::caller(),\n                );\n            }\n        }\n\n        Ok(Some(result))\n    }"
}