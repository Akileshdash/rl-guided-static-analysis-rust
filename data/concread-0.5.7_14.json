{
    "level": "Warning",
    "analyzer": "UnsafeDataflow",
    "op_type": "ReadFlow/Transmute",
    "description": "Potential unsafe dataflow issue in `internals::bptree::node::Branch::<K, V>::add_node_left`",
    "file": "concread-0.5.7/src/internals/bptree/node.rs",
    "start_line": 1227,
    "start_col": 5,
    "end_line": 1356,
    "end_col": 6,
    "code_snippet": "pub(crate) fn add_node_left(\n        &mut self,\n        lnode: *mut Node<K, V>,\n        sibidx: usize,\n    ) -> BranchInsertState<K, V> {\n        debug_assert_branch!(self);\n        if self.count() == L_CAPACITY {\n            if sibidx == self.count() {\n                // If sibidx == self.count, then we must be going into max - 1.\n                //    [   k1, k2, k3, k4, k5, k6   ]\n                //    [ v1, v2, v3, v4, v5, v6, v7 ]\n                //                            ^ ^-- sibidx\n                //                             \\---- where left should go\n                //\n                //    [   k1, k2, k3, k4, k5, xx   ]\n                //    [ v1, v2, v3, v4, v5, v6, xx ]\n                //\n                //    [   k1, k2, k3, k4, k5, xx   ]    [   k6   ]\n                //    [ v1, v2, v3, v4, v5, v6, xx ] -> [ ln, v7 ]\n                //\n                // So in this case we drop k6, and return a split.\n                let max = self.nodes[BV_CAPACITY - 1];\n                let _kdrop =\n                    unsafe { ptr::read(self.key.get_unchecked(L_CAPACITY - 1)).assume_init() };\n                self.dec_count();\n                BranchInsertState::Split(lnode, max)\n            } else if sibidx == (self.count() - 1) {\n                // If sibidx == (self.count - 1), then we must be going into max - 2\n                //    [   k1, k2, k3, k4, k5, k6   ]\n                //    [ v1, v2, v3, v4, v5, v6, v7 ]\n                //                         ^ ^-- sibidx\n                //                          \\---- where left should go\n                //\n                //    [   k1, k2, k3, k4, dd, xx   ]\n                //    [ v1, v2, v3, v4, v5, xx, xx ]\n                //\n                //\n                // This means that we need to return v6,v7 in a split, and\n                // just append node after v5.\n                let maxn1 = self.nodes[BV_CAPACITY - 2];\n                let max = self.nodes[BV_CAPACITY - 1];\n                let _kdrop =\n                    unsafe { ptr::read(self.key.get_unchecked(L_CAPACITY - 1)).assume_init() };\n                let _kdrop =\n                    unsafe { ptr::read(self.key.get_unchecked(L_CAPACITY - 2)).assume_init() };\n                self.dec_count();\n                self.dec_count();\n                //    [   k1, k2, k3, k4, dd, xx   ]    [   k6   ]\n                //    [ v1, v2, v3, v4, v5, xx, xx ] -> [ v6, v7 ]\n                let k: K = unsafe { (*lnode).min().clone() };\n\n                unsafe {\n                    slice_insert(&mut self.key, MaybeUninit::new(k), sibidx - 1);\n                    slice_insert(&mut self.nodes, lnode, sibidx);\n                    // slice_insert(&mut self.node, MaybeUninit::new(node), sibidx);\n                }\n                self.inc_count();\n                //\n                //    [   k1, k2, k3, k4, nk, xx   ]    [   k6   ]\n                //    [ v1, v2, v3, v4, v5, ln, xx ] -> [ v6, v7 ]\n\n                BranchInsertState::Split(maxn1, max)\n            } else {\n                // All other cases;\n                //    [   k1, k2, k3, k4, k5, k6   ]\n                //    [ v1, v2, v3, v4, v5, v6, v7 ]\n                //                 ^ ^-- sibidx\n                //                  \\---- where left should go\n                //\n                //    [   k1, k2, k3, k4, dd, xx   ]\n                //    [ v1, v2, v3, v4, v5, xx, xx ]\n                //\n                //    [   k1, k2, k3, nk, k4, dd   ]    [   k6   ]\n                //    [ v1, v2, v3, ln, v4, v5, xx ] -> [ v6, v7 ]\n                //\n                // This means that we need to return v6,v7 in a split,, drop k5,\n                // then insert\n\n                // Setup the nodes we intend to split away.\n                let maxn1 = self.nodes[BV_CAPACITY - 2];\n                let max = self.nodes[BV_CAPACITY - 1];\n                let _kdrop =\n                    unsafe { ptr::read(self.key.get_unchecked(L_CAPACITY - 1)).assume_init() };\n                let _kdrop =\n                    unsafe { ptr::read(self.key.get_unchecked(L_CAPACITY - 2)).assume_init() };\n                self.dec_count();\n                self.dec_count();\n\n                // println!(\"pre-fixup -> {:?}\", self);\n\n                let sibnode = self.nodes[sibidx];\n                let nkey: K = unsafe { &*Node::min_raw(sibnode) }.clone();\n\n                unsafe {\n                    slice_insert(&mut self.key, MaybeUninit::new(nkey), sibidx);\n                    slice_insert(&mut self.nodes, lnode, sibidx);\n                }\n\n                self.inc_count();\n                // println!(\"post fixup -> {:?}\", self);\n\n                BranchInsertState::Split(maxn1, max)\n            }\n        } else {\n            // We have space, so just put it in!\n            //    [   k1, k2, k3, k4, xx, xx   ]\n            //    [ v1, v2, v3, v4, v5, xx, xx ]\n            //                 ^ ^-- sibidx\n            //                  \\---- where left should go\n            //\n            //    [   k1, k2, k3, k4, xx, xx   ]\n            //    [ v1, v2, v3, ln, v4, v5, xx ]\n            //\n            //    [   k1, k2, k3, nk, k4, xx   ]\n            //    [ v1, v2, v3, ln, v4, v5, xx ]\n            //\n\n            let sibnode = self.nodes[sibidx];\n            let nkey: K = unsafe { &*Node::min_raw(sibnode) }.clone();\n\n            unsafe {\n                slice_insert(&mut self.nodes, lnode, sibidx);\n                slice_insert(&mut self.key, MaybeUninit::new(nkey), sibidx);\n            }\n\n            self.inc_count();\n            // println!(\"post fixup -> {:?}\", self);\n            BranchInsertState::Ok\n        }\n    }"
}