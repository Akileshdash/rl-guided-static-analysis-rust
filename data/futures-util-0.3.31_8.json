{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `<future::future::shared::Shared<Fut> as futures_core::Future>::poll`",
    "file": "futures-util-0.3.31/src/future/future/shared.rs",
    "start_line": 260,
    "start_col": 5,
    "end_line": 359,
    "end_col": 6,
    "code_snippet": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n        let this = &mut *self;\n\n        let inner = this.inner.take().expect(\"Shared future polled again after completion\");\n\n        // Fast path for when the wrapped future has already completed\n        if inner.notifier.state.load(Acquire) == COMPLETE {\n            // Safety: We're in the COMPLETE state\n            return unsafe { Poll::Ready(inner.take_or_clone_output()) };\n        }\n\n        inner.record_waker(&mut this.waker_key, cx);\n\n        match inner\n            .notifier\n            .state\n            .compare_exchange(IDLE, POLLING, SeqCst, SeqCst)\n            .unwrap_or_else(|x| x)\n        {\n            IDLE => {\n                // Lock acquired, fall through\n            }\n            POLLING => {\n                // Another task is currently polling, at this point we just want\n                // to ensure that the waker for this task is registered\n                this.inner = Some(inner);\n                return Poll::Pending;\n            }\n            COMPLETE => {\n                // Safety: We're in the COMPLETE state\n                return unsafe { Poll::Ready(inner.take_or_clone_output()) };\n            }\n            POISONED => panic!(\"inner future panicked during poll\"),\n            _ => unreachable!(),\n        }\n\n        let waker = waker_ref(&inner.notifier);\n        let mut cx = Context::from_waker(&waker);\n\n        struct Reset<'a> {\n            state: &'a AtomicUsize,\n            did_not_panic: bool,\n        }\n\n        impl Drop for Reset<'_> {\n            fn drop(&mut self) {\n                if !self.did_not_panic {\n                    self.state.store(POISONED, SeqCst);\n                }\n            }\n        }\n\n        let mut reset = Reset { state: &inner.notifier.state, did_not_panic: false };\n\n        let output = {\n            let future = unsafe {\n                match &mut *inner.future_or_output.get() {\n                    FutureOrOutput::Future(fut) => Pin::new_unchecked(fut),\n                    _ => unreachable!(),\n                }\n            };\n\n            let poll_result = future.poll(&mut cx);\n            reset.did_not_panic = true;\n\n            match poll_result {\n                Poll::Pending => {\n                    if inner.notifier.state.compare_exchange(POLLING, IDLE, SeqCst, SeqCst).is_ok()\n                    {\n                        // Success\n                        drop(reset);\n                        this.inner = Some(inner);\n                        return Poll::Pending;\n                    } else {\n                        unreachable!()\n                    }\n                }\n                Poll::Ready(output) => output,\n            }\n        };\n\n        unsafe {\n            *inner.future_or_output.get() = FutureOrOutput::Output(output);\n        }\n\n        inner.notifier.state.store(COMPLETE, SeqCst);\n\n        // Wake all tasks and drop the slab\n        let mut wakers_guard = inner.notifier.wakers.lock().unwrap();\n        let mut wakers = wakers_guard.take().unwrap();\n        for waker in wakers.drain().flatten() {\n            waker.wake();\n        }\n\n        drop(reset); // Make borrow checker happy\n        drop(wakers_guard);\n\n        // Safety: We're in the COMPLETE state\n        unsafe { Poll::Ready(inner.take_or_clone_output()) }\n    }"
}