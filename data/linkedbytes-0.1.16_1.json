{
    "level": "Info",
    "analyzer": "UnsafeDataflow",
    "op_type": "Transmute",
    "description": "Potential unsafe dataflow issue in `LinkedBytes::sync_write_all_vectored`",
    "file": "linkedbytes-0.1.16/src/lib.rs",
    "start_line": 240,
    "start_col": 5,
    "end_line": 307,
    "end_col": 6,
    "code_snippet": "pub fn sync_write_all_vectored<W: std::io::Write>(\n        &mut self,\n        writer: &mut W,\n    ) -> std::io::Result<()> {\n        self.ioslice.clear();\n        self.ioslice.reserve(self.list.len() + 1);\n        // prepare ioslice\n        for node in self.list.iter() {\n            let bytes = node.as_ref();\n            if bytes.is_empty() {\n                continue;\n            }\n            // SAFETY: we can guarantee that the lifetime of `bytes` can't outlive self\n            self.ioslice\n                .push(IoSlice::new(unsafe { &*(bytes as *const _) }));\n        }\n        if !self.bytes.is_empty() {\n            self.ioslice\n                .push(IoSlice::new(unsafe { &*(self.bytes.as_ref() as *const _) }));\n        }\n\n        // do write_all_vectored\n        let (mut base_ptr, mut len) = (self.ioslice.as_mut_ptr(), self.ioslice.len());\n        while len != 0 {\n            let ioslice = unsafe { std::slice::from_raw_parts(base_ptr, len) };\n            let n = writer.write_vectored(ioslice)?;\n            if n == 0 {\n                return Err(std::io::ErrorKind::WriteZero.into());\n            }\n            // Number of buffers to remove.\n            let mut remove = 0;\n            // Total length of all the to be removed buffers.\n            let mut accumulated_len = 0;\n            for buf in ioslice.iter() {\n                if accumulated_len + buf.len() > n {\n                    break;\n                } else {\n                    accumulated_len += buf.len();\n                    remove += 1;\n                }\n            }\n\n            // adjust the outer [IoSlice]\n            base_ptr = unsafe { base_ptr.add(remove) };\n            len -= remove;\n            if len == 0 {\n                assert!(\n                    n == accumulated_len,\n                    \"advancing io slices beyond their length\"\n                );\n            } else {\n                // adjust the inner IoSlice\n                let inner_slice = unsafe { &mut *base_ptr };\n                let (inner_ptr, inner_len) = (inner_slice.as_ptr(), inner_slice.len());\n                let remaining = n - accumulated_len;\n                assert!(\n                    remaining <= inner_len,\n                    \"advancing io slice beyond its length\"\n                );\n                let new_ptr = unsafe { inner_ptr.add(remaining) };\n                let new_len = inner_len - remaining;\n                *inner_slice =\n                    IoSlice::new(unsafe { std::slice::from_raw_parts(new_ptr, new_len) });\n            }\n        }\n        self.ioslice.clear();\n        Ok(())\n    }"
}